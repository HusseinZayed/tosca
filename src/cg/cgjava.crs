// Copyright (c) 2015 IBM Corporation.
/*
 * CRSX Java backend code generator
 *
 * Generate Java 8 source code from core Crsx.
 * 
 * Only one Java file is created from a Crsx system. This will have to change in order to scale.
 */
CG[(

$Lax;

$AddGrammar["net.sf.crsx.text.Text"];
$AddGrammar["org.crsx.core.CoreMetaParser"];

$CheckGrammar["net.sf.crsx.text.Text"];
$CheckGrammar["org.crsx.core.CoreMetaParser"];

$Use["core/Core.crs"];
$Use["std/core.crs"];
$Use["std/string.crs"];
$Use["std/num.crs"];
$Use["std/text.crs"];
$Use["std/list.crs"];
$Use["std/pair.crs"];
$Use["system.crs"];
$Use["cg/cgutils.crs"];

// ===== API

/*
 * Generates Java code from a sorted core Crsx system
 * @param System The crsx system
 */
CrsxToJava[System] :: Text;
CrsxToJava[System[#url, #modules]] 
→ JavaUnits[#url, MapValues[#modules]];

// --- Generate code.
// 
// Each Crsx module corresponds to a single Java class. 
// 
// Each rule declaration corresponds to a single Java function.
//
JavaUnits[$String, $List[Module]] :: Text;
JavaUnits[#url, #modules] 
→ %n⟦/** Generated File */«PackageDeclaration»
import static org.crsx.runtime.ConstructionDescriptor.makeData;
import static org.crsx.runtime.ConstructionDescriptor.makeFunction;
import static org.crsx.runtime.Normalizer.thunk;
import static org.crsx.runtime.Normalizer.force;
import static org.crsx.runtime.Normalizer.forceSub;
import static org.crsx.runtime.Reference.safeRef;

import org.crsx.runtime.*;
import org.crsx.runtime.ConstructionDescriptor.*;
import static org.crsx.runtime.Primitives.*;
«TextFold[Map[module.JavaUnit[#url, module], #modules], %n⟨⟩]»⟧;

/* Generate class for the given module */ 
JavaUnit[$String, Module] :: Text;
JavaUnit[#mainurl, Module[#url, Loaded[LoadedContent[#rules, #datasorts, #funcsorts]]]] 
→ %n⟦«JavaClassVisibility[#mainurl, #url]» class †«ClassName[#url]»
{⟦«TextFold[Map[sort.JavaDataDesc[sort], MapValues[#datasorts]], %n⟨⟩]»
«TextFold[Map[sort.JavaFuncDesc[ClassName[#url], sort], MapValues[#funcsorts]], %n⟨⟩]»
«TextFold[Map[cons.JavaMethod[cons, #rules, #datasorts, #funcsorts], MapKeys[#rules]], %n⟨⟩]»
«InitModule[#datasorts, #funcsorts]»⟧
}⟧;

JavaClassVisibility[$String, $String] :: Text;
JavaClassVisibility[#mainurl, #url] 
→ $[If, $[Equal, #mainurl, #url], %n⟦public⟧, %n⟦static⟧];

JavaDataDesc[Core_cdecl_sort] :: Text;
JavaDataDesc[%cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧]
→ TextFold[Map[form.JavaFormDesc[form], #cform*], %n⟦⟧];

JavaFormDesc[Core_cform_sort] :: Text;
JavaFormDesc[%cform⟦ ##CONSTRUCTOR ##csorts? ⟧] 
→ %n⟦
final public static ConstructionDescriptor «Descriptor[#CONSTRUCTOR]» = makeData(«Text-QuoteEscape[#CONSTRUCTOR]»);⟧;

JavaFuncDesc[$String, Core_cdecl_sort] :: Text;
JavaFuncDesc[#classname, %cdecl⟦ func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧]
→ %n⟦final public static DynamicFunctionDescriptor «Descriptor[#CONSTRUCTOR]» = makeFunction(«Text-QuoteEscape[#CONSTRUCTOR]», †«#classname».class, "«ToJavaId[#CONSTRUCTOR]»");⟧; 

/* Generate methods for module rules */ 
JavaMethod[$String, Map[$String, $List[Core_cdecl_sort]],  
           Map[$String, Core_cdecl_sort], Map[$String, Core_cdecl_sort]] :: Text;
JavaMethod[#constructor, #rules, #datasorts, #funcsorts] 
→ %n⟦final public static boolean «JavaMethodSig[UnSOME[MapGet[#funcsorts, #constructor]], UnSOME[MapGet[#rules, #constructor]]]»⟧;

JavaMethodSig[Core_cdecl_sort, $List[Core_cdecl_sort]] :: Text;
JavaMethodSig[%cdecl⟦ func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧, #rules] 
→ %n⟦«ToJavaId[#CONSTRUCTOR]»(Sink sink, int shared«JavaSigMaybeArgs[
                SetSink[AddThunk[AddThunk[NewEnv, %n⟦sink⟧], Descriptor[#CONSTRUCTOR]], %n⟦sink⟧], #csorts?, #rules]»⟧;  // )

JavaSigMaybeArgs[JavaEnv, $List[Core_csorts_sort], $List[Core_cdecl_sort]] :: Text;
JavaSigMaybeArgs[#env, %csorts?⟦⟧, #rules]
→ JavaBody[#env, #rules];

JavaSigMaybeArgs[#env, %csorts?⟦ ( ##csort* ) ⟧, #rules]
→ JavaSigArgs[#env, #csort*, #rules];

JavaSigArgs[JavaEnv, $List[Core_csort_sort], $List[Core_cdecl_sort]] :: Text;
JavaSigArgs[#env, %csort*⟦ ⟧, #rules]
→ JavaBody[#env, #rules];

-[Fresh[term::Text]]:
JavaSigArgs[#env, %csort*⟦ ##CONSTRUCTOR ##csorts? ##csort* ⟧, #rules]
→ %n⟦, Term «term»«JavaSigArgs[AddArg[#env, term], #csort*, #rules]»⟧;

JavaBody[JavaEnv, $List[Core_cdecl_sort]] :: Text;
JavaBody[#env, #rules]
→ %n⟦) 
{⟦
if (++sink.context().sd < 256)
{⟦
«TextFold[Map[rule.JavaBodyRule[#env, rule], #rules], %n⟨⟩]»⟧
}
return «Thunk[GetThunk[#env]]»;⟧
}⟧;

/* Generates code creating fallback thunk */
Thunk[$List[Text]] :: Text;
Thunk[#texts] → %n⟦thunk(«TextFold[#texts, %n⟦, ⟧]»)⟧;

JavaBodyRule[JavaEnv, Core_cdecl_sort] :: Text;
JavaBodyRule[#env, %cdecl⟦ rule ##CONSTRUCTOR → ##cterm2 ⟧]
→ JavaContractum[#env, #cterm2];

JavaBodyRule[#env, %cdecl⟦ rule ##CONSTRUCTOR ( ##cterm* ) → ##cterm2 ⟧]
→ JavaPattern[#env, #cterm*, #cterm2];

// ----- Naive pattern matching. 

JavaPattern[JavaEnv, $List[Core_cterm_sort], Core_cterm_sort] :: Text;

-[Fresh[label::Text]]:
JavaPattern[#env, #cterms, #contractum]
→ %n⟦«label»:{⟦«JavaCasePattern[SetLabel[#env, label], #cterms, #contractum]»⟧
}⟧;

JavaCasePattern[JavaEnv, $List[Core_cterm_sort], Core_cterm_sort] :: Text;
JavaCasePattern[#env, #cterms, #contractum]
→ TextFold[MapMThen[
             state term.JavaPatternTerm[SetArgs[state, Tail[GetArgs[state]]], term, Head[GetArgs[state]]], 
             #env, #cterms, state.JavaContractum[state, #contractum]], %n⟦⟧];

// --- Term pattern matching

JavaPatternTerm[JavaEnv, Core_cterm_sort, Text /* Current term */] :: Pair[JavaEnv, Text];

JavaPatternTerm[#env, %cterm⟦ ##CONSTRUCTOR ##cterms? ⟧, #term]
→ PairCons[#env, %n⟦
«#term» = force(sink.context(), «#term»);
if («#term».descriptor() != «Descriptor[#CONSTRUCTOR]»)
{⟦
  break «GetLabel[#env]»;⟧
}«JavaPatternMaybeTerms[#env, #cterms?, #term]»⟧];

JavaPatternTerm[#env, %cterm⟦ ##cliteral ⟧, #term]
→ $[Error, "Internal error: invalid pattern matching on literal"];

-[Data[#term]]:
JavaPatternTerm[#env, %cterm⟦ ##METAVAR ##cterms? ⟧, #term]
→ PairCons[AddMeta[#env, #METAVAR, #term], %n⟦
/* «Text-CommentToken[#METAVAR]»=«Text-CommentToken[$[Show, #term]]» */⟧];  

JavaPatternTerm[#env, %cterm⟦ ##VARIABLE ⟧, #term] 
→ JavaPatternVariable[MapGetVar[#env, #VARIABLE], #env, #VARIABLE, #term];

JavaPatternMaybeTerms[JavaEnv, $List[Core_cterms_sort], Text] :: Text;
JavaPatternMaybeTerms[#env, %cterms?⟦⟧, #term]
→ %n⟦⟧;

JavaPatternMaybeTerms[#env, %cterms?⟦ ( ##cterm* ) ⟧, #term]
→ %n⟦⟧;

// --- Variable pattern matching outside of meta

JavaPatternVariable[Option[VarEntry], JavaEnv, $String, Text /* Current term */] :: Pair[JavaEnv, Text];

// First variable occurrence: it's a free variable.
JavaPatternVariable[NONE, #env, #variable, #term] 
→ PairCons[AddFreeVar[#env, #variable, #term], %n⟦
Variable «#variable» = «#term».variable();⟧];

// Bound variable
// TODO: update term's parent with evaluated term.
// TODO: release acquired references.
JavaPatternVariable[SOME[BOUND], #env, #variable, #term] 
→ PairCons[#env, %n⟦
«#term» = force(«GetSink[#env]».context(), «#term»);
if («#variable» != VARIABLE(«#term»)) 
{⟦
  break «GetLabel[#env]»;⟧
}⟧];

// ----- Contraction

JavaContractum[JavaEnv, Core_cterm_sort] :: Text;
JavaContractum[#env, #term] → SendTerm[#env, #term];

// ---- Contraction send mode

SendTerm[JavaEnv, Core_cterm_sort] :: Text;

SendTerm[#env, %cterm⟦ ##CONSTRUCTOR ##cterms? ⟧]
→ SendConstruction[#env, #CONSTRUCTOR, #cterms?];

SendTerm[#env, %cterm⟦ ##cliteral ⟧]
→ %n⟦¶«GetSink[#env]».literal(«Literal[#cliteral]»);«SendEndTerm[GetTail[#env]]»⟧;

SendTerm[#env, %cterm⟦ ##VARIABLE ⟧] 
→ %n⟦¶«SendVariable[#env, #VARIABLE]»«SendEndTerm[GetTail[#env]]»⟧;

SendTerm[%cterm⟦ ##VARIABLE ˢ ⟧] 
→ %n⟦⟧; // TODO

SendTerm[#env, %cterm⟦ ##METAVAR ##cterms? ⟧] 
→ %n⟦«SendMeta[#env, #METAVAR, #cterms?]»«SendEndTerm[GetTail[#env]]»⟧;

SendTerm[#env, %cterm⟦ [ ##VARIABLE ] ##cterm ⟧]  
→ %n⟦«SendEndTerm[GetTail[#env]]»⟧; // TODO

SendEndTerm[$Boolean] :: Text;
SendEndTerm[$True]  → %n⟦return true;⟧;
SendEndTerm[$False] → %n⟦⟧;

// ---- SEND construction

SendConstruction[JavaEnv, $String, $List[Core_cterms_sort]] :: Text;

SendConstruction[#env, #constructor, #cterms?]
→ %n⟦
«GetSink[#env]».start(«Descriptor[#constructor]»);«SendMaybeTerms[UnsetTail[#env], #cterms?]»
«GetSink[#env]».end();«SendEndTerm[GetTail[#env]]»⟧;

SendMaybeTerms[JavaEnv, $List[Core_cterms_sort]] :: Text;
SendMaybeTerms[#env, %cterms?⟦              ⟧] → %n⟦⟧;
SendMaybeTerms[#env, %cterms?⟦ ( ##cterm* ) ⟧] → TextFold[Map[term.SendTerm[#env, term], #cterm*], %n⟦⟧];

// ---- SEND scope variable

SendVariable[JavaEnv, $String] :: Text;
SendVariable[#env, #var]
→ %n⟦¶«GetSink[#env]».use(«GetVariable[#var]»);⟧;

// ---- SEND metavar

SendMeta[JavaEnv, $String, $List[Core_cterms_sort]] :: Text;

// No argument -> just send value.
SendMeta[#env, #metavar, %cterms?⟦⟧] 
→ %n⟦
«GetSink[#env]».copy(«GetMeta[#env, #metavar]».ref());⟧;

// With arguments -> substitute.
// Start by computing arguments and then call substitute.
SendMeta[#env, #metavar, %cterms?⟦ ( ##cterm* ) ⟧] 
→ SetTerms[#env, #cterm*, terms.SendSubstitutes[#env, #metavar, terms]];

SendSubstitutes[JavaEnv, $String, $List[Text]] :: Text;
SendSubstitutes[#env, #metavar, #substitutes]
→ %n⟦
«GetSink[#env]».substitute(«GetMeta[#metavar]».ref(), new Variable[] { «TextFold[GetBinders[#env], %n⟦, ⟧]» }, new Term[] {«TextFold[#substitutes, %n⟦, ⟧]»});⟧;

//SendBinders[Crsx_nextBinder_sort] :: Text;
//
//{#E}SendBinders[%nextBinder⟦ ##binder ##nextBinder ⟧] → {#E}SendBindersKey[BinderKey[#binder], #binder, #nextBinder];
//
//{#E; "$sink":TEXT[#sink]; "$binders":TEXTS[#binders]}
//SendBinders[%nextBinder⟦ . ##freeTerm         ⟧] 
//→
//%n⟦¶«#sink».binds(new Variable[] {«Text-ConcatSep[#binders, %n⟦,⟧]»});«{#E}SendFreeTerm[#freeTerm]»⟧;
//
//SendBindersKey[$String, Crsx_binder_sort, Crsx_nextBinder_sort] :: Text;
//
//-[Fresh[var::Text], Data[#key]]:
//{#E; "$sink":TEXT[#sink]; "$binders": TEXTS[#binders]}
//
//// Use expanded syntax as crsx4 does not support escaped #
//SendBindersKey[#key, Crsx_binder[(), Crsx_variable[#linear?, #VARIABLE, #linear?2, #functional?, #varsort?]], #nextBinder]
////SendBindersKey[#key, %binder⟦ ##linear? ##VARIABLE ##linear?2 ##functional? ##varsort?  ⟧, #nextBinder]
//→
//%n⟦¶Variable «var» = «#sink».context().makeVariable("†«#VARIABLE»");«
//      {#E; var: BOUND; #key: TEXT[var]; "$binders": TEXTS[Concat[#binders, (var;)]]}SendBinders[#nextBinder]»⟧;
//
//// --- SEND properties
//
//SendMaybeProperties[$List[Crsx_properties_sort]] :: Text;
//
//{#E}SendMaybeProperties[%properties?⟦                 ⟧] → %n⟦⟧;
//{#E}SendMaybeProperties[%properties?⟦ {             } ⟧] → %n⟦⟧;
//{#E}SendMaybeProperties[%properties?⟦ { ##property* } ⟧] → {#E; "$tail": NO}SendPropertyList[#property*];
//
//SendPropertyList[$List[Crsx_property_sort]] :: Text;
//
//{#E}SendPropertyList[%property*⟦                        ⟧] → %n⟦⟧;
//{#E}SendPropertyList[%property*⟦ ##property ##property* ⟧] → %n⟦«{#E}SendProperty[#property]»«{#E}SendPropertyList[#property*]»⟧;
//
//SendProperty[Crsx_property_sort] :: Text;
//
//{#E; "$sink": TEXT[#sink]}
//SendProperty[%property⟦ ##METAVAR ⟧] 
//→
//%n⟦«#sink».properties(safeRef(«{#E}MetaVar[#METAVAR]»));⟧;       
//                          
//{#E}SendProperty[%property⟦ ##METAVAR : ##freeTerm  ⟧] 
//→ 
//{#E}SetFreeTerm[#freeTerm, ok value.SendMetaProperty[ok, #METAVAR, value]];                        
//
//{#E}SendProperty[%property⟦ ##VARIABLE : ##freeTerm ⟧] 
//→ 
//{#E}SetFreeTerm[#freeTerm, ok value.SendVariableProperty[ok, #VARIABLE, value]];               
//                               
//{#E}SendProperty[%property⟦ ##STRING : ##freeTerm   ⟧] 
//→ 
//{#E}SetFreeTerm[#freeTerm, ok value.SendNamedProperty[ok, UnString[#STRING], value]];               
//
//{#E}SendProperty[%property⟦ ##CONSTRUCTOR : ##freeTerm ⟧]                         
//→ 
//{#E}SetFreeTerm[#freeTerm, ok value.SendNamedProperty[ok, #CONSTRUCTOR, value]];               
//
//{#E}SendProperty[%property⟦ ¬ ##METAVAR            ⟧] → $[Error, "Internal error: test for property absence not allowed in contraction"];
//{#E}SendProperty[%property⟦ ##VARIABLE             ⟧] → $[Error, "Internal error: test for variable presence not allowed in contraction"];                                               
//{#E}SendProperty[%property⟦ ¬ ##VARIABLE           ⟧] → $[Error, "Internal error: test for variable absence not allowed in contraction"];                                          
//{#E}SendProperty[%property⟦ ##STRING               ⟧] → $[Error, "Internal error: test for named property presence not allowed in contraction"];                                             
//{#E}SendProperty[%property⟦ ¬ ##STRING             ⟧] → $[Error, "Internal error: test for named property absence not allowed in contraction"];                                            
//
//SendMetaProperty[OK_SORT, $String, Text] :: Text;
//
//{#E; "$sink": TEXT[#sink]}
//SendMetaProperty[OK, #METAVAR, #value] 
//→
//%n⟦¶«{#E}MetaVar[#METAVAR]» = force(«#sink».context(), «{#E}MetaVar[#METAVAR]»);
//Sink.property(«#sink», «{#E}MetaVar[#METAVAR]», «#value»);⟧;           
//
//SendVariableProperty[OK_SORT, $String, Text] :: Text;
//
//{#E; "$sink": TEXT[#sink]}
//SendVariableProperty[OK, #VARIABLE, #value] 
//→
//%n⟦¶«#sink».propertyVariable(«{#E}Variable[#VARIABLE]», «#value»);⟧;           
//
//SendNamedProperty[OK_SORT, $String, Text] :: Text;
//
//{#E; "$sink": TEXT[#sink]}
//SendNamedProperty[OK, #name, #value] 
//→
//%n⟦¶«#sink».propertyNamed(«Text-QuoteEscape[#name]», «#value»);⟧;           
//
//// --- SEND var
//
//SendVariable[$String] :: Text;
//
//-[Data[#key]]:
//{#E}SendVariable[#key]
//→
//{#E}SendVariable0[$[{#E}Get, #key, NOENTRY], #key];
//
//SendVariable0[STRING_ENTRY, $String] :: Text;
/
//{#E; "$sink":TEXT[#sink]; "$tail":#tail}
//SendVariable0[TEXT[#var], #key]
//→
//%n⟦¶«#sink».use(«#var»);«SendTail[#tail]»⟧;
//
//// If no entry, assume it's a fresh variable. Experimental.
////-[Fresh[var::Text]]:
////{#E; "$sink":TEXT[#sink];}
//{#E}SendVariable0[NOENTRY, #key]
//→
//$[Error, $[:, "Internal error: undefined variable key ", #key]];
////%n⟦¶Variable «var» = «#sink».context().makeVariable("†«#key»");«
////      {#E; var: FRESH; #key: TEXT[var]}SendVariable[#key]»⟧;
//
//// --- SEND dispatch
//
////
//// Generate code for the dispatch expression.
////
//// The core dispatched term must always be a constructor of the form {#E}C[x₁..xᵢ.#1[x₁..xᵢ], ..., x₁..xᵢ.#N[x₁..xᵢ]],
//// where all arguments are meta-variables, potentially with binders. 
////
//// Since the dispatched term is all meta-variables (except the wrapping constructor), there is no need to construct it.
//// Instead, each meta-variable is mapped to an existing meta-variable and dereferenced as needed. Furthermore,
//// since all dispatch cases start with the same dispatched term constructor, there is also no need to dynamically check for it.
////
//// Terms must be ordered is such a way that patterns capturing terms must occur before pattern using captured terms.
//// 
//// A dispatch expression with a delay branch must always be top-level.
////
// 
//SendDispatch[Crsx_dispatch_sort] :: Text;
//
//{#E}SendDispatch[%dispatch⟦ dispatch ##freeTerm ##dispatchCases ##delayCase? ⟧]
//→
//{#E}SendDispatchTopFreeTerm[#freeTerm, ok.SendDispatchCases[ok, DesugarDispatchCases[#dispatchCases]]];
//
//// Process dispatch term: just record in the environment the meta-variable mappings
//
//SendDispatchTopFreeTerm[Crsx_freeTerm_sort, ok::OK_SORT.Text] :: Text;
//
//{#E}SendDispatchTopFreeTerm[%freeTerm⟦ ##annotations? ##properties? ##constructor [ ##terms ] ⟧, ok.#[ok]] 
//→
//{#E}SendDispatchMaybeProperties[#properties?, ok.SendDispatchTerms[ok, DesugarTerms[#terms], 0, ok.#[ok]]];
//
//-[Fallback]:
//{#E}SendDispatchTopFreeTerm[#freeTerm, ok.#[ok]] 
//→
//$[Error, $[:, "Internal Error: invalid dispatch term. Got: ", $[Show, #freeTerm]]];
//
//SendDispatchMaybeProperties[$List[Crsx_properties_sort], ok::OK_SORT.Text] :: Text;
//
//{#E}SendDispatchMaybeProperties[%properties?⟦               ⟧, ok.#[ok]] → {#E}#[OK];
//{#E}SendDispatchMaybeProperties[%properties?⟦ {           } ⟧, ok.#[ok]] → {#E}#[OK];
//{#E}SendDispatchMaybeProperties[%properties?⟦ { ##METAVAR } ⟧, ok.#[ok]] → {#E; "$dispatch$env": TEXT[{#E}MetaVar[#METAVAR]]}#[OK];
//
//-[Fallback]:
//{#E}SendDispatchMaybeProperties[#properties, ok.#[ok]] → $[Error, $[:, "Internal error: invalid dispatch term properties:", $[Show, #properties]]];
//
//SendDispatchTerms[OK_SORT, $List[Crsx_term_sort], $Numeric, ok::OK_SORT.Text] :: Text;
//
//{#E}SendDispatchTerms[OK, %term*⟦                ⟧, #position, ok.#[ok]] → {#E}#[OK];
//
//{#E}SendDispatchTerms[OK, %term*⟦ ##term ##term* ⟧, #position, ok.#[ok]] 
//→ 
//{#E}SendDispatchTerm[#term, #position, ok.SendDispatchTerms[ok, #term*, $[Plus, #position, 1], ok.#[ok]]];
//
//SendDispatchTerm[Crsx_term_sort, $Numeric, ok::OK_SORT.Text] :: Text;
//
//{#E}SendDispatchTerm[%term⟦ ##freeTerm            ⟧, #position, ok.#[ok]] → {#E}SendDispatchFreeTerm[#freeTerm, #position, ok.#[ok]]; 
//{#E}SendDispatchTerm[%term⟦ ##binder ##nextBinder ⟧, #position, ok.#[ok]] → {#E}SendDispatchBinders[%nextBinder⟦ ##binder ##nextBinder ⟧, #position, ok.#[ok]];
//
//SendDispatchFreeTerm[Crsx_freeTerm_sort, $Numeric, ok::OK_SORT.Text] :: Text;
//
//// Record which meta-variable correspond to the current dispatch argument position
//{#E}SendDispatchFreeTerm[%freeTerm⟦ ##METAVAR ##freeArguments? ⟧, #position, ok.#[ok]]
//→
//{#E}SendDispatchMeta[MetaDispatchKey[#position], MetaKey[#METAVAR], ok.#[ok]]; 
//
//{#E}SendDispatchFreeTerm[#freeTerm, #position, ok.#[ok]]
//→
//$[Error, $[:, "Internal error: dispatch term arguments must be all meta-variables. Got: ", $[Show, #freeTerm]]];
//
//SendDispatchMeta[$String, $String, ok::OK_SORT.Text] :: Text;
//
//-[Data[#dispatchKey, #metavarKey]]:
//{#E}SendDispatchMeta[#dispatchKey, #metavarKey, ok.#[ok]] → {#E; #dispatchKey: STRING[#metavarKey]}#[OK];
//
//SendDispatchBinders[Crsx_nextBinder_sort, $Numeric, ok::OK_SORT.Text] :: Text;
//
//{#E}SendDispatchBinders[%nextBinder⟦ . ##freeTerm         ⟧, #position, ok.#[ok]] → {#E}SendDispatchFreeTerm[#freeTerm,  #position, ok.#[ok]];
//
//// Not need to keep tracks of binders, as they are not materialized.
//{#E}SendDispatchBinders[%nextBinder⟦ ##binder ##nextBinder ⟧, #position, ok.#[ok]] → {#E}SendDispatchBinders[#nextBinder, #position, ok.#[ok]];
//
//// --- dispatch cases
//
//// Match the top-level properties
//SendMatchTopMaybeProperties[OK_SORT, $List[Crsx_properties_sort], ok::OK_SORT.Text] :: Text;
//
//{#E}SendMatchTopMaybeProperties[OK, %properties?⟦                 ⟧, ok.#[ok]] → {#E}#[OK];
//{#E}SendMatchTopMaybeProperties[OK, %properties?⟦ {             } ⟧, ok.#[ok]] → {#E}#[OK];
//{#E}SendMatchTopMaybeProperties[OK, %properties?⟦ { ##property* } ⟧, ok.#[ok]] → {#E; "$top-props":YES}SendMatchProperties[OK, #property*, %n⟦⟧, ok.#[ok]];
//→ 
//{#E; "$binders": TEXTS[{#E}DispatchedMetaVarBinders[#position]]; "$top-props":NO}  // Gets the binders on the Java method signature.
//  SendMatchTerm[#term, NONE, {#E}DispatchedMetaVar[#position], #position, ok.
//  SendMatchTopArguments[ok, #term*, $[Plus, #position, 1], ok.#[ok]]];
//
//// Match current term 
//{$String:STRING_ENTRY}
//SendMatchTerm[Crsx_term_sort, Option[Text] /* parent term (empty if top) */, Text /* Current term */, $Numeric /* term position*/, ok::OK_SORT.Text] :: Text;
//
//{#E}SendMatchTerm[%term⟦ ##freeTerm            ⟧, #parent, #term, #termpos, ok.#[ok]] 
//→ 
//{#E; "$binders": TEXTS[()]}SendMatchFreeTerm[#freeTerm, #term, ok.#[ok]];
//
//{#E}SendMatchTerm[%term⟦ ##binder ##nextBinder ⟧, NONE, #term, #termpos, ok.#[ok]]  // $binders is already set.
//→ 
//{#E}SendMatchNextBinder[%nextBinder⟦ ##binder ##nextBinder⟧, NONE, #term, #termpos, 0, ok.#[ok]];
//
//{#E}SendMatchTerm[%term⟦ ##binder ##nextBinder ⟧, SOME[#parent], #term, #termpos, ok.#[ok]] 
//→ 
//{#E;"$binders": TEXTS[()]} // Compute as we go
//SendMatchNextBinder[%nextBinder⟦ ##binder ##nextBinder⟧, SOME[#parent], #term, #termpos, 0, ok.#[ok]];
//
//{#E}SendMatchProperties[OK, %property*⟦                        ⟧, #term, ok.#[ok]] → {#E}#[OK];
//{#E}SendMatchProperties[OK, %property*⟦ ##property ##property* ⟧, #term, ok.#[ok]] → {#E}SendMatchProperty[#property, #term, ok.SendMatchProperties[ok, #property*, #term, ok.#[ok]]];
//
//{$String:STRING_ENTRY}
//SendMatchProperty[Crsx_property_sort, Text, ok::OK_SORT.Text] :: Text;
//
//{#E; "$top-props":YES; "$dispatch$env": TEXT[#props]}
//SendMatchProperty[%property⟦ ##METAVAR ⟧, #term, ok.#[ok]] 
//→
//{#E; "$props": TEXT[#props]}AddMetaVar[#METAVAR, #props, (), ok.#[ok]];
//
//-[Fresh[props::Text]]:
//{#E; "$top-props":NO}
//SendMatchProperty[%property⟦ ##METAVAR ⟧, #term, ok.#[ok]] 
//→
//%n⟦¶Properties «props» = safeRef(«#term».properties());«{#E; "$props": TEXT[props]}AddMetaVar[#METAVAR, props, (), ok.#[ok]]»⟧;
//                          
//{#E; "$props": TEXT[#props]; "$caselabel":TEXT[#label]}
//SendMatchProperty[%property⟦ ¬ ##METAVAR            ⟧, #term, ok.#[ok]] 
//→ 
//%n⟦¶if («#props» != null && «#props».lookup(«{#E}MetaVar[#METAVAR]») != null) 
//{⟦
//  break «#label»;⟧
//}«{#E}#[OK]»⟧;
//
//{#E; "$props": TEXT[#props]; "$caselabel":TEXT[#label]}
//SendMatchProperty[%property⟦ ##VARIABLE             ⟧, #term, ok.#[ok]] 
//→ 
//%n⟦¶if («#props» == null || «#props».lookup(«{#E}Variable[#VARIABLE]») == null) 
//{⟦
//  break «#label»;⟧
//}«{#E}#[OK]»⟧;
//
//{#E; "$props": TEXT[#props]; "$caselabel":TEXT[#label]}
//SendMatchProperty[%property⟦ ¬ ##VARIABLE           ⟧, #term, ok.#[ok]]
//→ 
//%n⟦¶if («#props» != null && «#props».lookup(«{#E}Variable[#VARIABLE]») == null) 
//{⟦
//  break «#label»;⟧
//}«{#E}#[OK]»⟧;
//
//{#E; "$props": TEXT[#props]; "$caselabel":TEXT[#label]}
//SendMatchProperty[%property⟦ ##STRING               ⟧, #term, ok.#[ok]] 
//→
//%n⟦¶if («#props» == null || «#props».lookup(†«#STRING») == null) 
//{⟦
//  break «#label»;⟧
//}«{#E}#[OK]»⟧;
//
//{#E; "$props": TEXT[#props]; "$caselabel":TEXT[#label]}
//SendMatchProperty[%property⟦ ¬ ##STRING             ⟧, #term, ok.#[ok]] 
//→ 
//%n⟦¶if («#props» != null && «#props».lookup(†«#STRING») != null) 
//{⟦
//  break «#label»;⟧
//}«{#E}#[OK]»⟧;
//
//-[Fresh[value::Text]]:
//{#E; "$props": TEXT[#props]; "$caselabel":TEXT[#label]}
//SendMatchProperty[%property⟦ ##METAVAR1 : ##METAVAR2 ⟧, #term, ok.#[ok]] 
//→ 
//%n⟦¶Term «value» = «#props» == null ? null : «#props».lookup(«{#E}MetaVar[#METAVAR1]»);
//if («value» == null) 
//{⟦
//  break «#label»;⟧
//}
//«value» = «value».ref();«{#E}AddMetaVar[#METAVAR2, value, (), ok.#[ok]]»⟧;
//
//-[Fresh[value::Text]]:
//{#E; "$props": TEXT[#props]; "$caselabel":TEXT[#label]}
//SendMatchProperty[%property⟦ ##VARIABLE : ##METAVAR ⟧, #term, ok.#[ok]] 
//→ 
//%n⟦¶Term «value» = «#props» == null ? null : «#props».lookup(«{#E}Variable[#VARIABLE]»);
//if («value» == null) 
//{⟦
//  break «#label»;⟧
//}
//«value» = «value».ref();«{#E}AddMetaVar[#METAVAR, value, (), ok.#[ok]]»⟧;
//
//-[Fresh[value::Text]]:
//{#E; "$props": TEXT[#props]; "$caselabel":TEXT[#label]}
//SendMatchProperty[%property⟦ ##STRING : ##METAVAR ⟧, #term, ok.#[ok]] 
//→ 
//%n⟦¶Term «value» = «#props» == null ? null : «#props».lookup(†«#STRING»);
//if («value» == null) 
//{⟦
//  break «#label»;⟧
//}
//«value» = «value».ref();«{#E}AddMetaVar[#METAVAR, value, (), ok.#[ok]]»⟧;
//
//{#E}SendMatchProperty[%property⟦ ##METAVAR : ##freeTerm  ⟧, #term, ok.#[ok]] // Can't do this because of ordering.
//→ 
//$[Error, $[:, "Internal error: dynamic lookup of ", #METAVAR, " not allowed."]];
//
//// REVISIT: could easily be supported.
//{#E}SendMatchProperty[%property⟦ ##VARIABLE : ##freeTerm ⟧, #term, ok.#[ok]] → $[Error, "Internal error: variable property construction not allowed in pattern"];
//
//-[Fresh[value::Text]]:
//{#E; "$props": TEXT[#props]; "$caselabel":TEXT[#label]}
//SendMatchProperty[%property⟦ ##STRING : ##freeTerm  ⟧, #term, ok.#[ok]] 
//→
//%n⟦¶Term «value» = «#props» == null ? null : «#props».lookup(†«#STRING»);
//if («value» == null) 
//{⟦
//  break «#label»;⟧
//}«{#E}SendMatchFreeTerm[#freeTerm, value, ok.#[ok]]»⟧;
// 
//{#E}SendMatchProperty[%property⟦ ##CONSTRUCTOR : ##freeTerm ⟧, #term, ok.#[ok]] 
//→ 
//$[Error, $[:, "Internal error: named property ", #CONSTRUCTOR, " not allowed in pattern"]];
////{#E}#[OK]; // Ignore for now.
//
//SendMatchMeta[$String, Text, ok::OK_SORT.Text] :: Text;
//
//-[Data[#key]]:
//{#E; "$binders": TEXTS[#binders]}
//SendMatchMeta[#key, #term, ok.#[ok]]
//→
//{#E; #key: META[#term, #binders]}#[OK];
//
//SendMatchMaybeArguments[OK_SORT, $List[Crsx_arguments_sort], Text, ok::OK_SORT.Text] :: Text;
//
//{#E}SendMatchMaybeArguments[OK, %arguments?⟦             ⟧, #term, ok.#[ok]] → {#E}#[OK];
//{#E}SendMatchMaybeArguments[OK, %arguments?⟦ [         ] ⟧, #term, ok.#[ok]] → {#E}#[OK];
//{#E}SendMatchMaybeArguments[OK, %arguments?⟦ [ ##terms ] ⟧, #term, ok.#[ok]] → {#E}SendMatchSubTerms[OK, DesugarTerms[#terms], #term, 0, ok.#[ok]];
//
//SendMatchSubTerms[OK_SORT, $List[Crsx_term_sort], Text, $Numeric, ok::OK_SORT.Text] :: Text;
//
//{#E}SendMatchSubTerms[OK, %term*⟦                ⟧, #parent, #subpos, ok.#[ok]] → {#E}#[OK];
//
//{#E}SendMatchSubTerms[OK, %term*⟦ ##term ##term* ⟧, #parent, #subpos, ok.#[ok]] 
//→ 
//{#E}SendMatchSubTerm[#term, #parent, #subpos, ok.SendMatchSubTerms[ok, #term*, #parent, NumberPlus[#subpos, 1], ok.#[ok]]];
//
//SendMatchSubTerm[Crsx_term_sort, Text, $Numeric, ok::OK_SORT.Text] :: Text;
//
//// TODO: force only when have Data annotation.
//-[Fresh[sub::Text]]:
//{#E}SendMatchSubTerm[#sub, #parent, #subpos, ok.#[ok]]
//→
//%n⟦Term «sub» = forceSub(sink.context(), «#parent», «NumberToText[#subpos]»).ref();«{#E}SendMatchTerm[#sub, SOME[#parent], sub, #subpos, ok.#[ok]]»⟧;
//
//SendMatchNextBinder[Crsx_nextBinder_sort, Option[Text], Text /* Current term */, $Numeric, $Numeric, ok::OK_SORT.Text] :: Text;
//
//{#E}SendMatchNextBinder[%nextBinder⟦ . ##freeTerm ⟧, #parent, #term, #termpos, #binderpos, ok.#[ok]] 
//→ 
//{#E}SendMatchFreeTerm[#freeTerm, #term, ok.#[ok]];
//
//{#E}SendMatchNextBinder[%nextBinder⟦ ##binder ##nextBinder ⟧, NONE, #term, #termpos, #binderpos, ok.#[ok]] 
//→ 
//{#E}SendMatchNextBinder[#nextBinder, NONE, #term, #termpos, NumberPlus[#binderpos, 1], ok.#[ok]];
//
//-[Fresh[binder::Text]]:
//{#E;"$binders": TEXTS[#binders]}SendMatchNextBinder[%nextBinder⟦ ##binder ##nextBinder ⟧, SOME[#parent], #term, #termpos, #binderpos, ok.#[ok]] 
//→ 
//%n⟦
//Variable «binder» = «#parent».binders(«NumberToText[#termpos]»)[«NumberToText[#binderpos]»];«
//  {#E; "$binders": TEXTS[Concat[(binder;), #binders]]}SendMatchNextBinder[#nextBinder, SOME[#parent], #term, #termpos, NumberPlus[#binderpos,1], ok.#[ok]] » ⟧;
//
//// --- Dispatch case contraction.
////--- Make fresh variable
//
//SendFreshes[STRING_ENTRY, Crsx_freeTerm_sort] :: Text;
//
//{#E}SendFreshes[NOENTRY, #freeTerm]        → {#E}SendFreeTerm[#freeTerm];
//{#E}SendFreshes[STRINGS[#keys], #freeTerm] → {#E}SendFreshesKeys[OK, #keys, #freeTerm];
//
//SendFreshesKeys[OK_SORT, $List[$String], Crsx_freeTerm_sort] :: Text;
//
//{#E}SendFreshesKeys[OK, (), #freeTerm]            → {#E}SendFreeTerm[#freeTerm];
//{#E}SendFreshesKeys[OK, (#key; #keys), #freeTerm] → {#E}SendFreshesKey[$[{#E}Get, #key], ok.SendFreshesKeys[ok, #keys, #freeTerm]];
//
//SendFreshesKey[STRING_ENTRY, ok::OK_SORT.Text] :: Text;
//
//{#E}SendFreshesKey[STRING[#varname], ok.#[ok]]
//→
//{#E}SendFreshesKey2[#varname, $[:, "$var$", #varname], ok.#[ok]];
//
//SendFreshesKey2[$String, $String, ok::OK_SORT.Text] :: Text;
//
//-[Fresh[var::Text], Data[#key]]:
//{#E; "$sink":TEXT[#sink];}
//SendFreshesKey2[#varname, #key, ok.#[ok]]
//→
//%n⟦¶Variable «var» = «#sink».context().makeVariable("†«#varname»");«
//      {#E; var: FRESH; #key: TEXT[var]}#[OK]»⟧;
//
//CallFunction[OK_SORT, STRING_ENTRY, Crsx_constructor_sort, $List[Text]] :: Text;
//
//{#E; "$sink":TEXT[#sink]}CallFunction[OK, #tail, #symbol, #vars] 
//→  
//%n⟦«SendTail2[#tail]»«ToJavaId[#symbol]»(«#sink», 1, depth + 1«{#E}CallFunctionArgs[#vars]»);⟧;
//
//CallFunctionArgs[$List[Text]] :: Text;
//
//{#E}CallFunctionArgs[()]            → %n⟦⟧;
//{#E}CallFunctionArgs[(#arg; #args)] → %n⟦, «#arg»«{#E}CallFunctionArgs[#args]»⟧;
//
//// --- SET mode
//// 
//// Generate code evaluating each arguments and assigning result to variables
//
//SetFreeTerms[Crsx_freeTerms_sort, ok::OK_SORT vars::$List[Text].Text] :: Text;
//
//{#E}SetFreeTerms[%freeTerms⟦ ##freeTerm ##freeTerm* ⟧, ok vars.#[ok, vars]] 
//→ 
//{#E}SetFreeTerm[#freeTerm, ok var.SetFreeTermZOM[#freeTerm*, ok vars.#[ok, (var; vars)]]];
//
//SetFreeTermZOM[$List[Crsx_freeTerm_sort], ok::OK_SORT vars::$List[Text].Text] :: Text;
// 
//{#E}SetFreeTerms_S1_ZOM[%freeTerm*⟦ ⟧, ok var.#[ok, var]] → {#E}#[OK, ()]; 
//
//{#E}SetFreeTerms_S1_ZOM[%freeTerm*⟦ ##freeTerm ##freeTerm* ⟧, ok var.#[ok, var]] 
//→ 
//{#E}SetFreeTerm[#freeTerm, ok var.SetFreeTermZOM[#freeTerm*, ok vars.#[ok, (var; vars)]]];
//
//SetFreeTerm[Crsx_freeTerm_sort, ok::OK_SORT var::Text.Text] :: Text;
//
//// Construction
//{#E}SetFreeTerm[%freeTerm⟦ ##annotations? ##properties? ##constructor ##arguments? ⟧, ok var.#[ok, var]] 
//→ 
//{#E}SetBuffer[%freeTerm⟦ ##annotations? ##properties? ##constructor ##arguments? ⟧, ok var.#[ok, var]];
//
//// Construction one argument     
//{#E}SetFreeTerm[%freeTerm⟦ ##annotations? ##properties? ##constructor ##term ⟧, ok var.#[ok, var]] 
//→
//{#E}SetFreeTerm[%freeTerm⟦ ##annotations? ##properties? ##constructor [ ##term ] ⟧, ok var.#[ok, var]];
//
//// Literals can be directly created 
//-[Fresh[literal::Text]]:
//{#E;"$sink":TEXT[#sink]}
//SetFreeTerm[%freeTerm⟦ ##annotations? ##properties? ##literal ⟧, ok var.#[ok, var]]
//→
//%n⟦¶Term «literal» = Literal.make(«Literal[#literal]»);« {#E}#[OK, literal] »⟧;
//
//// List     
//{#E}SetFreeTerm[%freeTerm⟦ ##annotations? ##list ⟧, ok var.#[ok, var]] 
//→
//{#E}SetFreeTerm[DesugarList[#list], ok var.#[ok, var]];
//
//// variable
//{#E}SetFreeTerm[%freeTerm⟦ ##annotations? ##VARIABLE ##linear? ##functional? ##varsort? ⟧, ok var.#[ok, var]] 
//→
//{#E}SetVariable[VarKey[%variable⟦ ##VARIABLE ⟧], ok var.#[ok, var]];
//
//// struct     
//{#E}SetFreeTerm[%freeTerm⟦ ##properties ⟧, ok var.#[ok, var]]  
//→
//$[Error, "Named data structure not implemented yet."];
//
//// meta     
//{#E}SetFreeTerm[%freeTerm⟦ ##annotations? ##properties? ##METAVAR ##freeArguments? ⟧, ok var.#[ok, var]]
//→
//{#E}SetBuffer[%freeTerm⟦ ##annotations? ##properties? ##METAVAR ##freeArguments? ⟧, ok var.#[ok, var]];
//
//// expression     
//{#E}SetFreeTerm[%freeTerm⟦ ##annotations? ##properties? ##expression ⟧, ok var.#[ok, var]] 
//→
//{#E}SetBuffer[%freeTerm⟦ ##annotations? ##properties? ##expression ⟧, ok var.#[ok, var]];
//
//SetArgumentsOpt[$List[Crsx_arguments_sort], ok::OK_SORT args::$List[Text].Text] :: Text;
//
//{#E}SetArgumentsOpt[%arguments?⟦             ⟧, ok args.#[ok, args]] → {#E}#[OK, ()];
//{#E}SetArgumentsOpt[%arguments?⟦ [         ] ⟧, ok args.#[ok, args]] → {#E}#[OK, ()];
//{#E}SetArgumentsOpt[%arguments?⟦ [ ##terms ] ⟧, ok args.#[ok, args]] → {#E}SetTerms[#terms, ok args.#[ok, args]];
//
//SetTerms[Crsx_terms_sort, ok::OK_SORT args::$List[Text].Text] :: Text;
//
//{#E}SetTerms[%terms⟦ ##term ##term* ⟧, ok args.#[ok, args]]           
//→
//{#E}SetTerm[#term, ok args.SetNextTerms[ok, args, #term*,  ok args.#[ok, args]]];
//
//SetNextTerms[OK_SORT, $List[Text], $List[Crsx_term_sort], ok::OK_SORT args::$List[Text].Text] :: Text;
//
//{#E}SetNextTerms[OK, #args, %term*⟦⟧, ok args.#[ok, args]] → {#E}#[OK, #args];
//
//{#E}SetNextTerms[OK, #args, %term*⟦ ##term ##term* ⟧, ok args.#[ok, args]] 
//→ 
//{#E}SetTerm[#term, ok args.SetNextTerms[ok, Concat[#args, args], #term*, ok args.#[ok, args]]];
//
//SetTerm[Crsx_term_sort, ok::OK_SORT args::$List[Text].Text] :: Text;
//
//{#E}SetTerm[%term⟦ ##freeTerm ⟧, ok args.#[ok, args]] → {#E}SetFreeTerm[#freeTerm, ok var.#[ok, (var;)]];
//
//// --- SET var
//
//SetVariable[$String, ok::OK_SORT var::Text.Text] :: Text;
//
//-[Data[#key]]:
//{#E}SetVariable[#key, ok var.#[ok, var]] 
//→
//{#E}SetVariable0[$[{#E}Get, #key, NOENTRY], #key, ok var.#[ok, var]];
//
//SetVariable0[STRING_ENTRY, $String, ok::OK_SORT var::Text.Text] :: Text;
//
//-[Fresh[use::Text]]:
//{#E; "$sink":TEXT[#sink]}
//SetVariable0[TEXT[#var], #key, ok var.#[ok, var]] 
//→
//%n⟦¶VariableUse «use» = «#sink».context().makeVariableUse(«#var»);«{#E}#[OK, use]»⟧; 
//
//// If no entry, assume it's a fresh variable. Experimental.
//-[Fresh[var::Text]]:
//{#E; "$sink":TEXT[#sink];}
//SetVariable0[NOENTRY, #key, ok var.#[ok, var]]
//→
//%n⟦¶Variable «var» = «#sink».context().makeVariable("†«#key»");«
//      {#E; var: FRESH; #key: TEXT[var]}SetVariable[#key, ok var.#[ok, var]]»⟧;
//
//// --- SET through buffering
//
//SetBuffer[Crsx_freeTerm_sort, ok::OK_SORT var::Text.Text] :: Text;
//
//-[Fresh[buf::Text, term::Text]]
//:
//{#E; "$sink":TEXT[#sink]}
//SetBuffer[#freeTerm, ok var.#[ok, var]]
//→
//%n⟦Term «term»;
//{⟦
//BufferSink «buf» = «#sink».context().makeBuffer();« {#E; "$sink":TEXT[buf]}SendFreeTerm[#freeTerm] »
//«term» = «buf».term();⟧
//}«{#E; "$sink":TEXT[#sink]}#[OK, term]»⟧; // Repeat $sink because of interpreter bug.

// ----- initModule

/* Generate code initializing a module.
   Dynamically register data and function descriptors.
*/
InitModule[MAP[$String, Core_cdecl_sort], MAP[$String, Core_cdecl_sort]   ] :: Text;

InitModule[#data, #func] 
→ %n⟦
private static boolean initialized = false;
public static void init(Context context)
{⟦
if (!initialized) 
{⟦
«TextFold[Map[sort.RegisterDataSort[sort], MapValues[#data]], %n⟨⟩]»«TextFold[Map[sort.RegisterFuncSort[sort], MapValues[#func]], %n⟨⟩]»
initialized = true;⟧
}⟧
}⟧;

//Register[%declaration⟦ import module ##constructor ; ⟧] 
//→
//%n⟦
//«PathToImport[#constructor]».init(context);⟧;
//// TODO: unify path resolution
//Register[%declaration⟦ import grammar ##CONSTRUCTOR ; ⟧] 
//→
//%n⟦⟧;
////context.registerParser(«Text-QuoteEscape[Replace[#CONSTRUCTOR, "/", "."]]»);⟧;

RegisterDataSort[Core_cdecl_sort] :: Text;
RegisterDataSort[%cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧]
→ TextFold[Map[form.RegisterDataForm[form], #cform*], %n⟨⟩];

RegisterDataForm[Core_cform_sort] :: Text;
RegisterDataForm[%cform⟦ ##CONSTRUCTOR ##csorts? ⟧] 
→ %n⟦
context.register(«Descriptor[#CONSTRUCTOR]»);⟧;

RegisterFuncForm[Core_cdecl_sort] :: Text;
RegisterFuncSort[%cdecl⟦ func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧]
→ %n⟦
context.register(«Descriptor[#CONSTRUCTOR]»);⟧; 

/* Print package declaration */
PackageDeclaration :: Text;
PackageDeclaration → PackageDeclaration2[$[Get, "javabasepackage", ""], $[Get, "javapackage", ""]];

PackageDeclaration2[$String, $String] :: Text;
PackageDeclaration2[#base, #sub] 
→ %n⟦
package †«#base»«PackageDeclaration3[$[If, $[StringEqual, $[Trim, #base], ""],"", "."], #sub]»;⟧;

PackageDeclaration3[$String, $String] :: Text;
PackageDeclaration3[#sep, #sub] 
→
$[If, $[StringEqual, $[Trim, #sub], ""], %n⟦⟧, %n⟦†«#sep»†«#sub»⟧];
//
//// Print java import
//PathToImport[Crsx_constructor_sort] :: Text;
//
//PathToImport[%constructor⟦ ##CONSTRUCTOR ⟧] 
//→ 
//PathToImport2[$[If, $[StartsWith, #CONSTRUCTOR, "std/"], "org.crsx.compiler", $[Get, "javabasepackage", ""]], PathToDot[#CONSTRUCTOR]];
//
//PathToImport2[$String, $String] :: Text;
//
//-[Data[#package, #name]] : 
//PathToImport2[#package, #name] 
//→ 
//%n⟦«StringToText[#package]».«StringToText[#name]»⟧;
//
//PathToDot[$String] :: $String;
//PathToDot[#path] → PathToDot2[Replace[BeforeLast[#path, "."], "/", "."]];
//
//PathToDot2[$String] :: $String;
//-[Data[#subpackage]]: PathToDot2[#subpackage] 
//→ 
//$[If, $[Contains, #subpackage, "."],
//    ConcatString[ConcatString[BeforeLast[#subpackage, "."], "."], UpCaseFirst[AfterLast[#subpackage, "."]]],
//    UpCaseFirst[#subpackage]];

// Print class name
ClassName[$String] :: $String;
ClassName[#name] → UpCaseFirst[AfterLast[BeforeLast[#name, "."], "/"]]; 

// ----------- Code generation environment

// To change when upgrade to crsx4.

VarEntry ::= ( FREE; BOUND; FRESH; SEMANTIC; );

JavaEnvEntry ::= ( EText[Text]; ETexts[$List[Text]]; EBool[$Boolean]; EMapText[MAP[$String, Text]]; EMapVar[MAP[$String, VarEntry]]; );

{$String:JavaEnvEntry} 
JavaEnv ::= ( JavaEnv; );

NewEnv :: JavaEnv;
NewEnv → { "sink" : EText[%n⟦⟧];   /* Current sink. */
           "args" : ETexts[()];    /* Java method arguments. */
           "thunk": ETexts[()];    /* thunk arguments */
           "label": EText[%n⟦⟧];   /* Current pattern block label. */
           "tail" : EBool[$True];  /* Tail? */
           "meta" : EMapText[MAP]; /* Map meta variable to java variable */
           "vars" : EMapVar[MAP]   /* Map variable to VarEntry */
         }JavaEnv;

// --- Helpers.

∀ a.GetValue[JavaEnv, $String, x::JavaEnvEntry.$sort[a]] :: a;
GetValue[{#env}JavaEnv, #key, x.#unwrap[x]]
→ #unwrap[$[{#env}Get, #key]];

UnText[JavaEnvEntry] :: Text;
UnText[EText[#]] → #;

UnTexts[JavaEnvEntry] :: $List[Text];
UnTexts[ETexts[#]] → #;

UnBool[JavaEnvEntry] :: $List[Text];
UnBool[EBool[#]] → #;

UnMapText[JavaEnvEntry] :: MAP[$String, Text];
UnMapText[EMapText[#]] → #;

// --- Sink

GetSink[JavaEnv] :: Text;
GetSink[#env] → GetValue[#env, "sink", x.UnText[x]];

SetSink[JavaEnv, Text] :: Text;
SetSink[{#env}JavaEnv, #sink] → {#env; "sink": EText[#sink]}JavaEnv;

// --- Step method arguments

GetArgs[JavaEnv] :: $List[Text];
GetArgs[#env] → GetValue[#env, "args", x.UnTexts[x]];

SetArgs[JavaEnv, $List[Text]] :: Text;
SetArgs[{#env}JavaEnv, #args] → {#env; "args": ETexts[#args]}JavaEnv;

AddArg[JavaEnv, Text] :: JavaEnv;
AddArg[{#env}JavaEnv, #arg] → {#env; "args": ETexts[Append[#arg, GetArgs[{#env}JavaEnv]]]}JavaEnv;

// --- Thunk arguments

GetThunk[JavaEnv] :: $List[Text];
GetThunk[#env] → GetValue[#env, "thunk", x.UnTexts[x]];

SetThunk[JavaEnv, $List[Text]] :: Text;
SetThunk[{#env}JavaEnv, #thunk] → {#env; "thunk": ETexts[#thunk]}JavaEnv;

AddThunk[JavaEnv, Text] :: JavaEnv;
AddThunk[{#env}JavaEnv, #thunk] → {#env; "thunk": ETexts[Append[#thunk, GetThunk[{#env}JavaEnv]]]}JavaEnv;

// --- Rule case label

GetLabel[JavaEnv] :: Text;
GetLabel[#env] → GetValue[#env, "label", x.UnText[x]];

SetLabel[JavaEnv, Text] :: Text;
SetLabel[{#env}JavaEnv, #label] → {#env; "label": EText[#label]}JavaEnv;

// --- Tail mode.

GetTail[JavaEnv] :: Text;
GetTail[#env] → GetValue[#env, "tail", x.UnBool[x]];

SetTail[JavaEnv, Text] :: Text;
SetTail[{#env}JavaEnv] → {#env; "tail": EBool[$True]}JavaEnv;

UnsetTail[JavaEnv, Text] :: Text;
UnsetTail[{#env}JavaEnv] → {#env; "tail": EBool[$False]}JavaEnv;

// --- Meta

GetMetas[JavaEnv] :: MAP[$String, Text];
GetMetas[#env] → GetValue[#env, "meta", x.UnMapText[x]];

GetMeta[JavaEnv, $String] :: Text;
GetMeta[#env, #metavar] → UnSOME[MapGet[GetMetas[#env], #metavar]];

AddMeta[JavaEnv, $String, Text] :: JavaEnv;
AddMeta[{#env}JavaEnv, #metavar, #term]
→ {#env; "meta": EMapText[MapPut[GetMetas[{#env}JavaEnv], #metavar, #term]]}JavaEnv;

SetValue[JavaEnv, $String, JavaEnvEntry] :: JavaEnv;
-[Data[#value]]: 
SetValue[{#env}JavaEnv, #key, #value]
→ {#env; #key: #value}JavaEnv;

// --- Variable


)]