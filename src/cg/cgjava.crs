// Copyright (c) 2015 IBM Corporation.
/*
 * CRSX Java backend code generator
 *
 * Generate Java 8 source code from core Crsx.
 * 
 * Only one Java file is created from a Crsx system. This will have to change in order to scale.
 */
CG[(

$Lax;

$AddGrammar["net.sf.crsx.text.Text"];
$AddGrammar["org.crsx.core.CoreMetaParser"];

$CheckGrammar["net.sf.crsx.text.Text"];
$CheckGrammar["org.crsx.core.CoreMetaParser"];

$Use["core/Core.crs"];
$Use["std/core.crs"];
$Use["std/string.crs"];
$Use["std/num.crs"];
$Use["std/text.crs"];
$Use["std/list.crs"];
$Use["std/pair.crs"];
$Use["system.crs"];

// ===== API

/*
 * Generates Java code from a sorted core Crsx system
 * @param System The crsx system
 */
CrsxToJava[System] :: Text;
CrsxToJava[System[#url, #modules]] 
→ JavaUnits[#url, MapValues[#modules]];

// --- Generate code.
// 
// Each Crsx module corresponds to a single Java class. 
// 
// Each rule declaration corresponds to a single Java function.
//
JavaUnits[$String, $List[Module]] :: Text;
JavaUnits[#url, #modules] 
→ %n⟦/** Generated File */«PackageDeclaration»
import static org.crsx.runtime.ConstructionDescriptor.makeData;
import static org.crsx.runtime.ConstructionDescriptor.makeFunction;
import static org.crsx.runtime.Normalizer.thunk;
import static org.crsx.runtime.Normalizer.force;
import static org.crsx.runtime.Normalizer.forceSub;
import static org.crsx.runtime.Reference.safeRef;
import static org.crsx.runtime.Term.isVariableUse; 

import org.crsx.runtime.*;
import org.crsx.runtime.ConstructionDescriptor.*;
import static org.crsx.runtime.Primitives.*;
«TextFold[Map[module.JavaUnit[#url, module], #modules], %n⟨⟩]»⟧;

/* Generate class for the given module */ 
JavaUnit[$String, Module] :: Text;
-[Data[#rules, #datasorts, #funcsorts]]:
JavaUnit[#mainurl, Module[#url, Loaded[LoadedContent[#imports, #rules, #datasorts, #funcsorts]]]] 
→ %n⟦
«TextFold[Map[import.JavaImport[import], #imports], %n⟨⟩]»

@SuppressWarnings("unused")
«JavaClassVisibility[#mainurl, #url]» class †«ClassName[#url]»
{⟦«TextFold[Map[sort.JavaDataDesc[sort], MapValues[#datasorts]], %n⟨⟩]»
«TextFold[Map[sort.JavaFuncDesc[ClassName[#url], sort], MapValues[#funcsorts]], %n⟨⟩]»
«TextFold[Map[cons.JavaMethod[cons, #rules, #datasorts, #funcsorts], MapKeys[#rules]], %n⟨⟩]»
«InitModule[#datasorts, #funcsorts]»⟧
}⟧;

JavaImport[$String] :: Text;
JavaImport[#name] 
→ %n⟦
import static «PathToImport[#name]».*;⟧;

JavaClassVisibility[$String, $String] :: Text;
JavaClassVisibility[#mainurl, #url] 
→ $[If, $[Equal, #mainurl, #url], %n⟦¶public⟧, %n⟦¶static⟧];

JavaDataDesc[Core_cdecl_sort] :: Text;
JavaDataDesc[%cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧]
→ TextFold[Map[form.JavaFormDesc[form], #cform*], %n⟦⟧];

JavaFormDesc[Core_cform_sort] :: Text;
JavaFormDesc[%cform⟦ ##CONSTRUCTOR ##csorts? ⟧] 
→ %n⟦
final public static ConstructionDescriptor «Descriptor[#CONSTRUCTOR]» = makeData(«Text-QuoteEscape[#CONSTRUCTOR]»);⟧;

JavaFuncDesc[$String, Core_cdecl_sort] :: Text;
JavaFuncDesc[#classname, %cdecl⟦ func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧]
→ %n⟦final public static DynamicFunctionDescriptor «Descriptor[#CONSTRUCTOR]» = makeFunction(«Text-QuoteEscape[#CONSTRUCTOR]», †«#classname».class, "«ToJavaId[#CONSTRUCTOR]»");⟧; 

/* Generate methods for module rules */ 
JavaMethod[$String, Map[$String, $List[Core_cdecl_sort]],  
           Map[$String, Core_cdecl_sort], Map[$String, Core_cdecl_sort]] :: Text;
JavaMethod[#constructor, #rules, #datasorts, #funcsorts] 
→ %n⟦final public static boolean «JavaMethodSig[UnSOME[MapGet[#funcsorts, #constructor]], UnSOME[MapGet[#rules, #constructor]]]»⟧;

JavaMethodSig[Core_cdecl_sort, $List[Core_cdecl_sort]] :: Text;
JavaMethodSig[%cdecl⟦ func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧, #rules] 
→ %n⟦«ToJavaId[#CONSTRUCTOR]»(Sink sink«JavaSigMaybeArgs[
                SetSink[AddThunk[AddThunk[NewEnv, %n⟦sink⟧], Descriptor[#CONSTRUCTOR]], %n⟦sink⟧], #csorts?, #rules]»⟧;  // )

JavaSigMaybeArgs[JavaEnv, $List[Core_csorts_sort], $List[Core_cdecl_sort]] :: Text;
JavaSigMaybeArgs[#env, %csorts?⟦⟧, #rules]
→ JavaBody[#env, #rules];

JavaSigMaybeArgs[#env, %csorts?⟦ ( ##csort* ) ⟧, #rules]
→ JavaSigArgs[#env, #csort*, #rules];

// Generate method signature and record the argument names in the environment, as an ordered list.
JavaSigArgs[JavaEnv, $List[Core_csort_sort], $List[Core_cdecl_sort]] :: Text;

JavaSigArgs[#env, %csort*⟦ ⟧, #rules]
→ JavaBody[#env, #rules];

-[Fresh[term::Text]]:
JavaSigArgs[#env, %csort*⟦ ##CONSTRUCTOR ##csorts? ##csort* ⟧, #rules]
→ %n⟦, Term «term»«JavaSigArgs[AddParam[#env, term], #csort*, #rules]»⟧;

-[Fresh[term::Text]]:
JavaSigArgs[#env, %csort*⟦ ##VARIABLE ##csort* ⟧, #rules] // Sort variable
→ %n⟦, Term «term»«JavaSigArgs[AddParam[#env, term], #csort*, #rules]»⟧;

-[Fresh[var::Text]]:
JavaSigArgs[#env, %csort*⟦ [ ##csort ] ##csort2 ##csort* ⟧, #rules]
→ %n⟦, Variable «var»«JavaSigArgs[AddParam[#env, var], (#csort2; #csort*), #rules]»⟧;

// TODO
JavaSigArgs[#env, %csort*⟦ { ##cmapsort* }  ⟧, #rules]
→ %n⟦⟧;

JavaBody[JavaEnv, $List[Core_cdecl_sort]] :: Text;
JavaBody[#env, #rules]
→ %n⟦) 
{⟦if («GetSink[#env]».context().sd ++ < 256) {⟦
«TextFold[Map[rule.JavaBodyRule[#env, rule], #rules], %n⟨⟩]»⟧
}
return «Thunk[GetThunk[#env]]»;⟧
}⟧;

/* Generates code creating fallback thunk */
Thunk[$List[Text]] :: Text;
Thunk[#texts] → %n⟦thunk(«TextFold[#texts, %n⟦, ⟧]»)⟧;

JavaBodyRule[JavaEnv, Core_cdecl_sort] :: Text;
JavaBodyRule[#env, %cdecl⟦ rule ##CONSTRUCTOR → ##cterm2 ⟧]
→ JavaContractum[#env, #cterm2];

JavaBodyRule[#env, %cdecl⟦ rule ##CONSTRUCTOR ( ##cterm* ) → ##cterm2 ⟧]
→ JavaPattern[#env, #cterm*, #cterm2];

// ----- Naive pattern matching: test each pattern in sequence

JavaPattern[JavaEnv, $List[Core_cterm_sort], Core_cterm_sort] :: Text;

-[Fresh[label::Text]]:
JavaPattern[#env, #cterms, #contractum]
→ %n⟦«label»:{⟦«JavaCasePattern[SetLabel[#env, label], #cterms, #contractum]»⟧
}⟧;

// Data sort helper indicating whether the current term is a method parameter, or an argument (local variable).
Storage ::= ( PARAMETER; ARGUMENT; );

// Iterate over top-level pattern arguments
JavaCasePattern[JavaEnv, $List[Core_cterm_sort], Core_cterm_sort] :: Text;

JavaCasePattern[#env, %cterm*⟦ ⟧, #contractum]
→ JavaContractum[#env, #contractum];

JavaCasePattern[#env, %cterm*⟦ ##cterm ##cterm* ⟧, #contractum]
→ JavaPatternTerm[NextParam[#env], #cterm, CurrentParam[#env], PARAMETER, env.JavaCasePattern[env, #cterm*, #contractum]];

// --- Term pattern matching

JavaPatternTerm[JavaEnv, Core_cterm_sort, Text /* Current term */, Storage, env::JavaEnv.Text] :: Text;

-[Data[#env]]:
JavaPatternTerm[#env, %cterm⟦ ##CONSTRUCTOR ##cterms? ⟧, #term, #storage, env.#[env]]
→ %n⟦
«#term» = force(sink.context(), «#term»);
if («#term».descriptor() != «Descriptor[#CONSTRUCTOR]»)
{⟦
  break «GetLabel[#env]»;⟧
}«JavaPatternMaybeSubs[#env, #cterms?, #term, env.#[env]]»⟧;

JavaPatternTerm[#env, %cterm⟦ ##cliteral ⟧, #term, #storage, env.#[env]]
→ $[Error, "Internal error: invalid pattern matching on literal"];

// REVISIT: bound variable reordering, ie. [x][y]#(y, x)
// For now only accepts patterns of the form [x]...[y]#(x, ... y)
-[Data[#env, #term]]:
JavaPatternTerm[#env, %cterm⟦ ##METAVAR ##cterms? ⟧, #term, #storage, env.#[env]]
→ %n⟦
/* «Text-CommentToken[#METAVAR]»=«Text-CommentToken[$[Show, #term]]» */«JavaPatternMaybeMetaArgs[#env, #METAVAR, #cterms?, #term, env.#[env]]»⟧;  

-[Data[#env]]:
JavaPatternTerm[#env, %cterm⟦ ##VARIABLE ⟧, #term, #storage, env.#[env]] 
→ JavaPatternVariable[MapGetVar[#env, #VARIABLE], #env, #VARIABLE, #term, env.#[env]];

-[Data[#env, #term], Fresh[var::Core_cterm_sort]]:
JavaPatternTerm[#env, %cterm⟦ [ ##VARIABLE ] ##cterm ⟧, #term, PARAMETER, env.#[env]] 
→ JavaPatternTerm[NextParam[AddVar[#env, var, Bound[#term]]], #cterm[var], CurrentParam[#env], PARAMETER, env.#[env]];

-[Data[#env, #term], Fresh[boundvar::Text, var::Core_cterm_sort]]:
JavaPatternTerm[#env, %cterm⟦ [ ##VARIABLE ] ##cterm ⟧, #term, ARGUMENT, env.#[env]] 
→ %n⟦
Variable «boundvar» = «#term».binders()[];«JavaPatternTerm[AddVar[#env, var, Bound[boundvar]], #cterm[var], #term, ARGUMENT, env.#[env]]»⟧;

// Pattern matching on construction arguments (subterms).
JavaPatternMaybeSubs[JavaEnv, $List[Core_cterms_sort], Text, env::JavaEnv.Text] :: Text;

JavaPatternMaybeSubs[#env, %cterms?⟦⟧, #term, env.#[env]]
→ #[#env];

JavaPatternMaybeSubs[#env, %cterms?⟦ ( ##cterm* ) ⟧, #term, env.#[env]]
→ JavaPatternSubs[#env, #cterm*, #term, 0, env.#[env]];

JavaPatternSubs[JavaEnv, $List[Core_cterm_sort], Text /* parent term */, $Numeric /* sub index */, env::JavaEnv.Text] :: Text;

JavaPatternSubs[#env, %cterm*⟦⟧, #term, #index, env.#[env]]
→ #[#env];

-[Fresh[sub::Text]]:
JavaPatternSubs[#env, %cterm*⟦ ##cterm ##cterm* ⟧, #term, #index, env.#[env]]
→ %n⟦
Term «sub» = «#term».sub(«Text-Integer[#index]»).ref();«JavaPatternTerm[#env, #cterm, sub, ARGUMENT, env.JavaPatternSubs[env, #cterm*, #term, NumberPlus[#index, 1], env.#[env]]]»⟧;

// --- Variable pattern matching outside of meta

JavaPatternVariable[Option[VarEntry], JavaEnv, $String /* TODO: Core_cvariable_sort when metaparser is fixed */, Text /* Current term */, env::JavaEnv.Text] :: Text;

// First variable occurrence: the term is a variable use.
-[Fresh[var::Text]]: 
JavaPatternVariable[NONE, #env, #variable, #term, env.#[env]] 
→ %n⟦
Variable «var» = «#term».variable();«#[AddVar[#env, #variable, Free[var]]]»⟧;

// Bound variable
// TODO: update term's parent with evaluated term.
// TODO: release acquired references.
JavaPatternVariable[SOME[Bound[#javavar]], #env, #variable, #term, env.#[env]] 
→ %n⟦
«#term» = force(«GetSink[#env]».context(), «#term»);
if (!isVariableUse(«#term») || «#javavar» != «#term».variable()) 
{⟦
  break «GetLabel[#env]»;⟧
}«#[#env]»⟧;

// --- pattern matching inside meta

// Iterate over meta arguments and find corresponding bound variables.
JavaPatternMaybeMetaArgs[JavaEnv, $String, $List[Core_cterm_sort], Text /* Current term */, env::JavaEnv.Text] :: Text;

JavaPatternMaybeMetaArgs[#env, #metavar, %cterms?⟦⟧, #term, env.#[env]]
→ #[AddMeta[#env, #metavar, #term, ()]];

JavaPatternMaybeMetaArgs[#env, #metavar, %cterms?⟦ ( ##cterm* ) ⟧, #term, env.#[env]]
→ #[AddMeta[#env, #metavar, #term, Map[x.JavaFindBoundVar[#env, x], #cterm*]]];

JavaFindBoundVar[JavaEnv,Core_cterm_sort] :: Text;

JavaFindBoundVar[#env, %cterm⟦ ##VARIABLE ⟧]
→ GetVar[#env, #VARIABLE];

// Interpreter does not handle Fallback
//-[Fallback]:
//JavaFindBoundVar[#env, #cterm]
//→ $[Error, $[:, "Invalid argument in metavariable: ", $[Show, #cterm]]];

// ----- Contraction

JavaContractum[JavaEnv, Core_cterm_sort] :: Text;
JavaContractum[#env, #term] 
→ JavaSendTerm[#env, #term, env.JavaSendEndTerm[GetTail[env]]];

// ---- Contraction - send mode

JavaSendTerm[JavaEnv, Core_cterm_sort, env::JavaEnv.Text] :: Text;

JavaSendTerm[#env, %cterm⟦ ##CONSTRUCTOR ##cterms? ⟧, env.#[env]]
→ JavaSendConstruction[#env, #CONSTRUCTOR, #cterms?, env.#[env]];

JavaSendTerm[#env, %cterm⟦ ##cliteral ⟧, env.#[env]]
→ %n⟦¶«GetSink[#env]».literal(«Literal[#cliteral]»);«#[#env]»⟧;

JavaSendTerm[#env, %cterm⟦ ##VARIABLE ⟧, env.#[env]] 
→ JavaSendVariable[#env, #VARIABLE, env.#[env]];

JavaSendTerm[#env, %cterm⟦ ##METAVAR ##cterms? ⟧, env.#[env]] 
→ JavaSendMeta[#env, #METAVAR, #cterms?, env.#[env]];

-[Fresh[jvar::Text, var::Core_cterm_sort]]:
JavaSendTerm[#env, %cterm⟦ [ ##VARIABLE ] ##cterm ⟧, env.#[env]]  
→ %n⟦
Variable «jvar» = «GetSink[#env]».context().makeVariable("x");«JavaSendTerm[AddVar[#env, var, Fresh[jvar]], #cterm[var], env.#[env]]»⟧;

JavaSendEndTerm[$Boolean] :: Text;
JavaSendEndTerm[$True]  → %n⟦return true;⟧;
JavaSendEndTerm[$False] → %n⟦⟧;

// ---- SEND construction

JavaSendConstruction[JavaEnv, $String, $List[Core_cterms_sort], env::JavaEnv.Text] :: Text;

JavaSendConstruction[#env, #constructor, #cterms?, env.#[env]]
→ %n⟦
«GetSink[#env]».start(«Descriptor[#constructor]»);«JavaSendMaybeTerms[UnsetTail[#env], #cterms?]»
«GetSink[#env]».end();«#[#env]»⟧;

JavaSendMaybeTerms[JavaEnv, $List[Core_cterms_sort]] :: Text;
JavaSendMaybeTerms[#env, %cterms?⟦              ⟧] → %n⟦⟧;
JavaSendMaybeTerms[#env, %cterms?⟦ ( ##cterm* ) ⟧] → TextFold[Map[term.JavaSendTerm[#env, term, env.%n⟦⟧], #cterm*], %n⟦⟧];

// ---- SEND scope variable

JavaSendVariable[JavaEnv, $String, env::JavaEnv.Text] :: Text;
JavaSendVariable[#env, #var, env.#[env]]
→ %n⟦¶«GetSink[#env]».use(«GetVar[#env, #var]»);«#[#env]»⟧;

// ---- SEND metavar

JavaSendMeta[JavaEnv, $String, $List[Core_cterms_sort], env::JavaEnv.Text] :: Text;

// No argument -> just send value.
JavaSendMeta[#env, #metavar, %cterms?⟦⟧, env.#[env]] 
→ %n⟦
«GetSink[#env]».copy(«GetMetaVar[#env, #metavar]».ref());«#[#env]»⟧;

// With arguments -> substitute.
// Start by computing arguments and then call substitute.
JavaSendMeta[#env, #metavar, %cterms?⟦ ( ##cterm* ) ⟧, env.#[env]] 
→ %n⟦«JavaSetTerms[#env, #cterm*, terms.JavaSendSubstitutes[#env, #metavar, terms]]»«#[#env]»⟧;

JavaSendSubstitutes[JavaEnv, $String, $List[Text]] :: Text;
JavaSendSubstitutes[#env, #metavar, #substitutes]
→ %n⟦
«GetSink[#env]».substitute(«GetMetaVar[#env, #metavar]».ref(), new Variable[] { «TextFold[GetMetaArgs[#env, #metavar], %n⟦, ⟧]» }, new Term[] {«TextFold[#substitutes, %n⟦, ⟧]»});⟧;

// ---- Contraction - set mode

JavaSetTerms[JavaEnv, $List[Core_cterm_sort], jterms::$List[Text].Text] :: Text;
JavaSetTerms[#env, #cterms, jterms.#[jterms]] 
→ JavaSetTerms2[#env, #cterms, (), jterms.#[jterms]];

JavaSetTerms2[JavaEnv, $List[Core_cterm_sort], $List[Text], jterms::$List[Text].Text] :: Text;

JavaSetTerms2[#env, %cterm*⟦ ⟧, #jterms, terms.#[terms]]
→ #[#jterms];

JavaSetTerms2[#env, %cterm*⟦ ##cterm ##cterm* ⟧, #jterms, terms.#[terms]]
→ JavaSetTerm[#env, #cterm, jterm.JavaSetTerms2[#env, #cterm*, Append[jterm, #jterms], terms.#[terms]]];

JavaSetTerm[JavaEnv, Core_cterm_sort, jterm::Text.Text] :: Text;

-[Fresh[term::Text, buffer::Text]]:
JavaSetTerm[#env, #cterm, jterm.#[jterm]]
→ %n⟦Term «term»;{⟦
BufferSink «buffer» = «GetSink[#env]».context().makeBuffer();«JavaSendTerm[SetSink[#env, buffer], #cterm, env.%n⟦⟧]»
«term» = «buffer».term();⟧
}«#[term]»⟧;

// ----- initModule

/* Generate code initializing a module.
   Dynamically register data and function descriptors.
*/
InitModule[MAP[$String, Core_cdecl_sort], MAP[$String, Core_cdecl_sort]] :: Text;

InitModule[#data, #func] 
→ %n⟦
private static boolean initialized = false;
public static void init(Context context)
{⟦
if (!initialized) 
{⟦
«TextFold[Map[sort.RegisterDataSort[sort], MapValues[#data]], %n⟨⟩]»«TextFold[Map[sort.RegisterFuncSort[sort], MapValues[#func]], %n⟨⟩]»
initialized = true;⟧
}⟧
}⟧;

//Register[%declaration⟦ import module ##constructor ; ⟧] 
//→
//%n⟦
//«PathToImport[#constructor]».init(context);⟧;
//// TODO: unify path resolution
//Register[%declaration⟦ import grammar ##CONSTRUCTOR ; ⟧] 
//→
//%n⟦⟧;
////context.registerParser(«Text-QuoteEscape[Replace[#CONSTRUCTOR, "/", "."]]»);⟧;

RegisterDataSort[Core_cdecl_sort] :: Text;
RegisterDataSort[%cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧]
→ TextFold[Map[form.RegisterDataForm[form], #cform*], %n⟨⟩];

RegisterDataForm[Core_cform_sort] :: Text;
RegisterDataForm[%cform⟦ ##CONSTRUCTOR ##csorts? ⟧] 
→ %n⟦
context.register(«Descriptor[#CONSTRUCTOR]»);⟧;

RegisterFuncForm[Core_cdecl_sort] :: Text;
RegisterFuncSort[%cdecl⟦ func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧]
→ %n⟦
context.register(«Descriptor[#CONSTRUCTOR]»);⟧; 

/* Print package declaration */
PackageDeclaration :: Text;
PackageDeclaration → PackageDeclaration2[$[Get, "javabasepackage", ""], $[Get, "javapackage", ""]];

PackageDeclaration2[$String, $String] :: Text;
PackageDeclaration2[#base, #sub] 
→ %n⟦
package †«#base»«PackageDeclaration3[$[If, $[StringEqual, $[Trim, #base], ""],"", "."], #sub]»;⟧;

PackageDeclaration3[$String, $String] :: Text;
PackageDeclaration3[#sep, #sub] 
→
$[If, $[StringEqual, $[Trim, #sub], ""], %n⟦⟧, %n⟦†«#sep»†«#sub»⟧];

// Print java import
PathToImport[$String] :: Text;

PathToImport[#name] 
→ $[Trace, PathToImport2[$[If, $[StartsWith, #name, "Std::"], "org.crsx.compiler", $[Get, "javabasepackage", ""]], PathToDot[DownCaseFirst[#name]]]];

PathToImport2[$String, $String] :: Text;

-[Data[#package, #name]] : 
PathToImport2[#package, #name] 
→  %n⟦«StringToText[#package]».«StringToText[#name]»⟧;

PathToDot[$String] :: $String;
PathToDot[#path] → PathToDot2[Replace[#path, "::", "."]];

PathToDot2[$String] :: $String;
-[Data[#subpackage]]: PathToDot2[#subpackage] 
→ 
$[If, $[Contains, #subpackage, "."],
    ConcatString[ConcatString[BeforeLast[#subpackage, "."], "."], UpCaseFirst[AfterLast[#subpackage, "."]]],
    UpCaseFirst[#subpackage]];

// Print class name
ClassName[$String] :: $String;
ClassName[#name] → UpCaseFirst[AfterLast[BeforeLast[#name, "."], "/"]]; 

// ----------- Code generation environment

// To change when upgrade to crsx4.

VarEntry  ::= ( Free[Text /* Java var */]; Bound[Text /* Java var */]; Fresh[Text /* Java var */]; );

MetaEntry ::= ( MetaVar[Text /* Java variable associated with the meta variable*/, 
                        $List[Text] /* Java variables associated to the meta variable bound variables */]; );

JavaEnvEntry ::= ( EText[Text]; ETexts[$List[Text]]; EBool[$Boolean]; EMapMeta[MAP[$String, Text]]; EMapVar[MAP[$String /* TODO: Core_cvariable_sort when metaparser is fixed */, VarEntry]]; );

{$String:JavaEnvEntry} 
JavaEnv ::= ( JavaEnv; );

NewEnv :: JavaEnv;
NewEnv → { "sink"   : EText[%n⟦⟧];   /* Current sink. */
           "params" : ETexts[()];    /* Java method arguments. */
           "thunk"  : ETexts[()];    /* thunk arguments */
           "label"  : EText[%n⟦⟧];   /* Current pattern block label. */
           "tail"   : EBool[$True];  /* Tail? */
           "meta"   : EMapMeta[MAP];  /* Map meta variable to java variables */
           "vars"   : EMapVar[MAP];  /* Map variable to VarEntry */
         }JavaEnv;

// --- Java printing helpers

// Print construction descriptor name
Descriptor[$String] :: Text;
Descriptor[#constructor] → ToJavaIdString[#constructor];

// Print literal as a java string
Literal[Core_cliteral_sort] :: Text;
Literal[%cliteral⟦ ##STRING ⟧] → StringToText[#STRING];
Literal[%cliteral⟦ ##NUMBER ⟧] → StringToText[#NUMBER];

// Convert constructor to legal Java ID
ToJavaId[$String] :: Text;
ToJavaId[#constructor] → Text-Mangle[UpCaseFirst[#constructor]]; 

// Convert constructor to legal Java ID
ToJavaIdString[$String] :: Text;
ToJavaIdString[#name] → Text-Mangle[#name]; 

// --- Helpers.

∀ a.GetValue[JavaEnv, $String, x::JavaEnvEntry.$sort[a]] :: a;
GetValue[{#env}JavaEnv, #key, x.#unwrap[x]]
→ #unwrap[$[{#env}Get, #key]];

SetValue[JavaEnv, $String, JavaEnvEntry] :: JavaEnv;
-[Data[#value]]: 
SetValue[{#env}JavaEnv, #key, #value]
→ {#env; #key: #value}JavaEnv;

UnText[JavaEnvEntry] :: Text;
UnText[EText[#]] → #;

UnTexts[JavaEnvEntry] :: $List[Text];
UnTexts[ETexts[#]] → #;

UnBool[JavaEnvEntry] :: $List[Text];
UnBool[EBool[#]] → #;

UnMapMeta[JavaEnvEntry] :: MAP[$String, MetaEntry];
UnMapMeta[EMapMeta[#]] → #;

UnMapVar[JavaEnvEntry] :: MAP[$String, VarEntry];
UnMapVar[EMapVar[#]] → #;

UnVarVar[VarEntry] :: Text;
UnVarVar[Bound[#]] → #;
UnVarVar[Free[#]] → #;
UnVarVar[Fresh[#]] → #;

UnMetaVar[MetaEntry] :: Text;
UnMetaVar[MetaVar[#1, #2]] → #1;

UnMetaArgs[MetaEntry] :: $List[Text];
UnMetaArgs[MetaVar[#1, #2]] → #2;

// --- Sink

GetSink[JavaEnv] :: Text;
GetSink[#env] → GetValue[#env, "sink", x.UnText[x]];

SetSink[JavaEnv, Text] :: Text;
SetSink[{#env}JavaEnv, #sink] → {#env; "sink": EText[#sink]}JavaEnv;

// --- Step method arguments

GetParams[JavaEnv] :: $List[Text];
GetParams[#env] → GetValue[#env, "params", x.UnTexts[x]];

SetParams[JavaEnv, $List[Text]] :: Text;
SetParams[{#env}JavaEnv, #args] → {#env; "params": ETexts[#args]}JavaEnv;

AddParam[JavaEnv, Text] :: JavaEnv;
AddParam[{#env}JavaEnv, #arg] → {#env; "params": ETexts[Append[#arg, GetParams[{#env}JavaEnv]]]}JavaEnv;

// Move to the next parameter
NextParam[JavaEnv] :: JavaEnv;
NextParam[#env] → SetParams[#env, Tail[GetParams[#env]]];

// Get the current parameter
CurrentParam[JavaEnv] :: Text;
CurrentParam[#env] → Head[GetParams[#env]];

// --- Thunk arguments

GetThunk[JavaEnv] :: $List[Text];
GetThunk[#env] → GetValue[#env, "thunk", x.UnTexts[x]];

SetThunk[JavaEnv, $List[Text]] :: Text;
SetThunk[{#env}JavaEnv, #thunk] → {#env; "thunk": ETexts[#thunk]}JavaEnv;

AddThunk[JavaEnv, Text] :: JavaEnv;
AddThunk[{#env}JavaEnv, #thunk] → {#env; "thunk": ETexts[Append[#thunk, GetThunk[{#env}JavaEnv]]]}JavaEnv;

// --- Rule case label

GetLabel[JavaEnv] :: Text;
GetLabel[#env] → GetValue[#env, "label", x.UnText[x]];

SetLabel[JavaEnv, Text] :: Text;
SetLabel[{#env}JavaEnv, #label] → {#env; "label": EText[#label]}JavaEnv;

// --- Tail mode.

GetTail[JavaEnv] :: Text;
GetTail[#env] → GetValue[#env, "tail", x.UnBool[x]];

SetTail[JavaEnv, Text] :: Text;
SetTail[{#env}JavaEnv] → {#env; "tail": EBool[$True]}JavaEnv;

UnsetTail[JavaEnv, Text] :: Text;
UnsetTail[{#env}JavaEnv] → {#env; "tail": EBool[$False]}JavaEnv;

// --- Meta

GetMetas[JavaEnv] :: MAP[$String, MetaEntry];
GetMetas[#env] → GetValue[#env, "meta", x.UnMapMeta[x]];

GetMetaVar[JavaEnv, $String] :: Text;
GetMetaVar[#env, #metavar] → UnMetaVar[UnSOME[MapGet[GetMetas[#env], #metavar]]];

GetMetaArgs[JavaEnv, $String] :: $List[Text];
GetMetaArgs[#env, #metavar] → UnMetaArgs[UnSOME[MapGet[GetMetas[#env], #metavar]]];

AddMeta[JavaEnv, $String, Text, $List[Text]] :: JavaEnv;
AddMeta[{#env}JavaEnv, #metavar, #term, #boundvars]
→ {#env; "meta": EMapMeta[MapPut[GetMetas[{#env}JavaEnv], #metavar, MetaVar[#term, #boundvars]]]}JavaEnv;

// --- Variable

GetVars[JavaEnv] :: MAP[$String, VarEntry];
GetVars[#env] → GetValue[#env, "vars", x.UnMapVar[x]];

GetVar[JavaEnv, $String] :: Text;
GetVar[#env, #var] → UnVarVar[UnSOME[MapGetVar[GetVars[#env], #var]]];

AddVar[JavaEnv, $String /* TODO: Core_cvariable_sort */, VarEntry] :: JavaEnv;
AddVar[{#env}JavaEnv, #var, #entry]
→ {#env; "vars": EMapVar[MapPut[GetVars[{#env}JavaEnv], #var, #entry]]}JavaEnv;

)]