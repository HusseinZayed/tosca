// Copyright (c) 2015 IBM Corporation.
/*
 * CRSX Java backend code generator
 *
 * Generate Java 8 source code from core Crsx.
 * 
 * Only one Java file is created from a Crsx system. This will have to change in order to scale.
 */
CG[(

$Lax;

$AddGrammar["net.sf.crsx.text.Text"];
$AddGrammar["org.crsx.core.CoreMetaParser"];

$CheckGrammar["net.sf.crsx.text.Text"];
$CheckGrammar["org.crsx.core.CoreMetaParser"];

$Use["core/Core.crs"];
$Use["std/core.crs"];
$Use["std/string.crs"];
$Use["std/num.crs"];
$Use["std/text.crs"];
$Use["std/list.crs"];
$Use["std/pair.crs"];
$Use["system.crs"];
$Use["cg/cgutils.crs"];

// ===== API

/*
 * Generates Java code from a sorted core Crsx system
 * @param System The crsx system
 */
CrsxToJava[System] :: Text;
CrsxToJava[System[#url, #modules]] 
→ JavaUnits[#url, MapValues[#modules]];

// --- Generate code.
// 
// Each Crsx module corresponds to a single Java class. 
// 
// Each rule declaration corresponds to a single Java function.
//
JavaUnits[$String, $List[Module]] :: Text;
JavaUnits[#url, #modules] 
→ %n⟦/** Generated File */«PackageDeclaration»
import static org.crsx.runtime.ConstructionDescriptor.makeData;
import static org.crsx.runtime.ConstructionDescriptor.makeFunction;
import static org.crsx.runtime.Normalizer.thunk;
import static org.crsx.runtime.Normalizer.force;
import static org.crsx.runtime.Normalizer.forceSub;
import static org.crsx.runtime.Reference.safeRef;

import org.crsx.runtime.*;
import org.crsx.runtime.ConstructionDescriptor.*;
import static org.crsx.runtime.Primitives.*;
«TextFold[Map[module.JavaUnit[#url, module], #modules], %n⟨⟩]»⟧;

/* Generate class for the given module */ 
JavaUnit[$String, Module] :: Text;
JavaUnit[#mainurl, Module[#url, Loaded[LoadedContent[#rules, #datasorts, #funcsorts]]]] 
→ %n⟦«JavaClassVisibility[#mainurl, #url]» class †«ClassName[#url]»
{⟦«TextFold[Map[sort.JavaDataDesc[sort], MapValues[#datasorts]], %n⟨⟩]»
«TextFold[Map[sort.JavaFuncDesc[ClassName[#url], sort], MapValues[#funcsorts]], %n⟨⟩]»
«TextFold[Map[cons.JavaMethod[cons, #rules, #datasorts, #funcsorts], MapKeys[#rules]], %n⟨⟩]»
«InitModule[#datasorts, #funcsorts]»⟧
}⟧;

JavaClassVisibility[$String, $String] :: Text;
JavaClassVisibility[#mainurl, #url] 
→ $[If, $[Equal, #mainurl, #url], %n⟦public⟧, %n⟦static⟧];

JavaDataDesc[Core_cdecl_sort] :: Text;
JavaDataDesc[%cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧]
→ TextFold[Map[form.JavaFormDesc[form], #cform*], %n⟦⟧];

JavaFormDesc[Core_cform_sort] :: Text;
JavaFormDesc[%cform⟦ ##CONSTRUCTOR ##csorts? ⟧] 
→ %n⟦
final public static ConstructionDescriptor «Descriptor[#CONSTRUCTOR]» = makeData(«Text-QuoteEscape[#CONSTRUCTOR]»);⟧;

JavaFuncDesc[$String, Core_cdecl_sort] :: Text;
JavaFuncDesc[#classname, %cdecl⟦ func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧]
→ %n⟦final public static DynamicFunctionDescriptor «Descriptor[#CONSTRUCTOR]» = makeFunction(«Text-QuoteEscape[#CONSTRUCTOR]», †«#classname».class, "«ToJavaId[#CONSTRUCTOR]»");⟧; 

/* Generate methods for module rules */ 
JavaMethod[$String, Map[$String, $List[Core_cdecl_sort]],  
           Map[$String, Core_cdecl_sort], Map[$String, Core_cdecl_sort]] :: Text;
JavaMethod[#constructor, #rules, #datasorts, #funcsorts] 
→ %n⟦final public static boolean «JavaMethodSig[UnSOME[MapGet[#funcsorts, #constructor]], UnSOME[MapGet[#rules, #constructor]]]»⟧;

JavaMethodSig[Core_cdecl_sort, $List[Core_cdecl_sort]] :: Text;
JavaMethodSig[%cdecl⟦ func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧, #rules] 
→ %n⟦«ToJavaId[#CONSTRUCTOR]»(Sink sink, int shared«JavaSigMaybeArgs[
                SetSink[AddThunk[AddThunk[NewEnv, %n⟦sink⟧], Descriptor[#CONSTRUCTOR]], %n⟦sink⟧], #csorts?, #rules]»⟧;  // )

JavaSigMaybeArgs[JavaEnv, $List[Core_csorts_sort], $List[Core_cdecl_sort]] :: Text;
JavaSigMaybeArgs[#env, %csorts?⟦⟧, #rules]
→ JavaBody[#env, #rules];

JavaSigMaybeArgs[#env, %csorts?⟦ ( ##csort* ) ⟧, #rules]
→ JavaSigArgs[#env, #csort*, #rules];

JavaSigArgs[JavaEnv, $List[Core_csort_sort], $List[Core_cdecl_sort]] :: Text;
JavaSigArgs[#env, %csort*⟦ ⟧, #rules]
→ JavaBody[#env, #rules];

-[Fresh[term::Text]]:
JavaSigArgs[#env, %csort*⟦ ##CONSTRUCTOR ##csorts? ##csort* ⟧, #rules]
→ %n⟦, Term «term»«JavaSigArgs[AddArg[#env, term], #csort*, #rules]»⟧;

JavaBody[JavaEnv, $List[Core_cdecl_sort]] :: Text;
JavaBody[#env, #rules]
→ %n⟦) 
{⟦
if (++sink.context().sd < 256)
{⟦
«TextFold[Map[rule.JavaBodyRule[#env, rule], #rules], %n⟨⟩]»⟧
}
return «Thunk[GetThunk[#env]]»;⟧
}⟧;

/* Generates code creating fallback thunk */
Thunk[$List[Text]] :: Text;
Thunk[#texts] → %n⟦thunk(«TextFold[#texts, %n⟦, ⟧]»)⟧;

JavaBodyRule[JavaEnv, Core_cdecl_sort] :: Text;
JavaBodyRule[#env, %cdecl⟦ rule ##CONSTRUCTOR → ##cterm2 ⟧]
→ JavaContractum[#env, #cterm2];

JavaBodyRule[#env, %cdecl⟦ rule ##CONSTRUCTOR ( ##cterm* ) → ##cterm2 ⟧]
→ JavaPattern[#env, #cterm*, #cterm2];

// ----- Naive pattern matching. 

JavaPattern[JavaEnv, $List[Core_cterm_sort], Core_cterm_sort] :: Text;

-[Fresh[label::Text]]:
JavaPattern[#env, #cterms, #contractum]
→ %n⟦«label»:{⟦«JavaCasePattern[SetLabel[#env, label], #cterms, #contractum]»⟧
}⟧;

JavaCasePattern[JavaEnv, $List[Core_cterm_sort], Core_cterm_sort] :: Text;
JavaCasePattern[#env, #cterms, #contractum]
→ TextFold[MapMThen[
             state term.JavaPatternTerm[SetArgs[state, Tail[GetArgs[state]]], term, Head[GetArgs[state]]], 
             #env, #cterms, state.JavaContractum[state, #contractum]], %n⟦⟧];

// --- Term pattern matching

JavaPatternTerm[JavaEnv, Core_cterm_sort, Text /* Current term */] :: Pair[JavaEnv, Text];

JavaPatternTerm[#env, %cterm⟦ ##CONSTRUCTOR ##cterms? ⟧, #term]
→ PairCons[#env, %n⟦
«#term» = force(sink.context(), «#term»);
if («#term».descriptor() != «Descriptor[#CONSTRUCTOR]»)
{⟦
  break «GetLabel[#env]»;⟧
}«JavaPatternMaybeTerms[#env, #cterms?, #term]»⟧];

JavaPatternTerm[#env, %cterm⟦ ##cliteral ⟧, #term]
→ $[Error, "Internal error: invalid pattern matching on literal"];

-[Data[#term]]:
JavaPatternTerm[#env, %cterm⟦ ##METAVAR ##cterms? ⟧, #term]
→ PairCons[AddMeta[#env, #METAVAR, #term], %n⟦
/* «Text-CommentToken[#METAVAR]»=«Text-CommentToken[$[Show, #term]]» */⟧];  

JavaPatternTerm[#env, %cterm⟦ ##VARIABLE ⟧, #term] 
→ JavaPatternVariable[MapGetVar[#env, #VARIABLE], #env, #VARIABLE, #term];

JavaPatternMaybeTerms[JavaEnv, $List[Core_cterms_sort], Text] :: Text;
JavaPatternMaybeTerms[#env, %cterms?⟦⟧, #term]
→ %n⟦⟧;

JavaPatternMaybeTerms[#env, %cterms?⟦ ( ##cterm* ) ⟧, #term]
→ %n⟦⟧;

// --- Variable pattern matching outside of meta

JavaPatternVariable[Option[VarEntry], JavaEnv, $String, Text /* Current term */] :: Pair[JavaEnv, Text];

// First variable occurrence: it's a free variable.
JavaPatternVariable[NONE, #env, #variable, #term] 
→ PairCons[AddFreeVar[#env, #variable, #term], %n⟦
Variable «#variable» = «#term».variable();⟧];

// Bound variable
// TODO: update term's parent with evaluated term.
// TODO: release acquired references.
JavaPatternVariable[SOME[BOUND], #env, #variable, #term] 
→ PairCons[#env, %n⟦
«#term» = force(«GetSink[#env]».context(), «#term»);
if («#variable» != VARIABLE(«#term»)) 
{⟦
  break «GetLabel[#env]»;⟧
}⟧];

// ----- Contraction

JavaContractum[JavaEnv, Core_cterm_sort] :: Text;
JavaContractum[#env, #term] → SendTerm[#env, #term];

// ---- Contraction send mode

SendTerm[JavaEnv, Core_cterm_sort] :: Text;

SendTerm[#env, %cterm⟦ ##CONSTRUCTOR ##cterms? ⟧]
→ SendConstruction[#env, #CONSTRUCTOR, #cterms?];

SendTerm[#env, %cterm⟦ ##cliteral ⟧]
→ %n⟦¶«GetSink[#env]».literal(«Literal[#cliteral]»);«SendEndTerm[GetTail[#env]]»⟧;

SendTerm[#env, %cterm⟦ ##VARIABLE ⟧] 
→ %n⟦¶«SendVariable[#env, #VARIABLE]»«SendEndTerm[GetTail[#env]]»⟧;

SendTerm[%cterm⟦ ##VARIABLE ˢ ⟧] 
→ %n⟦⟧; // TODO

SendTerm[#env, %cterm⟦ ##METAVAR ##cterms? ⟧] 
→ %n⟦«SendMeta[#env, #METAVAR, #cterms?]»«SendEndTerm[GetTail[#env]]»⟧;

SendTerm[#env, %cterm⟦ [ ##VARIABLE ] ##cterm ⟧]  
→ %n⟦«SendEndTerm[GetTail[#env]]»⟧; // TODO

SendEndTerm[$Boolean] :: Text;
SendEndTerm[$True]  → %n⟦return true;⟧;
SendEndTerm[$False] → %n⟦⟧;

// ---- SEND construction

SendConstruction[JavaEnv, $String, $List[Core_cterms_sort]] :: Text;

SendConstruction[#env, #constructor, #cterms?]
→ %n⟦
«GetSink[#env]».start(«Descriptor[#constructor]»);«SendMaybeTerms[UnsetTail[#env], #cterms?]»
«GetSink[#env]».end();«SendEndTerm[GetTail[#env]]»⟧;

SendMaybeTerms[JavaEnv, $List[Core_cterms_sort]] :: Text;
SendMaybeTerms[#env, %cterms?⟦              ⟧] → %n⟦⟧;
SendMaybeTerms[#env, %cterms?⟦ ( ##cterm* ) ⟧] → TextFold[Map[term.SendTerm[#env, term], #cterm*], %n⟦⟧];

// ---- SEND scope variable

SendVariable[JavaEnv, $String] :: Text;
SendVariable[#env, #var]
→ %n⟦¶«GetSink[#env]».use(«GetVariable[#var]»);⟧;

// ---- SEND metavar

SendMeta[JavaEnv, $String, $List[Core_cterms_sort]] :: Text;

// No argument -> just send value.
SendMeta[#env, #metavar, %cterms?⟦⟧] 
→ %n⟦
«GetSink[#env]».copy(«GetMeta[#env, #metavar]».ref());⟧;

// With arguments -> substitute.
// Start by computing arguments and then call substitute.
SendMeta[#env, #metavar, %cterms?⟦ ( ##cterm* ) ⟧] 
→ SetTerms[#env, #cterm*, terms.SendSubstitutes[#env, #metavar, terms]];

SendSubstitutes[JavaEnv, $String, $List[Text]] :: Text;
SendSubstitutes[#env, #metavar, #substitutes]
→ %n⟦
«GetSink[#env]».substitute(«GetMeta[#metavar]».ref(), new Variable[] { «TextFold[GetBinders[#env], %n⟦, ⟧]» }, new Term[] {«TextFold[#substitutes, %n⟦, ⟧]»});⟧;

// ----- initModule

/* Generate code initializing a module.
   Dynamically register data and function descriptors.
*/
InitModule[MAP[$String, Core_cdecl_sort], MAP[$String, Core_cdecl_sort]] :: Text;

InitModule[#data, #func] 
→ %n⟦
private static boolean initialized = false;
public static void init(Context context)
{⟦
if (!initialized) 
{⟦
«TextFold[Map[sort.RegisterDataSort[sort], MapValues[#data]], %n⟨⟩]»«TextFold[Map[sort.RegisterFuncSort[sort], MapValues[#func]], %n⟨⟩]»
initialized = true;⟧
}⟧
}⟧;

//Register[%declaration⟦ import module ##constructor ; ⟧] 
//→
//%n⟦
//«PathToImport[#constructor]».init(context);⟧;
//// TODO: unify path resolution
//Register[%declaration⟦ import grammar ##CONSTRUCTOR ; ⟧] 
//→
//%n⟦⟧;
////context.registerParser(«Text-QuoteEscape[Replace[#CONSTRUCTOR, "/", "."]]»);⟧;

RegisterDataSort[Core_cdecl_sort] :: Text;
RegisterDataSort[%cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧]
→ TextFold[Map[form.RegisterDataForm[form], #cform*], %n⟨⟩];

RegisterDataForm[Core_cform_sort] :: Text;
RegisterDataForm[%cform⟦ ##CONSTRUCTOR ##csorts? ⟧] 
→ %n⟦
context.register(«Descriptor[#CONSTRUCTOR]»);⟧;

RegisterFuncForm[Core_cdecl_sort] :: Text;
RegisterFuncSort[%cdecl⟦ func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧]
→ %n⟦
context.register(«Descriptor[#CONSTRUCTOR]»);⟧; 

/* Print package declaration */
PackageDeclaration :: Text;
PackageDeclaration → PackageDeclaration2[$[Get, "javabasepackage", ""], $[Get, "javapackage", ""]];

PackageDeclaration2[$String, $String] :: Text;
PackageDeclaration2[#base, #sub] 
→ %n⟦
package †«#base»«PackageDeclaration3[$[If, $[StringEqual, $[Trim, #base], ""],"", "."], #sub]»;⟧;

PackageDeclaration3[$String, $String] :: Text;
PackageDeclaration3[#sep, #sub] 
→
$[If, $[StringEqual, $[Trim, #sub], ""], %n⟦⟧, %n⟦†«#sep»†«#sub»⟧];
//
//// Print java import
//PathToImport[Crsx_constructor_sort] :: Text;
//
//PathToImport[%constructor⟦ ##CONSTRUCTOR ⟧] 
//→ 
//PathToImport2[$[If, $[StartsWith, #CONSTRUCTOR, "std/"], "org.crsx.compiler", $[Get, "javabasepackage", ""]], PathToDot[#CONSTRUCTOR]];
//
//PathToImport2[$String, $String] :: Text;
//
//-[Data[#package, #name]] : 
//PathToImport2[#package, #name] 
//→ 
//%n⟦«StringToText[#package]».«StringToText[#name]»⟧;
//
//PathToDot[$String] :: $String;
//PathToDot[#path] → PathToDot2[Replace[BeforeLast[#path, "."], "/", "."]];
//
//PathToDot2[$String] :: $String;
//-[Data[#subpackage]]: PathToDot2[#subpackage] 
//→ 
//$[If, $[Contains, #subpackage, "."],
//    ConcatString[ConcatString[BeforeLast[#subpackage, "."], "."], UpCaseFirst[AfterLast[#subpackage, "."]]],
//    UpCaseFirst[#subpackage]];

// Print class name
ClassName[$String] :: $String;
ClassName[#name] → UpCaseFirst[AfterLast[BeforeLast[#name, "."], "/"]]; 

// ----------- Code generation environment

// To change when upgrade to crsx4.

VarEntry ::= ( FREE; BOUND; FRESH; SEMANTIC; );

JavaEnvEntry ::= ( EText[Text]; ETexts[$List[Text]]; EBool[$Boolean]; EMapText[MAP[$String, Text]]; EMapVar[MAP[$String, VarEntry]]; );

{$String:JavaEnvEntry} 
JavaEnv ::= ( JavaEnv; );

NewEnv :: JavaEnv;
NewEnv → { "sink" : EText[%n⟦⟧];   /* Current sink. */
           "args" : ETexts[()];    /* Java method arguments. */
           "thunk": ETexts[()];    /* thunk arguments */
           "label": EText[%n⟦⟧];   /* Current pattern block label. */
           "tail" : EBool[$True];  /* Tail? */
           "meta" : EMapText[MAP]; /* Map meta variable to java variable */
           "vars" : EMapVar[MAP]   /* Map variable to VarEntry */
         }JavaEnv;

// --- Helpers.

∀ a.GetValue[JavaEnv, $String, x::JavaEnvEntry.$sort[a]] :: a;
GetValue[{#env}JavaEnv, #key, x.#unwrap[x]]
→ #unwrap[$[{#env}Get, #key]];

UnText[JavaEnvEntry] :: Text;
UnText[EText[#]] → #;

UnTexts[JavaEnvEntry] :: $List[Text];
UnTexts[ETexts[#]] → #;

UnBool[JavaEnvEntry] :: $List[Text];
UnBool[EBool[#]] → #;

UnMapText[JavaEnvEntry] :: MAP[$String, Text];
UnMapText[EMapText[#]] → #;

// --- Sink

GetSink[JavaEnv] :: Text;
GetSink[#env] → GetValue[#env, "sink", x.UnText[x]];

SetSink[JavaEnv, Text] :: Text;
SetSink[{#env}JavaEnv, #sink] → {#env; "sink": EText[#sink]}JavaEnv;

// --- Step method arguments

GetArgs[JavaEnv] :: $List[Text];
GetArgs[#env] → GetValue[#env, "args", x.UnTexts[x]];

SetArgs[JavaEnv, $List[Text]] :: Text;
SetArgs[{#env}JavaEnv, #args] → {#env; "args": ETexts[#args]}JavaEnv;

AddArg[JavaEnv, Text] :: JavaEnv;
AddArg[{#env}JavaEnv, #arg] → {#env; "args": ETexts[Append[#arg, GetArgs[{#env}JavaEnv]]]}JavaEnv;

// --- Thunk arguments

GetThunk[JavaEnv] :: $List[Text];
GetThunk[#env] → GetValue[#env, "thunk", x.UnTexts[x]];

SetThunk[JavaEnv, $List[Text]] :: Text;
SetThunk[{#env}JavaEnv, #thunk] → {#env; "thunk": ETexts[#thunk]}JavaEnv;

AddThunk[JavaEnv, Text] :: JavaEnv;
AddThunk[{#env}JavaEnv, #thunk] → {#env; "thunk": ETexts[Append[#thunk, GetThunk[{#env}JavaEnv]]]}JavaEnv;

// --- Rule case label

GetLabel[JavaEnv] :: Text;
GetLabel[#env] → GetValue[#env, "label", x.UnText[x]];

SetLabel[JavaEnv, Text] :: Text;
SetLabel[{#env}JavaEnv, #label] → {#env; "label": EText[#label]}JavaEnv;

// --- Tail mode.

GetTail[JavaEnv] :: Text;
GetTail[#env] → GetValue[#env, "tail", x.UnBool[x]];

SetTail[JavaEnv, Text] :: Text;
SetTail[{#env}JavaEnv] → {#env; "tail": EBool[$True]}JavaEnv;

UnsetTail[JavaEnv, Text] :: Text;
UnsetTail[{#env}JavaEnv] → {#env; "tail": EBool[$False]}JavaEnv;

// --- Meta

GetMetas[JavaEnv] :: MAP[$String, Text];
GetMetas[#env] → GetValue[#env, "meta", x.UnMapText[x]];

GetMeta[JavaEnv, $String] :: Text;
GetMeta[#env, #metavar] → UnSOME[MapGet[GetMetas[#env], #metavar]];

AddMeta[JavaEnv, $String, Text] :: JavaEnv;
AddMeta[{#env}JavaEnv, #metavar, #term]
→ {#env; "meta": EMapText[MapPut[GetMetas[{#env}JavaEnv], #metavar, #term]]}JavaEnv;

SetValue[JavaEnv, $String, JavaEnvEntry] :: JavaEnv;
-[Data[#value]]: 
SetValue[{#env}JavaEnv, #key, #value]
→ {#env; #key: #value}JavaEnv;

// --- Variable


)]