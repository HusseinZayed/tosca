// Copyright (c) 2015 IBM Corporation.
/*
 * CRSX Java backend code generator
 *
 * Generate Java 8 source code from normalized CRSX.
 *  
 * 
 */
CG[(

$Lax;

$AddGrammar["net.sf.crsx.text.Text"];
$AddGrammar["org.crsx.parser.CrsxMetaParser"];

$CheckGrammar["net.sf.crsx.text.Text"];
$CheckGrammar["org.crsx.parser.CrsxMetaParser"];

$Use["cg/sortutil.crs"];
$Use["parser/Crsx.crs"];
$Use["text/Text.crs"];
$Use["std/string.crs"];
$Use["std/text.crs"];
$Use["std/list.crs"];
$Use["crsxutils.crs"];

// ===== API

GenerateJava[$String, Mode] :: Text;
GenerateJava[#, #mode] → GenerateJavaParsed[#, $[ParseResource, "crsx", #], #mode];

GenerateJavaParsed[$String, Crsx_crsx_sort, Mode] :: Text;
GenerateJavaParsed[#filename, #crsx, #mode] 
→ 
//LoadSort_Crsx[#crsx, ok.Crsx[ok, #filename, #crsx, #mode]];
Crsx[OK, #filename, #crsx, #mode];

// ===== Sorts and utilities

UnTEXT[STRING_ENTRY] :: Text;
UnTEXT[TEXT[#]] → #;

UnSTRING[STRING_ENTRY] :: Text;
UnSTRING[STRING[#]] → #;

UnMETA[STRING_ENTRY] :: Text;
UnMETA[META[#1, #2]] → #1;

UnMETABinders[STRING_ENTRY] :: Text;
UnMETABinders[META[#1, #2]] → #2;

// --- Generate code.
// 
// Each CRSX corresponds to a single Java class.
// Each rule declaration corresponds to a Java function.
//

Crsx[OK_SORT, $String, Crsx_crsx_sort, Mode] :: Text;

{#E}Crsx[OK, #filename, %crsx⟨ #declarations ⟩, #mode] → {#E}JavaUnit[#filename, #declarations, #mode];

JavaUnit[$String, Crsx_declarations_sort] :: Text;

{#E}JavaUnit[#filename, #declarations, #mode] 
→
%n⟨«JavaHeader[#mode]»class †«ClassName[#filename]»
{⟦«{#E; "$classname": STRING[ClassName[#filename]]}Declarations[DesugarDeclarations[#declarations]]»«InitModule[DesugarDeclarations[#declarations]]»⟧
«JavaFooter[#mode]»⟩;

JavaHeader[Mode] :: Text;

JavaHeader[MAINMODULE]
→
%n⟨/** Generated File */«PackageDeclaration»
import static org.crsx.runtime.ConstructionDescriptor.makeData;
import static org.crsx.runtime.ConstructionDescriptor.makeFunction;
import static org.crsx.runtime.Normalizer.thunk;

import org.crsx.runtime.*;
import org.crsx.runtime.ConstructionDescriptor.*;

@SuppressWarnings("unused")
public ⟩;

JavaHeader[SUBMODULE]
→
%n⟨¶public static ⟩;


JavaFooter[Mode] :: Text;

JavaFooter[MAINMODULE] → %n⟨⟩;
JavaFooter[SUBMODULE ] → %n⟨}⟩;

Declarations[$List[Crsx_declarations_S1_sort]] :: Text;

{#E}Declarations[%declarations_S1*⟨                                  ⟩] → %n⟨⟩;
{#E}Declarations[%declarations_S1*⟨ ;                                ⟩] → %n⟨⟩;

{#E}Declarations[%declarations_S1*⟨ ; #declaration #declarations_S1* ⟩]
→
%n⟨«{#E}Declaration[#declaration]»«{#E}Declarations[#declarations_S1*]»⟩;

// --- declarations

// module
{#E}Declaration[%declaration⟨ module #STRING { #declarations } ⟩] 
→
{#E}Declarations[#declarations];

// rule
{#E}Declaration[%declaration⟨ #option? #pattern → #contractum ⟩] 
→
{#E}Rule[#pattern, #contractum];

// data sort
{#E}Declaration[%declaration⟨ #sortparams? #sortset #sortname ::= ( #forms_S1* )  ⟩]
→
{#E}DataSort[#sortset, #sortname, #forms_S1*];

// function sort
{#E; "$classname":STRING[#class]}
Declaration[%declaration⟨ #sortparams? #sortset #constructor #arguments? :: #sortname  ⟩]
→
%n⟨¶final public static DynamicFunctionDescriptor «Descriptor[#constructor]» = makeFunction(«QuotedConstructor[#constructor]», †«#class».class, "«ToJavaId[#constructor]»");⟩; 

// Nested declarations  
{#E}Declaration[%declaration⟨ #constructor                     ⟩] → %n⟨⟩; // TODO: codegen directive/constant.
{#E}Declaration[%declaration⟨ #constructor [(               )] ⟩] → %n⟨⟩;
{#E}Declaration[%declaration⟨ #constructor [( #declarations )] ⟩] → {#E}Declarations[#declarations];

// --- Data sort

DataSort[Crsx_sortset_sort, Crsx_sortname_sort, Crsx_sortname_sort, $List[Crsx_forms_S1_sort]] :: Text;

{#E}DataSort[#sortset, #sortname, #forms]
→
Text-Concat[Map[form.{#E}DataForm[form], #forms]];

DataForm[Crsx_forms_S1_sort] :: Text;

{#E}DataForm[%forms_S1⟨ #constructor #arguments? ; ⟩] 
→
%n⟨
final public static ConstructionDescriptor «Descriptor[#constructor]» = makeData(«QuotedConstructor[#constructor]»);⟩;

// --- Rule declaration
//
// A rule maps directly to a Java function. 
// Generate the non-step function. 
//

Rule[Crsx_pattern_sort, Crsx_contractum_sort] :: Text;

{#E}Rule[#pattern, #contractum] 
→
%n⟨final public static boolean «{#E}Signature[#pattern, #contractum]»⟩;

Signature[Crsx_term_sort, Crsx_term_sort] :: Text;

{#E}Signature[%pattern⟨ #properties? #constructor #arguments? ⟩, #contractum] 
→ 
%n⟨«{#E; "$method-name": ToJavaId[#constructor]}ToJavaId[#constructor]»(Sink sink, int shared, int depth«
  {#E; "$thunk-args": TEXTS[(%n⟨sink⟩; Descriptor[#constructor];)]}SigMaybeArguments[#arguments?, %pattern⟨  #properties? #constructor #arguments? ⟩, #contractum]»⟩;  // )


SigMaybeArguments[$List[Crsx_arguments_sort], Crsx_pattern_sort, Crsx_contractum_sort] :: Text;

// Constant function.
{#E}SigMaybeArguments[%arguments?⟨            ⟩, #pattern, #contractum] → {#E}Body[#pattern, #contractum];

{#E}SigMaybeArguments[%arguments?⟨ #arguments ⟩, #pattern, #contractum] → {#E}SigArguments[#arguments, #pattern, #contractum] ;

SigArguments[Crsx_arguments_sort, Crsx_pattern_sort, Crsx_contractum_sort] :: Text;
{#E}SigArguments[%arguments⟨ [ #terms? ] ⟩, #pattern, #contractum] → {#E}SigMaybeTerms[#terms?, #pattern, #contractum];

SigMaybeTerms[$List[Crsx_terms_sort], Crsx_pattern_sort, Crsx_contractum_sort] :: Text;

// Constant function.
{#E}SigMaybeTerms[%terms?⟨        ⟩, #pattern, #contractum] → {#E}Body[#pattern, #contractum];

{#E}SigMaybeTerms[%terms?⟨ #terms ⟩, #pattern, #contractum] 
→
{#E; "$binders": TEXTS[()]}SigTerms[DesugarTerms[#terms], #pattern, #contractum]; 
 
SigTerms[$List[Crsx_terms_S1_sort], Crsx_pattern_sort, Crsx_contractum_sort] :: Text;

{#E}SigTerms[%terms_S1*⟨                                       ⟩, #pattern, #contractum] → {#E}Body[#pattern, #contractum];

// Matches a meta-application. Arguments can be ignored.
{#E}SigTerms[%terms_S1*⟨ , #METAVAR #freeArguments? #terms_S1* ⟩, #pattern, #contractum]
→ 
{#E}SigMeta[MetaKey[#METAVAR], #terms_S1*, #pattern, #contractum];

{#E}SigTerms[%terms_S1*⟨ , #binder #nextBinder #terms_S1*      ⟩, #pattern, #contractum]
→
{#E}SigNextBinder[%nextBinder⟨ #binder #nextBinder ⟩, #terms_S1*, #pattern, #contractum];

-[Fallback]:
{#E}SigTerms[#terms, #pattern, #contractum]
→ 
$[Error, "Internal error: all pattern arguments must be metavariable."];

SigNextBinder[Crsx_nextBinder_sort, $List[Crsx_terms_S1_sort], Crsx_pattern_sort, Crsx_contractum_sort] :: Text;

{#E}SigNextBinder[%nextBinder⟨ . #freeTerm ⟩, #terms_S1*, #pattern, #contractum]
→
{#E}SigTerms[%terms_S1*⟨ , #freeTerm #terms_S1* ⟩, #pattern, #contractum];

{#E}SigNextBinder[%nextBinder⟨ #binder #nextBinder ⟩, #terms_S1*, #pattern, #contractum]
→
{#E}SigVar[BinderKey[#binder], #nextBinder, #terms_S1*, #pattern, #contractum];

SigMeta[$String, $List[Crsx_terms_S1_sort], Crsx_pattern_sort, Crsx_contractum_sort] :: Text;

-[Fresh[term::Text], Data[#key]]:
{#E; "$binders": TEXTS[#binders]; "$thunk-args":TEXTS[#thunk]}
SigMeta[#key, #terms_S1*, #pattern, #contractum]
→ 
%n⟨, Term «term»«{#E; #key : META[term, #binders]; "$thunk-args":TEXTS[Concat[#thunk, (term;)]]}SigTerms[#terms_S1*, #pattern, #contractum]» ⟩;

SigVar[$String, $List[Crsx_terms_S1_sort], Crsx_pattern_sort, Crsx_contractum_sort] :: Text;

-[Fresh[var::Text], Data[#key]]:
{#E; "$binders":TEXTS[#binders]; "$thunk-args":TEXTS[#thunk]}
SigVar[#key, #nextBinder, #terms_S1*, #pattern, #contractum]
→ 
%n⟨, Variable «var»«{#E; #key:TEXT[var]; "$binders":TEXTS[Concat[#binders, (var;)]]; "$thunk-args":TEXTS[Concat[#thunk, (var;)]]}SigNextBinder[#nextBinder, #terms_S1*, #pattern, #contractum]»  ⟩;

// ------ function body

Body[Crsx_pattern_sort, Crsx_Constractum_sort] :: Text;

{#E}Body[#pattern, %contractum⟨ #freeTerm ⟩]
→
%n⟨) {⟦¶if (depth < 2000) {⟦«{#E; "$sink": TEXT[%n⟨sink⟩]; "$tail":YES; "$binders":TEXTS[()]}SendFreeTerm[#freeTerm]»⟧¶}¶return «{#E}Thunk»;⟧¶}⟩;

Thunk :: Text;

{#E; "$thunk-args":TEXTS[#thunk]}
Thunk
→
%n⟨thunk(«Text-ConcatSep[#thunk, %n⟨, ⟩]»)⟩;

// ------- SEND mode
// 
// Generate code sending term to a sink

SendTerm[Crsx_term_sort] :: Text;

{#E}SendTerm[%term⟨ #freeTerm ⟩]           → {#E; "$binders": TEXTS[()]}SendFreeTerm[#freeTerm];
{#E}SendTerm[%term⟨ #binder #nextBinder ⟩] → {#E; "$binders": TEXTS[()]}SendBinders[%nextBinder⟨ #binder #nextBinder ⟩];

SendFreeTerm[Crsx_freeTerm_sort] :: Text;

// Construction     
{#E}SendFreeTerm[%freeTerm⟨ #annotations? #constructor #arguments? ⟩] 
→ 
{#E}SendConstructor[IndexAnnotations[#annotations?], #constructor, #arguments?];

// Construction one argument     
{#E}SendFreeTerm[%freeTerm⟨ #annotations? #constructor #term ⟩] 
→
{#E}SendFreeTerm[%freeTerm⟨ #annotations? #constructor [ #term ] ⟩];

// Literal     
{#E; "$sink":TEXT[#sink]; "$tail":#tail}
SendFreeTerm[%freeTerm⟨ #annotations? #literal ⟩] 
→
%n⟨¶«#sink».literal(«#literal»);«SendTail[#tail]»⟩;

// List     
{#E}SendFreeTerm[%freeTerm⟨ #annotations? #list ⟩] 
→ 
{#E}SendFreeTerm[DesugarList[#list]]; 

// variable     
{#E}SendFreeTerm[%freeTerm⟨ #annotations? #VARIABLE #linear? #functional? #varsort? ⟩] 
→
{#E}SendVariable[VarKey[%variable⟨ #VARIABLE #linear? #functional? ⟩]];

// struct     
{#E}SendFreeTerm[%freeTerm⟨ #annotations? #properties ⟩] 
→
$[Error, "Named data structure not implemented yet."];

// meta     
{#E; "$tail":#tail}
SendFreeTerm[%freeTerm⟨ #annotations? #METAVAR #freeArguments? ⟩] 
→
%n⟪«{#E; "$tail": NO}SendMeta[#METAVAR, #freeArguments?]»«SendTail[#tail]»⟫;

// dispatch expression
{#E}SendFreeTerm[%freeTerm⟨ #annotations? #dispatch ⟩] 
→
{#E}SendDispatch[#dispatch]; 

{#E}SendFreeTerm[%freeTerm⟨ #annotations? #expression ⟩] 
→
$[Error, $[:, "Expression not implemented yet: ", #expression]]; 

// --- SEND constructor

SendConstructor[Annotations, Crsx_constructor_sort,  $List[Crsx_arguments_sort]] :: Text;

// Data constructor: send start/end event to sink.
{#E; "$tail": #tail; "$sink": TEXT[#sink]}
SendConstructor[{#A; ¬"@Function"}ANNOTATIONS, #constructor, #arguments?]
→
%n⟨¶«#sink».start(«Descriptor[#constructor]»);«{#E; "$tail": NO}SendArgumentsOpt[#arguments?]»
«#sink».end();«SendTail[#tail]»⟩;

// Function constructor - lazy
{#E; "$tail": #tail; "$sink": TEXT[#sink]}   
SendConstructor[{#A; "@Function"}ANNOTATIONS, #constructor2, #arguments2?]
→
%n⟨ 
«#sink».start(«Descriptor[#constructor2]»);«{#E; "$tail": NO}SendArgumentsOpt[#arguments2?]»
«#sink».end();ff«SendTail[#tail]»⟩;

SendArgumentsOpt[$List[Crsx_arguments_sort]] :: Text;

{#E}SendArgumentsOpt[%arguments?⟨            ⟩] → %n⟨⟩;
{#E}SendArgumentsOpt[%arguments?⟨ [        ] ⟩] → %n⟨⟩;
{#E}SendArgumentsOpt[%arguments?⟨ [ #terms ] ⟩] → {#E}SendTerms[#terms];

SendTerms[Crsx_terms_sort] :: Text;

{#E}SendTerms[%terms⟨ #term #terms_S1* ⟩] 
→
%n⟨«{#E}SendTerm[#term]»«{#E}SendTerms_S1_ZOM[#terms_S1*]»⟩;

SendTerms_S1_ZOM[$List[Crsx_terms_S1_sort]] :: Text;

{#E}SendTerms_S1_ZOM[%terms_S1*⟨                    ⟩] → %n⟨⟩;

{#E}SendTerms_S1_ZOM[%terms_S1*⟨ , #term #terms_S1* ⟩] 
→
%n⟨«{#E}SendTerm[#term]»«{#E}SendTerms_S1_ZOM[#terms_S1*]»⟩;
  
SendBinders[Crsx_nextBinder_sort] :: Text;

{#E}SendBinders[%nextBinder⟨ #binder #nextBinder ⟩] → {#E}SendBindersKey[BinderKey[#binder], #binder, #nextBinder];

{#E; "$sink":TEXT[#sink]; "$binders":TEXTS[#binders]}
SendBinders[%nextBinder⟨ . #freeTerm         ⟩] 
→
%n⟨¶«#sink».binds(new Variable[] {«Text-ConcatSep[#binders, %n⟨,⟩]»});«{#E}SendFreeTerm[#freeTerm]»⟩;

SendBindersKey[$String, Crsx_nextBinder_sort] :: Text;

-[Fresh[var::Text], Data[#key]]:
{#E; "$sink":TEXT[#sink]; "$binders": TEXTS[#binders]}
SendBindersKey[#key, %binder⟨ #VARIABLE ⟩, #nextBinder]
→
%n⟨¶Variable «var» = «#sink».context().makeVariable("†«#VARIABLE»");«
      {#E; var: BOUND; #key: TEXT[var]; "$binders": TEXTS[Concat[#binders, (var;)]]}SendBinders[#nextBinder]»⟩;

// --- SEND var

SendVariable[$String] :: Text;

-[Data[#key]]:
{#E}SendVariable[#key]
→
{#E}SendVariable0[$[{#E}Get, #key]];

SendVariable0[STRING_ENTRY] :: Text;

{#E; "$sink":TEXT[#sink]; "$tail":#tail}
SendVariable0[TEXT[#var]]
→
%n⟨¶«#sink».use(«#var»);«SendTail[#tail]»⟩;

// --- SEND meta

// TODO: reuse and functional binders
SendMeta[$String, $List[Crsx_freeArguments_sort]] :: Text;
{#E}SendMeta[#metavar, #freeArguments?] → $[Trace, {#E}SendMetaKey[MetaKey[#metavar], #metavar, #freeArguments?]];

SendMetaKey[$String, $String, $List[Crsx_freeArguments_sort]] :: Text;

-[Data[#key]]:
{#E}SendMetaKey[#key, #metavar, #freeArguments?] 
→
{#E}SendMetaEntry[$[{#E}Get, #key], #metavar, #freeArguments?]; 

SendMetaEntry[STRING_ENTRY, $String, $List[Crsx_freeArguments_sort]] :: Text;

// No argument -> just send value.
{#E; "$sink":TEXT[#sink]}
SendMetaEntry[META[#var, #binders], #metavar, %freeArguments?⟨ ⟩] 
→
%n⟨¶«#sink».copy(«#var»);⟩;

// Also no argument -> just send value.
{#E; "$sink":TEXT[#sink]}
SendMetaEntry[META[#var, #binders], #metavar, %freeArguments?⟨ [] ⟩] 
→
%n⟨¶«#sink».copy(«#var»);⟩;

// With arguments -> substitute.
// Start by computing arguments and then call substitute.
{#E}SendMetaEntry[META[#var, #binders], #metavar, %freeArguments?⟨ [ #freeTerms ] ⟩] 
→
{#E}SetFreeTerms[#freeTerms, ok¹ args¹.SendSubstitutes[ok¹, #metavar, #binders, args¹]];

SendSubstitutes[OK_SORT, $String, $List[Text]] :: Text;

{#E; "$sink": TEXT[#sink]}
SendSubstitutes[OK, #metavar, #binders, #substitutes]
→
%n⟨¶«#sink».substitute(«{#E}MetaVar[#metavar]».ref(), new Variable[] { «Text-ConcatSep[#binders, %n⟨, ⟩]» }, new Term[] {«Text-ConcatSep[#substitutes, %n⟨, ⟩]»});⟩;

// --- SEND dispatch

//
// Generate code for the dispatch expression.
//
// The core dispatched term must always be a constructor of the form C[x₁..xᵢ.#1[x₁..xᵢ], ..., x₁..xᵢ.#N[x₁..xᵢ]],
// where all arguments are meta-variables, potentially with binders. They must be ordered is such a way that
// patterns capturing terms must occur before pattern using captured terms.
//
// Since the dispatched term is all meta-variables (except the wrapping constructor), there is no need to construct it.
// Instead, each meta-variable is mapped to an existing meta-variable and dereferenced as needed. And furthermore,
// since all dispatch cases start with the same dispatched term constructor, there is also no need to dynamically check for it.
//
// A dispatch expression with a delay branch must always be top-level.
//
 
SendDispatch[Crsx_dispatch_sort] :: Text;

{#E}SendDispatch[%dispatch⟨ dispatch #term #dispatchCases #delayCase? ⟩]
→
{#E}SendDispatchTopTerm[#term, ok¹.SendDispatchCases[ok¹, DesugarDispatchCases[#dispatchCases]]];

-[Fallback]:
{#E}SendDispatch[#dispatch]
→
$[Error, "Invalid CRSX core term: conjunctive dispatch expression not allowed."];

// Process dispatch term

SendDispatchTopTerm[Crsx_term_sort, ok¹::OK_SORT.Text] :: Text;

{#E}SendDispatchTopTerm[%term⟨ #freeTerm ⟩,           ok¹.#[ok¹]] → {#E}SendDispatchTopFreeTerm[#freeTerm, ok¹.#[ok¹]];
{#E}SendDispatchTopTerm[%term⟨ #binder #nextBinder ⟩, ok¹.#[ok¹]] → $[Error, "Error: a dispatch term cannot start with binders."];

SendDispatchTopFreeTerm[Crsx_freeTerm_sort, ok¹::OK_SORT.Text] :: Text;

{#E}SendDispatchTopFreeTerm[%freeTerm⟨ #constructor [ #terms ] ⟩, ok¹.#[ok¹]] 
→
{#E}SendDispatchTerms[OK, DesugarTerms[#terms], 0, ok¹.#[ok¹]];

-[Fallback]:
{#E}SendDispatchTopFreeTerm[#freeTerm, ok¹.#[ok¹]] 
→
$[Error, $[:, "Internal Error: invalid dispatch term. Got: ", $[Show, #freeTerm]]];

SendDispatchTerms[OK_SORT, $List[Crsx_terms_S1_sort], $Numeric, ok¹::OK_SORT.Text] :: Text;

{#E}SendDispatchTerms[OK, %terms_S1*⟨                    ⟩, #position, ok¹.#[ok¹]] → {#E}#[OK];

{#E}SendDispatchTerms[OK, %terms_S1*⟨ , #term #terms_S1* ⟩, #position, ok¹.#[ok¹]] 
→ 
{#E}SendDispatchTerm[#term, #position, ok¹.SendDispatchTerms[ok¹, #terms_S1*, $[Plus, #position, 1], ok¹.#[ok¹]]];

SendDispatchTerm[Crsx_term_sort, $Numeric, ok¹::OK_SORT.Text] :: Text;

{#E}SendDispatchTerm[%term⟨ #freeTerm ⟩, #position, ok¹.#[ok¹]]
→
{#E}SendDispatchFreeTerm[#freeTerm, #position, ok¹.#[ok¹]]; 

{#E}SendDispatchTerm[%term⟨ #binder #nextBinder ⟩, #position, ok¹.#[ok¹]] 
→
{#E}SendDispatchBinders[%nextBinder⟨ #binder #nextBinder ⟩, #position, ok¹.#[ok¹]];

SendDispatchFreeTerm[Crsx_freeTerm_sort, $Numeric, ok¹::OK_SORT.Text] :: Text;

// Record which meta-variable correspond to the current dispatch argument position
{#E}SendDispatchFreeTerm[%freeTerm⟨ #METAVAR #freeArguments? ⟩, #position, ok¹.#[ok¹]]
→
{#E}SendDispatchMeta[MetaDispatchKey[#position], MetaKey[#METAVAR], ok¹.#[ok¹]]; 

{#E}SendDispatchFreeTerm[#freeTerm, #position, ok¹.#[ok¹]]
→
$[Error, $[:, "Internal error: dispatch term arguments must be all meta-variables. Got: ", $[Show, #freeTerm]]];

SendDispatchMeta[$String, $String, ok¹::OK_SORT.Text] :: Text;

-[Data[#dispatchKey, #metavarKey]]:
{#E}SendDispatchMeta[#dispatchKey, #metavarKey, ok¹.#[ok¹]]
→
{#E; #dispatchKey: STRING[#metavarKey]}#[OK];

SendDispatchBinders[Crsx_nextBinder_sort, $Numeric, ok¹::OK_SORT.Text] :: Text;

{#E}SendDispatchBinders[%nextBinder⟨ . #freeTerm ⟩, #position, ok¹.#[ok¹]] 
→ 
{#E}SendDispatchFreeTerm[#freeTerm,  #position, ok¹.#[ok¹]];

// Not need to keep tracks of binders, as they are not materialized.
{#E}SendDispatchBinders[%nextBinder⟨ #binder #nextBinder ⟩, #position, ok¹.#[ok¹]] 
→ 
{#E}SendDispatchBinders[#nextBinder, #position, ok¹.#[ok¹]];

// --- dispatch cases

SendDispatchCases[OK_SORT, $List[Crsx_dispatchCases_S1_sort]] :: Text;

{#E}SendDispatchCases[OK, %dispatchCases_S1*⟨⟩] → %n⟨⟩;

{#E}SendDispatchCases[OK, %dispatchCases_S1*⟨ ; #dispatchCase #dispatchCases_S1* ⟩] 
→
%n⟨«{#E}SendDispatchCase[#dispatchCase]»«{#E}SendDispatchCases[OK, #dispatchCases_S1*]»⟩; 

SendDispatchCase[Crsx_dispatchCase_sort] :: Text;

// TODO: handle properties
-[Fresh[label::Text]]:
{#E}SendDispatchCase[%dispatchCase⟨ #option? #properties? #constructor [ #terms ] → #freeTerm ⟩] 
→
%n⟨¶«label»: {⟦«{#E; "$caselabel":TEXT[label]}SendMatchTerms[OK, DesugarTerms[#terms], 0, ok¹.SendContraction[ok¹, #freeTerm]]»⟧¶}⟩;

-[Fallback]:
{#E}SendDispatchCase[#dispatchCase] 
→
$[Error, $[:, "Internal error: dispatch case pattern must be of the form C[ ... ]. Got: ", $[Show, #dispatchCase]]];

SendMatchTerms[OK_SORT, $List[Crsx_terms_S1_sort], $Numeric, ok¹::OK_SORT.Text] :: Text;

{#E}SendMatchTerms[OK, %terms_S1*⟨                    ⟩, #position, ok¹.#[ok¹]] → {#E}#[OK];

{#E}SendMatchTerms[OK, %terms_S1*⟨ , #term #terms_S1* ⟩, #position, ok¹.#[ok¹]] 
→ 
{#E; "$binders": TEXTS[{#E}DispatchedMetaVarBinders[#position]]}SendMatchTerm[#term, {#E}DispatchedMetaVar[#position], #position, ok¹.SendMatchTerms[ok¹, #terms_S1*, $[Plus, #position, 1], ok¹.#[ok¹]]];

SendMatchTerm[Crsx_term_sort, Text /* Current term */, $Numeric /* term position*/, ok¹::OK_SORT.Text] :: Text;

{#E}SendMatchTerm[%term⟨ #freeTerm ⟩, #term, #termpos, ok¹.#[ok¹]] 
→
{#E}SendMatchFreeTerm[#freeTerm, #term, ok¹.#[ok¹]];

// 
{#E}SendMatchTerm[%term⟨ #binder #nextBinder ⟩, #term, #termpos, ok¹.#[ok¹]] 
→
{#E}SendMatchNextBinder[%nextBinder⟨ #binder #nextBinder⟩, #term, #termpos, 0, ok¹.#[ok¹]];

SendMatchFreeTerm[Crsx_freeTerm_sort, Text /* Current term */, ok¹::OK_SORT.Text] :: Text;

// TODO: compare descriptors?
{#E;"$caselabel":TEXT[#label]}
SendMatchFreeTerm[%freeTerm⟨ #constructor #arguments? ⟩, #term, ok¹.#[ok¹]] 
→
%n⟨¶if (!«#term».symbol().equals(«QuotedConstructor[#constructor]»))¶{⟦¶break «#label»;⟧¶}«{#E}SendMatchArgumentsOpt[#arguments?, #term, ok¹.#[ok¹]]»⟩;

// Just desuaar single arg construction. 
{#E}SendMatchFreeTerm[%freeTerm⟨ #constructor #term ⟩, #cterm, ok¹.#[ok¹]] 
→
{#E}SendMatchFreeTerm[%freeTerm⟨ #constructor [ #term ] ⟩, #cterm, ok¹.#[ok¹]];

// Match Literal
{#E}SendMatchFreeTerm[%freeTerm⟨ #literal ⟩, #term, ok¹.#[ok¹]] 
→
$[Error, "Internal error: literals cannot appear in patterns, not yet..."];

// Desugar list
{#E}SendMatchFreeTerm[%freeTerm⟨ #list ⟩, #term, ok¹.#[ok¹]] 
→
{#E}SendMatchFreeTerm[DesugarList[#list], #term, ok¹.#[ok¹]];

// Metavariable matches all terms. Just record name in the environment.
-[Data[#term]]:
{#E}SendMatchFreeTerm[%freeTerm⟨ #METAVAR #freeArguments? ⟩, #term, ok¹.#[ok¹]] 
→
%n⟨¶/* «Text-CommentToken[#METAVAR]»=«Text-CommentToken[$[Show, #term]]» */«{#E}SendMatchMeta[MetaKey[#METAVAR], #term, ok¹.#[ok¹]]»⟩;

SendMatchMeta[$String, Text, ok¹::OK_SORT.Text] :: Text;

-[Data[#key]]:
{#E; "$binders": TEXTS[#binders]}
SendMatchMeta[#key, #term, ok¹.#[ok¹]]
→
{#E; #key: META[#term, #binders]}#[OK];

SendMatchArgumentsOpt[$List[Crsx_arguments_sort], Text, ok¹::OK_SORT.Text] :: Text;

{#E}SendMatchArgumentsOpt[%arguments?⟨            ⟩, #term, ok¹.#[ok¹]] → {#E}#[OK];
{#E}SendMatchArgumentsOpt[%arguments?⟨ []         ⟩, #term, ok¹.#[ok¹]] → {#E}#[OK];
{#E}SendMatchArgumentsOpt[%arguments?⟨ [ #terms ] ⟩, #term, ok¹.#[ok¹]] → {#E}SendMatchSubTerms[OK, DesugarTerms[#terms], #term, 0, ok¹.#[ok¹]];

SendMatchSubTerms[OK_SORT, $List[Crsx_terms_S1_sort], Text, $Numeric, ok¹::OK_SORT.Text] :: Text;

{#E}SendMatchSubTerms[OK, %terms_S1*⟨                    ⟩, #parent, #subpos, ok¹.#[ok¹]] → {#E}#[OK];

{#E}SendMatchSubTerms[OK, %terms_S1*⟨ , #term #terms_S1* ⟩, #parent, #subpos, ok¹.#[ok¹]] 
→ 
{#E}SendMatchSubTerm[#term, #parent, #subpos, ok¹.SendMatchSubTerms[ok¹, #terms_S1*, #parent, NumberPlus[#subpos, 1], ok¹.#[ok¹]]];

SendMatchSubTerm[Crsx_term_sort, Text, $Numeric, ok¹::OK_SORT.Text] :: Text;

-[Fresh[sub::Text]]:
{#E}SendMatchSubTerm[#sub, #parent, #subpos, ok¹.#[ok¹]]
→
%n⟨¶Term «sub» = «#parent».sub(«NumberToText[#subpos]»).ref();«{#E}SendMatchTerm[#sub, sub, #subpos, ok¹.#[ok¹]]»⟩;

SendMatchNextBinder[Crsx_nextBinder_sort, Text /* Current term */, $Numeric, $Numeric, ok¹::OK_SORT.Text] :: Text;

{#E}SendMatchNextBinder[%nextBinder⟨ . #freeTerm ⟩, #term, #termpos, #binderpos, ok¹.#[ok¹]] 
→ 
{#E}SendMatchFreeTerm[#freeTerm, #term, ok¹.#[ok¹]];

{#E}SendMatchNextBinder[%nextBinder⟨ #binder #nextBinder ⟩, #term, #termpos, #binderpos, ok¹.#[ok¹]] 
→ 
{#E}SendMatchNextBinder[#nextBinder, #term, #termpos, NumberPlus[#binderpos,1], ok¹.#[ok¹]];

// --- Dispatch case contraction.

SendContraction[OK_SORT, Crsx_freeTerm_sort] :: Text;

{#E}SendContraction[OK, #freeTerm] 
→
%n⟨«Text-Comment["Contract"]»«{#E}SendFreeTerm[#freeTerm]»⟩;

// --- send utilities

SendTail[StringEntry] :: Text;

SendTail[YES] → %n⟨¶return true;⟩; 
SendTail[NO]  → %n⟨⟩;

SendTail2[STRING_ENTRY] :: Text;

SendTail2[YES]  → %n⟪¶return ⟫;
SendTail2[NO]   → %n⟪¶⟫;

CallFunction[OK_SORT, STRING_ENTRY, Crsx_constructor_sort, $List[Text]] :: Text;

{#E; "$sink":TEXT[#sink]}CallFunction[OK, #tail, #symbol, #vars] 
→  
%n⟪«SendTail2[#tail]»«ToJavaId[#symbol]»(«#sink», 1, depth + 1«{#E}CallFunctionArgs[#vars]»);⟫;

CallFunctionArgs[$List[Text]] :: Text;

{#E}CallFunctionArgs[()]            → %n⟨⟩;
{#E}CallFunctionArgs[(#arg; #args)] → %n⟪, «#arg»«{#E}CallFunctionArgs[#args]»⟫;

// --- SET mode
// 
// Generate code evaluating each arguments and assigning result to variables

SetFreeTerms[Crsx_freeTerms_sort, ok¹::OK_SORT vars::$List[Text].Text] :: Text;

{#E}SetFreeTerms[%freeTerms⟨ #freeTerm #freeTerms_S1* ⟩, ok¹ vars.#[ok¹, vars]] 
→ 
{#E}SetFreeTerm[#freeTerm, ok¹ var.SetFreeTerms_S1_ZOM[#freeTerms_S1*, ok¹ vars.#[ok¹, (var; vars)]]];

SetFreeTerms_S1_ZOM[$List[Crsx_freeTerms_S1_sort], ok¹::OK_SORT vars::$List[Text].Text] :: Text;
 
{#E}SetFreeTerms_S1_ZOM[%freeTerms_S1*⟨ ⟩, ok¹ var.#[ok¹, var]] → {#E}#[OK, ()]; 

{#E}SetFreeTerms_S1_ZOM[%freeTerms_S1*⟨ , #freeTerm #freeTerms_S1* ⟩, ok¹ var.#[ok¹, var]] 
→ 
{#E}SetFreeTerm[#freeTerm, ok¹ var.SetFreeTerms_S1_ZOM[#freeTerms_S1*, ok¹ vars.#[ok¹, (var; vars)]]];

SetFreeTerm[Crsx_freeTerm_sort, ok¹::OK_SORT var::Text.Text] :: Text;

// Construction
{#E}SetFreeTerm[%freeTerm⟨ #constructor #arguments? ⟩, ok¹ var.#[ok¹, var]] 
→ 
{#E}SetBuffer[%freeTerm⟨ #constructor #arguments? ⟩, ok¹ var.#[ok¹, var]];

// Construction one argument     
{#E}SetFreeTerm[%freeTerm⟨ #constructor #term ⟩, ok¹ var.#[ok¹, var]] 
→
$[Error, "Invalid CRSX core term: construction with one argument."];

// Literals can be directly created 
-[Fresh[literal::Text]]:
{#E;"$sink":TEXT[#sink]}
SetFreeTerm[%freeTerm⟨ #literal ⟩, ok¹ var.#[ok¹, var]]
→
%n⟪¶Term «literal» = makeStringLiteral(«#sink».context, «Text-String[#literal]»);« {#E}#[OK, literal] »⟫;

// List     
{#E}SetFreeTerm[%freeTerm⟨ #list ⟩, ok¹ var.#[ok¹, var]] 
→
{#E}SetFreeTerm[DesugarList[#list], ok¹ var.#[ok¹, var]];

// variable
{#E}SetFreeTerm[%freeTerm⟨ #VARIABLE #linear? #functional? #varsort? ⟩, ok¹ var.#[ok¹, var]] 
→
{#E}SetVariable[VarKey[%variable⟨ #VARIABLE ⟩], ok¹ var.#[ok¹, var]];

// struct     
{#E}SetFreeTerm[%freeTerm⟨ #properties ⟩, ok¹ var.#[ok¹, var]]  
→
$[Error, "Named data structure not implemented yet."];

// meta     
{#E}SetFreeTerm[%freeTerm⟨ #METAVAR #freeArguments? ⟩, ok¹ var.#[ok¹, var]]
→
{#E}SetBuffer[%freeTerm⟨ #METAVAR #freeArguments? ⟩, ok¹ var.#[ok¹, var]];

// expression     
{#E}SetFreeTerm[%freeTerm⟨ #expression ⟩, ok¹ var.#[ok¹, var]] 
→
{#E}SetBuffer[%freeTerm⟨ #expression ⟩, ok¹ var.#[ok¹, var]];

SetArgumentsOpt[$List[Crsx_arguments_sort], ok¹::OK_SORT args¹::$List[Text].Text] :: Text;

{#E}SetArgumentsOpt[%arguments?⟨            ⟩, ok¹ args¹.#[ok¹, args¹]] → {#E}#[OK, ()];
{#E}SetArgumentsOpt[%arguments?⟨ [        ] ⟩, ok¹ args¹.#[ok¹, args¹]] → {#E}#[OK, ()];
{#E}SetArgumentsOpt[%arguments?⟨ [ #terms ] ⟩, ok¹ args¹.#[ok¹, args¹]] → {#E}SetTerms[#terms, ok¹ args¹.#[ok¹, args¹]];

SetTerms[Crsx_terms_sort, ok¹::OK_SORT args¹::$List[Text].Text] :: Text;

{#E}SetTerms[%terms⟨ #term #terms_S1* ⟩, ok¹ args¹.#[ok¹, args¹]]           
→
{#E}SetTerm[#term, ok¹ args¹.SetNextTerms[ok¹, args¹, #terms_S1*,  ok¹ args¹.#[ok¹, args¹]]];

SetNextTerms[OK_SORT, $List[Text], Crsx_Terms_S1_sort, ok¹::OK_SORT args¹::$List[Text].Text] :: Text;

{#E}SetNextTerms[OK, #args, %terms_S1*⟨                    ⟩, ok¹ args¹.#[ok¹, args¹]] → {#E}#[OK, #args];

{#E}SetNextTerms[OK, #args, %terms_S1*⟨ , #term #terms_S1* ⟩, ok¹ args¹.#[ok¹, args¹]] 
→ 
{#E}SetTerm[#term, ok¹ args¹.SetNextTerms[ok¹, Concat[#args, args¹], #terms_S1*, ok¹ args¹.#[ok¹, args¹]]];

SetTerm[Crsx_Term_sort, ok¹::OK_SORT args¹::$List[Text].Text] :: Text;

{#E}SetTerm[%term⟨ #freeTerm ⟩, ok¹ args¹.#[ok¹, args¹]] → {#E}SetFreeTerm[#freeTerm, ok¹ var.#[ok¹, (var;)]];

// --- SET var

SetVariable[$String, ok¹::OK_SORT var::Text.Text] :: Text;

-[Data[#key]]:
{#E}SetVariable[#key, ok¹ var.#[ok¹, var]] 
→
{#E}SetVariable0[$[{#E}Get, #key], ok¹ var.#[ok¹, var]];

SetVariable0[STRING_ENTRY, ok¹::OK_SORT var::Text.Text] :: Text;

-[Fresh[use::Text]]:
{#E; "$sink":TEXT[#sink]}
SetVariable0[TEXT[#var], ok¹ var.#[ok¹, var]] 
→
%n⟨¶VariableUse «use» = «#sink».context().makeVariableUse(«#var»);«{#E}#[OK, use]»⟩; 

// --- SET through buffering

SetBuffer[Crsx_freeTerm_sort, ok¹::OK_SORT var::Text.Text] :: Text;

-[Fresh[buf::Text, term::Text]]
:
{#E; "$sink":TEXT[#sink]}
SetBuffer[#freeTerm, ok¹ var.#[ok¹, var]]
→
%n⟪
Term «term»;
{⟦
BufferSink «buf» = «#sink».context().makeBuffer();« {#E; "$sink":TEXT[buf]}SendFreeTerm[#freeTerm] »
«term» = «buf».term();⟧
}«{#E; "$sink":TEXT[#sink]}#[OK, term]»⟫; // Repeat $sink because of interpreter bug.


//
// ------ initModule
//

InitModule[$List[Crsx_declarations_S1_sort]] :: Text;


InitModule[#declarations] 
→
%n⟨public static void init(Context context)
{⟦«Registers[#declarations]»⟧
}⟩;


Registers[$List[Crsx_declarations_S1_sort]] :: Text;

Registers[%declarations_S1*⟨                                  ⟩] → %n⟨⟩;
Registers[%declarations_S1*⟨ ;                                ⟩] → %n⟨⟩;

Registers[%declarations_S1*⟨ ; #declaration #declarations_S1* ⟩]
→
%n⟨«Register[#declaration]»«Registers[#declarations_S1*]»⟩;

// --- declarations

// module
Register[%declaration⟨ module #STRING { #declarations } ⟩] 
→
Registers[#declarations];

// rule
Register[%declaration⟨ #option? #pattern → #contractum ⟩] 
→
%n⟨⟩;

// data sort
Register[%declaration⟨ #sortparams? #sortset #sortname ::= ( #forms_S1* )  ⟩]
→
RegisterDataSort[#sortset, #sortname, #forms_S1*];

// function sort
Register[%declaration⟨ #sortparams? #sortset #constructor #arguments? :: #sortname  ⟩]
→
%n⟨¶context.register(«Descriptor[#constructor]»);⟩; 

// Nested declarations  
Register[%declaration⟨ #constructor                     ⟩] → %n⟨⟩;
Register[%declaration⟨ #constructor [(               )] ⟩] → %n⟨⟩;
Register[%declaration⟨ #constructor [( #declarations )] ⟩] → Registers[#declarations];

RegisterDataSort[Crsx_sortset_sort, Crsx_sortname_sort, Crsx_sortname_sort, $List[Crsx_forms_S1_sort]] :: Text;

RegisterDataSort[#sortset, #sortname, #forms]
→
Text-Concat[Map[form.RegisterDataForm[form], #forms]];

RegisterDataForm[Crsx_forms_S1_sort] :: Text;

RegisterDataForm[%forms_S1⟨ #constructor #arguments? ; ⟩] 
→
%n⟨¶context.register(«Descriptor[#constructor]»);⟩;

// Some helpers

//
// Print the Java meta variable id
MetaVar[$String] :: Text;
{#E}MetaVar[#] → {#E}MetaVar0[MetaKey[#]];

MetaVar0[$String] :: Text;
-[Data[#]]: {#E}MetaVar0[#] → UnMETA[$[{#E}Get, #]];

//
// Gets property name for given meta-application
MetaKey[$String] :: $String;
MetaKey[#] → $[:, "$meta$", #];

//
// Gets property name for dispatched metavariable
MetaDispatchKey[$Numeric] :: $String;
MetaDispatchKey[#position] → $[:, "$dispatch$", $[FormatNumber, #position]];

//
// Gets the dispatched metavar at the given position
DispatchedMetaVar[$Numeric] :: Text;
{#E}DispatchedMetaVar[#position] → {#E}DispatchedMetaVar1[MetaDispatchKey[#position]];

DispatchedMetaVar1[$String] :: Text;
-[Data[#key]]: {#E}DispatchedMetaVar1[#key] → {#E}DispatchedMetaVar2[UnSTRING[$[{#E}Get, #key]]];

DispatchedMetaVar2[$String] :: Text;
-[Data[#key]]: {#E}DispatchedMetaVar2[#key] → UnMETA[$[{#E}Get, #key]];

//
// Gets the binders of the dispatched metavar at the given position
DispatchedMetaVarBinders[$Numeric] :: Text;
{#E}DispatchedMetaVarBinders[#position] → {#E}DispatchedMetaVarBinders1[MetaDispatchKey[#position]];

DispatchedMetaVarBinders1[$String] :: Text;
-[Data[#key]]: {#E}DispatchedMetaVarBinders1[#key] → {#E}DispatchedMetaVarBinders2[UnSTRING[$[{#E}Get, #key]]];

DispatchedMetaVarBinder2[$String] :: Text;
-[Data[#key]]: {#E}DispatchedMetaVarBinders2[#key] → UnMETABinders[$[{#E}Get, #key]];

//
// Gets property name for given binder
BinderKey[Crsx_binder_sort] :: $String;
BinderKey[%binder⟨ #variable ⟩] → VarKey[#variable];

//
// Gets property name for given variable
VarKey[Crsx_variable_sort] :: $String;
VarKey[%variable⟨ #VARIABLE #linear? #functional? #varsort? ⟩] → $[:, "$var$", #VARIABLE];

//
// Print construction descriptor name
Descriptor[Crsx_constructor_sort] :: Text;
Descriptor[%constructor⟨ #qualifier #CONSTRUCTOR ⟩] → %n⟨«Qualifier[#qualifier]»«ToJavaIdString[#CONSTRUCTOR]»⟩;
Descriptor[%constructor⟨ :                       ⟩] → %n⟨Colon⟩;

// Print construction descriptor qualifier name
Qualifier[Crsx_qualifier_sort] :: Text;
Qualifier[%qualifier⟨ #CONSTRUCTOR . ⟩] → %n⟨†«UpCaseFirst[#CONSTRUCTOR]».⟩;
Qualifier[%qualifier⟨                ⟩] → %n⟨⟩;

//
// Print quoted constructor
QuotedConstructor[Crsx_constructor_sort] :: Text;
QuotedConstructor[%constructor⟨ #CONSTRUCTOR ⟩] → Text-QuoteString[#CONSTRUCTOR];
QuotedConstructor[%constructor⟨ : ⟩]            → %n⟨":"⟩;

// Print package declaration
PackageDeclaration :: Text;
PackageDeclaration → PackageDeclaration2[$[Get, "javapackage", ""]];

PackageDeclaration2[$String] :: Text;
PackageDeclaration2[#name] 
→
$[If, $[Equal, $[Trim, #name], ""], %n⟨⟩, %n⟨package †«#name»;⟩];

// Print class name
ClassName[$String] :: $String;
ClassName[#Name] → UpCaseFirst[AfterLast[BeforeLast[#Name, "."], "/"]]; 

// Convert constructor to legal Java ID
ToJavaId[Crsx_constructor_sort] :: Text;
ToJavaId[%constructor⟨ #CONSTRUCTOR ⟩] → Text-Mangle[UpCaseFirst[#CONSTRUCTOR]]; 
ToJavaId[%constructor⟨ : ⟩]            → %n⟨_M_Colon⟩;

// Convert constructor to legal Java ID
ToJavaIdString[$String] :: Text;
ToJavaIdString[#name] → Text-Mangle[#name]; 

)]