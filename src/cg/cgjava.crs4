// Copyright (c) 2`018 IBM Corporation.
/*
 * TransScript Java 8 backend code generator
 */

import Core::Core
import Std::Core
import Std::String
import Std::Num
import Std::Text
import Std::List
import Std::Pair
import Std::Map
import Text::Text4
import Std::Language
import System

// ===== API

/*
 * Generates Java code from Core TransScript
 * @param System The TransScript system
 */
func TransScriptToJava(System) -> Text
rule TransScriptToJava(System(#url, #modules))
→ JavaUnits(#url, MapValues(#modules))

// --- Generate code.
/*
 Each Crsx module corresponds to a single Java class.

 Each rule declaration corresponds to a single Java function.
*/

func JavaUnits(String, List<Module>) -> Text
rule JavaUnits(#url, #modules)
  → text⟦
/** Generated File */
⟨PackageDeclaration⟩

import java.util.function.Function;

import org.transscript.runtime.Context;
import org.transscript.runtime.v2.Term;
import org.transscript.runtime.v2.Variable;
import org.transscript.runtime.v2.VariableUse;
import org.transscript.runtime.v2.LazyTerm;
import org.transscript.runtime.v2.StringTerm;
import org.transscript.runtime.v2.DoubleTerm;
import org.transscript.runtime.v2.MapTerm;
import static org.transscript.runtime.v2.Term.force;
import static org.transscript.runtime.v2.Term.subst;
import static org.transscript.runtime.v2.Functions.*;
import static org.transscript.runtime.v2.StringTerm.newLazyStringTerm;
import static org.transscript.runtime.v2.StringTerm.newStringTerm;
import static org.transscript.runtime.v2.DoubleTerm.newLazyDoubleTerm;
import static org.transscript.runtime.v2.DoubleTerm.newDoubleTerm;

⟨TextFold(Map([x] -> JavaUnit(#url, x), #modules), text⟦⟧)⟩
⟧

/* Generate class for the given module */
func JavaUnit(String, eager Module) -> Text
rule JavaUnit(#mainurl, Module(#url, Loaded(LoadedContent(#imports, #rules, #datasorts, #funcsorts))))
→ text⟦
⟨TextFold(Map([x] -> JavaImport(x), #imports), text⟦⟧)⟩

@SuppressWarnings("unused")
⟨JavaClassVisibility(#mainurl, #url)⟩ class †⟨ClassName(#url)⟩ {

  /* Typed enumerations */
  ⟨TextFold( Map([x] ->EnumToClass(x), MapValues(#datasorts)), text⟦⟧)⟩
  ⟨TextFold( Map([x] ->JavaMethod(x, text⟦†⟨ClassName(#url)⟩⟧, #rules, #datasorts, #funcsorts), MapKeys(#funcsorts)), text⟦⟧)⟩
  ⟨InitModule(#datasorts, #funcsorts, #imports)⟩
}⟧

func JavaImport(String) -> Text
rule JavaImport(#name)
→ text⟦
import static ⟨PathToImport(#name)⟩.*;⟧

func JavaClassVisibility(String, String) -> Text
rule JavaClassVisibility(#mainurl, #url)
→ If(Equal(#mainurl, #url), text⟦public⟧, text⟦static⟧)

//--- Translate enumerations

/** Generate enumeration descriptors */
func EnumToDataDesc(Core_cdecl_sort) -> Text
rule EnumToDataDesc(cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧)
→ TextFold(Map([x] -> EnumFormToDesc(#CONSTRUCTOR, x), #cform*), text⟦⟧)

func EnumFormToDesc(String, Core_cform_sort) -> Text
rule EnumFormToDesc(#sortname, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
→ text⟦
final public static ConstructionDescriptor ⟨Descriptor(#CONSTRUCTOR)⟩ = makeData(⟨Text-QuoteEscape(#CONSTRUCTOR)⟩, ⟨NumberToText(MaybeSortsCount(#csorts?))⟩, ⟨EnumToClassRef(#sortname, #CONSTRUCTOR)⟩);⟧

func EnumToClassRef(String, String) -> Text
rule EnumToClassRef(#sortname, #formname) → text⟦⟨ToJavaClassName(#sortname)⟩.⟨ToJavaClassName(#formname)⟩.class⟧

/* Generate interfaces corresponding to the enum type */
func EnumToClass(Core_cdecl_sort) -> Text
rule EnumToClass(cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧)
→ text⟦

⟨TextFold(Map([x] -> FormToMethodNew(#CONSTRUCTOR, #csortvars?, x), #cform*), text⟦⟧)⟩

static public ⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ newLazy⟨ToJavaClassName(#CONSTRUCTOR)⟩(Function<Context, ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩> function)
{
  return new Lazy⟨ToJavaClassName(#CONSTRUCTOR)⟩(function);
}

public interface ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ extends Term
{
  ⟨TextFold(Map([x] -> FormToMethodAs(#CONSTRUCTOR, #csortvars?, x), #cform*), text⟦⟧)⟩
}

⟨TextFold(Map([x] -> FormToInterfaceValue(#CONSTRUCTOR, #csortvars?, x), #cform*), text⟦⟧)⟩
⟨TextFold(Map([x] -> FormToImplValue(#CONSTRUCTOR, #csortvars?, x), #cform*), text⟦⟧)⟩

static class Lazy⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ extends LazyTerm<⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩>implements ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩
{

  protected Lazy⟨ToJavaClassName(#CONSTRUCTOR)⟩(⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ value)
	{
		super(value);
	}

  public Lazy⟨ToJavaClassName(#CONSTRUCTOR)⟩(Function<Context, ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩> function)
	{
		super(function);
	}

  ⟨TextFold(Map([x] -> FormToMethodMemoAs(#CONSTRUCTOR, #csortvars?, x), #cform*), text⟦⟧)⟩

  @Override
	public ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ copy(Context c)
	{
		return new Lazy⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩(value);
	}

}⟧

/* Generate a 'new' static method for each enum value */

// TODO: optimize constant value.
func FormToMethodNew(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text
  rule FormToMethodNew(#constructor, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
  → text⟦
    static public ⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ ⟨ToJavaClassName(#constructor)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ ⟨ToJavaMethodName(#CONSTRUCTOR)⟩ (Context context⟨MaybeSortsToFormalParams(#csorts?, text⟦, ⟧)⟩)
    {
      return new ⟨ToJavaClassName(#CONSTRUCTOR)⟩Impl⟨SortParamToTypeParam(#csortvars?, FALSE)⟩(⟨MaybeSortsToArgs(#csorts?)⟩);
    }⟧

  rule FormToMethodNew(#constructor, #csortvars?, cform⟦ allows-variable ⟧)
  → text⟦
    static ⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ ⟨ToJavaClassName(#constructor)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ ⟨ToJavaMethodName(ConcatString("newVar", #constructor))⟩ (Variable var)
    {
      return new Var⟨ToJavaClassName(#constructor)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩(var);
    }⟧

// --- Generate a 'as' method for each enum value

func FormToMethodAs(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text
  rule FormToMethodAs(#enumname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
  → text⟦
    default ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ ⟨MethodNameAs(#CONSTRUCTOR)⟩(Context context)
    {
      return null;
    }⟧

  rule FormToMethodAs(#enumname, #csortvars?, cform⟦ allows-variable ⟧)
  → text⟦⟧

func FormToMethodMemoAs(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text
  rule FormToMethodMemoAs(#enumname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
  → text⟦
   @Override
   final public ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ ⟨MethodNameAs(#CONSTRUCTOR)⟩(Context context)
   {
     return eval(context).⟨MethodNameAs(#CONSTRUCTOR)⟩(context);
   }⟧

 rule FormToMethodMemoAs(#enumname, #csortvars?, cform⟦ allows-variable ⟧)
 → text⟦⟧

func MethodNameAs(String) -> Text
rule MethodNameAs(#formCons) → ToJavaMethodName(ConcatString("as", #formCons))

// --- Generate an interface the enumeration value

func FormToInterfaceValue(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text
  rule FormToInterfaceValue(#enumtype, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
  → text⟦
      public interface ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ extends ⟨ToJavaClassName(#enumtype)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩
      {
        ⟨MaybeSortsToGetValueSig(#csorts?)⟩

        @Override
        default ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ ⟨MethodNameAs(#CONSTRUCTOR)⟩(Context context)
        {
          return this;
        }
      }⟧

  rule FormToInterfaceValue(#enumtype, #csortvars?, cform⟦ allows-variable ⟧)
  → text⟦⟧

// --- Generate an implementation for the enumeration value

func FormToImplValue(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text
  rule FormToImplValue(#typename, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
  → text⟦
      static class ⟨ToJavaClassName(#CONSTRUCTOR)⟩Impl⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ implements ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩
      {
          ⟨MaybeSortsToClassFields(#csorts?)⟩

          ⟨MaybeSortsToDefaultConstructor(#csorts?,  text⟦⟨ToJavaClassName(#CONSTRUCTOR)⟩Impl⟧)⟩

          public ⟨ToJavaClassName(#CONSTRUCTOR)⟩Impl(⟨MaybeSortsToFormalParams(#csorts?, text⟦⟧)⟩)
          {
            ⟨MaybeSortsToInitFields(#csorts?)⟩
          }

          @Override
          public Term copy(Context c)
          {
            return new ⟨ToJavaClassName(#CONSTRUCTOR)⟩Impl⟨SortParamToTypeParam(#csortvars?, FALSE)⟩();
          }

          ⟨MaybeSortsToGetValue(#csorts?)⟩
          ⟨MaybeSortsToGetSubs(#csorts?)⟩
          ⟨MaybeSortsToSetSubs(#csorts?)⟩
          ⟨MaybeSortsToGetBinder(#csorts?)⟩
          ⟨MaybeSortsToSetBinder(#csorts?)⟩

      }⟧

  rule FormToImplValue(#typename, #csortvars?, cform⟦ allows-variable⟧)
  → text⟦
      static class Var⟨ToJavaClassName(#typename)⟩⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ extends VariableUse implements ⟨ToJavaClassName(#typename)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩
      {
        public Var⟨ToJavaClassName(#typename)⟩(Variable var)
        {
          super(var);
        }

        @Override
		    public Term copy(Context c)
	    	{
		      return new Var⟨ToJavaClassName(#typename)⟩(variable);
		    }
    }⟧

//--- Default empty constructor

func MaybeSortsToDefaultConstructor(List<Core_csorts_sort>, Text) -> Text
  rule MaybeSortsToDefaultConstructor(csorts?⟦⟧, #classname)
  → text⟦⟧

  rule MaybeSortsToDefaultConstructor(csorts?⟦ ( ##csort*) ⟧, #classname)
  → text⟦private ⟨#classname⟩() {}⟧

//--- Class fields

func MaybeSortsToClassFields(List<Core_csorts_sort>) -> Text
  rule MaybeSortsToClassFields(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToClassFields(csorts?⟦ ( ##csort* ) ⟧)
  → text⟦
    /* Form arguments */
    ⟨SortsToClassFields(#csort*, 1)⟩⟧

func SortsToClassFields(List<Core_csort_sort>, Numeric) -> Text
  rule SortsToClassFields(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToClassFields(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦⟨SortToClassFields(SortToTypes(#csort), #index, 1)⟩⟨SortsToClassFields(#csort*, Plus(#index, 1))⟩⟧

func SortToClassFields(List<Text>, eager Numeric, eager Numeric) -> Text
  rule SortToClassFields(Cons(#type, Nil), #index, #subindex)
  → text⟦⟨#type⟩ field⟨FieldSuffix(#index)⟩;⟧

  rule SortToClassFields(Cons(#type, #types), #index, #subindex)
  → text⟦
     ⟨#type⟩ var⟨NumberToText(#index)⟩_⟨NumberToText(#subindex)⟩;
     ⟨SortToClassFields(#types, #index, Plus(#subindex, 1))⟩⟧

//--- Class fields initialization

func MaybeSortsToInitFields(List<Core_csorts_sort>) -> Text
  rule MaybeSortsToInitFields(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToInitFields(csorts?⟦ ( ##csort* ) ⟧)
  → SortsToInitFields(#csort*, 1)

func SortsToInitFields(List<Core_csort_sort>, Numeric) -> Text
  rule SortsToInitFields(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToInitFields(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦⟨SortToInitFields(SortToTypes(#csort), #index, 1)⟩⟨SortsToInitFields(#csort*, Plus(#index, 1))⟩⟧

func SortToInitFields(List<Text>, eager Numeric, eager Numeric) -> Text
  rule SortToInitFields(Cons(#type, Nil), #index, #subindex)
  → text⟦this.field⟨FieldSuffix(#index)⟩ = param⟨FieldSuffix(#index)⟩;⟧

  rule SortToInitFields(Cons(#type, #types), #index, #subindex)
  → text⟦this.var⟨NumberToText(#index)⟩_⟨NumberToText(#subindex)⟩ = param⟨NumberToText(#index)⟩_⟨NumberToText(#subindex)⟩; ⟨SortToInitFields(#types, #index, Plus(#subindex, 1))⟩⟧

// --- sub function

func MaybeSortsToGetSubs(List<Core_csorts_sort>) -> Text
  rule MaybeSortsToGetSubs(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToGetSubs(csorts?⟦ ( ##csort* ) ⟧)
  → text⟦
      @Override
      public Term sub(int i) {
       switch (i) {
         ⟨SortsToGetSubs(#csort*, 0)⟩
         default: return null;
        }
      }⟧

func SortsToGetSubs(List<Core_csort_sort>, Numeric) -> Text
  rule SortsToGetSubs(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToGetSubs(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦⟨SortToGetSubs(SortToTypes(#csort), #index, 0)⟩⟨SortsToGetSubs(#csort*, Plus(#index, 1))⟩⟧

func SortToGetSubs(List<Text>, eager Numeric, eager Numeric) -> Text

  rule SortToGetSubs(Cons(#type, Nil), #index, #subindex)
  → text⟦case ⟨NumberToText(#index)⟩: return field⟨FieldSuffix(Plus(#index, 1))⟩;⟧

  rule SortToGetSubs(Cons(#type, #types), #index, #subindex)
  → SortToGetSubs(#types, #index, Plus(#subindex, 1))

// --- SetSub function

func MaybeSortsToSetSubs(List<Core_csorts_sort>) -> Text
  rule MaybeSortsToSetSubs(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToSetSubs(csorts?⟦ ( ##csort* ) ⟧)
  → text⟦
      @Override
      public void setSub(int i, Term sub) {
        switch (i) {
             ⟨SortsToSetSubs(#csort*, 0)⟩
             default: throw new IndexOutOfBoundsException();
           }
         }⟧

func SortsToSetSubs(List<Core_csort_sort>, Numeric) -> Text
  rule SortsToSetSubs(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToSetSubs(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦⟨SortToSetSubs(SortToTypes(#csort), #index, 0)⟩⟨SortsToSetSubs(#csort*, Plus(#index, 1))⟩⟧

func SortToSetSubs(List<Text>, eager Numeric, eager Numeric) -> Text

  rule SortToSetSubs(Cons(#type, Nil), #index, #subindex)
  → text⟦
      case ⟨NumberToText(#index)⟩:
        field⟨FieldSuffix(Plus(#index, 1))⟩ = (⟨#type⟩) sub;
        break;⟧

  rule SortToSetSubs(Cons(#type, #types), #index, #subindex)
  → SortToSetSubs(#types, #index, Plus(#subindex, 1))

// --- binder function

func MaybeSortsToGetBinder(List<Core_csorts_sort>) -> Text
  rule MaybeSortsToGetBinder(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToGetBinder(csorts?⟦ ( ##csort* ) ⟧)
  → If(HasBinders(#csort*),
      text⟦
        @Override
        public Variable binder(int i, int j) {
          switch (i) {
            ⟨SortsToGetBinder(#csort*, 0)⟩
            default: return null;
          }
        }⟧,
      text⟦⟧)

func SortsToGetBinder(List<Core_csort_sort>, Numeric) -> Text
  rule SortsToGetBinder(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToGetBinder(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦
      ⟨If(HasBindersSort(#csort),
        text⟦
          case ⟨NumberToText(#index)⟩: {
            switch (j) {
              ⟨SortToGetBinder(SortToTypes(#csort), #index, 0)⟩
              default: return null;
            }
          }⟧,
        text⟦⟧)⟩
      ⟨SortsToGetBinder(#csort*, Plus(#index, 1))⟩⟧

func SortToGetBinder(List<Text>, eager Numeric, eager Numeric) -> Text

  rule SortToGetBinder(Cons(#type, Nil), #index, #subindex)
  → text⟦⟧

  rule SortToGetBinder(Cons(#type, #types), #index, #subindex)
  → text⟦
      case ⟨NumberToText(#subindex)⟩: return var⟨NumberToText(Plus(#index, 1))⟩_⟨NumberToText(Plus(#subindex, 1))⟩;
      ⟨SortToGetBinder(#types, #index, Plus(#subindex, 1))⟩⟧

// --- setBinder function

func MaybeSortsToSetBinder(List<Core_csorts_sort>) -> Text
  rule MaybeSortsToSetBinder(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToSetBinder(csorts?⟦ ( ##csort* ) ⟧)
  → If(HasBinders(#csort*),
      text⟦
        @Override
        public void setBinder(int i, int j, Variable var) {
         switch (i) {
           ⟨SortsToSetBinder(#csort*, 0)⟩
           default: throw new IndexOutOfBoundsException();
          }
        }⟧,
      text⟦⟧)

func SortsToSetBinder(List<Core_csort_sort>, Numeric) -> Text
  rule SortsToSetBinder(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToSetBinder(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦
      ⟨If(HasBindersSort(#csort),
        text⟦
          case ⟨NumberToText(#index)⟩: {
            switch (j) {
              ⟨SortToSetBinder(SortToTypes(#csort), #index, 0)⟩
              default: throw new IndexOutOfBoundsException();
            }
            break;
          }⟧,
        text⟦⟧)⟩
      ⟨SortsToSetBinder(#csort*, Plus(#index, 1))⟩⟧

func SortToSetBinder(List<Text>, eager Numeric, eager Numeric) -> Text

  rule SortToSetBinder(Cons(#type, Nil), #index, #subindex)
  → text⟦⟧

  rule SortToSetBinder(Cons(#type, #types), #index, #subindex)
  → text⟦
      case ⟨NumberToText(#subindex)⟩:
        var⟨NumberToText(Plus(#index, 1))⟩_⟨NumberToText(Plus(#subindex, 1))⟩ = var;
        break;
      ⟨SortToSetBinder(#types, #index, Plus(#subindex, 1))⟩⟧


//--- Sort to formal parameters

func MaybeSortsToFormalParams(List<Core_csorts_sort>, Text) -> Text
  rule MaybeSortsToFormalParams(csorts?⟦⟧, #sep)
  → text⟦⟧

  rule MaybeSortsToFormalParams(csorts?⟦ ( ##csort*) ⟧, #sep)
  → SortsToFormalParams(#csort*, 1, #sep)

func SortsToFormalParams(List<Core_csort_sort>, Numeric, Text) -> Text
  rule SortsToFormalParams(csort*⟦⟧, #index, #sep)
  → text⟦⟧

  rule SortsToFormalParams(csort*⟦ ##csort ##csort* ⟧, #index, #sep)
  → text⟦⟨#sep⟩⟨SortToFormalParams(SortToTypes(#csort), #index, 1)⟩⟨SortsToFormalParams(#csort*, Plus(#index, 1), text⟦, ⟧)⟩⟧

func SortToFormalParams(List<Text>, Numeric, Numeric) -> Text
  rule SortToFormalParams(Cons(#type, Nil), #index, #subindex)
  → text⟦⟨#type⟩ param⟨FieldSuffix(#index)⟩⟧

  rule SortToFormalParams(Cons(#type, #types), #index, #subindex)
  → text⟦⟨#type⟩ param⟨NumberToText(#index)⟩_⟨NumberToText(#subindex)⟩, ⟨SortToFormalParams(#types, #index, Plus(#subindex, 1))⟩⟧

//--- Sort to function call arguments

func MaybeSortsToArgs(List<Core_csorts_sort>) -> Text
  rule MaybeSortsToArgs(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToArgs(csorts?⟦ ( ##csort*) ⟧)
  → SortsToArgs(#csort*, 1, text⟦⟧)

func SortsToArgs(List<Core_csort_sort>, Numeric, Text) -> Text
  rule SortsToArgs(csort*⟦⟧, #index, #sep)
  → text⟦⟧

  rule SortsToArgs(csort*⟦ ##csort ##csort* ⟧, #index, #sep)
  → text⟦⟨#sep⟩⟨SortToArgs(SortToTypes(#csort), #index, 1)⟩⟨SortsToArgs(#csort*, Plus(#index, 1), text⟦, ⟧)⟩⟧

func SortToArgs(List<Text>, Numeric, Numeric) -> Text
  rule SortToArgs(Cons(#type, Nil), #index, #subindex)
  → text⟦param⟨FieldSuffix(#index)⟩⟧

  rule SortToArgs(Cons(#type, #types), #index, #subindex)
  → text⟦param⟨NumberToText(#index)⟩_⟨NumberToText(#subindex)⟩, ⟨SortToArgs(#types, #index, Plus(#subindex, 1))⟩⟧

//--- Get value method signature

func MaybeSortsToGetValueSig(List<Core_csorts_sort>) -> Text
  rule MaybeSortsToGetValueSig(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToGetValueSig(csorts?⟦ ( ##csort* ) ⟧)
  → SortsToGetValueSig(#csort*, 1)

func SortsToGetValueSig(List<Core_csort_sort>, eager Numeric) -> Text
  rule SortsToGetValueSig(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToGetValueSig(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦⟨SortToGetValueSig(SortToTypes(#csort), #index, 1)⟩⟨SortsToGetValueSig(#csort*, Plus(#index, 1))⟩⟧

func SortToGetValueSig(List<Text>, eager Numeric, eager Numeric) -> Text
  rule SortToGetValueSig(Cons(#type, Nil), #index, #subindex)
  → text⟦public ⟨#type⟩ getField⟨FieldSuffix(#index)⟩();⟧

  rule SortToGetValueSig(Cons(#type, #types), #index, #subindex)
  → text⟦public ⟨#type⟩ getVar⟨NumberToText(#index)⟩_⟨NumberToText(#subindex)⟩();
         ⟨SortToGetValueSig(#types, #index, Plus(#subindex, 1))⟩⟧

//--- Get value method implementation

func MaybeSortsToGetValue(List<Core_csorts_sort>) -> Text
  rule MaybeSortsToGetValue(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToGetValue(csorts?⟦ ( ##csort* ) ⟧)
  → SortsToGetValue(#csort*, 1)

func SortsToGetValue(List<Core_csorts_sort>, eager Numeric) -> Text
  rule SortsToGetValue(csort*⟦ ⟧, #index)
  → text⟦⟧

  rule SortsToGetValue(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦⟨SortToGetValue(SortToTypes(#csort), #index, 1)⟩⟨SortsToGetValue(#csort*, Plus(#index, 1))⟩⟧

func SortToGetValue(List<Text>, eager Numeric, eager Numeric) -> Text
  rule SortToGetValue(Cons(#type, Nil), #index, #subindex)
  → text⟦@Override
         public ⟨#type⟩ getField⟨FieldSuffix(#index)⟩() {
            return field⟨FieldSuffix(#index)⟩;
         }⟧

  rule SortToGetValue(Cons(#type, #types), #index, #subindex)
  → text⟦@Override
         public ⟨#type⟩ getVar⟨NumberToText(#index)⟩_⟨NumberToText(#subindex)⟩() {
           return var⟨NumberToText(#index)⟩_⟨NumberToText(#subindex)⟩;
        }
        ⟨SortToGetValue(#types, #index, Plus(#subindex, 1))⟩⟧

//--- Helpers

func FieldSuffix(Numeric) -> Text
  rule FieldSuffix(#index)
  → NumberToText(#index)

func MaybeSortsCount(List<Core_csorts_sort>) -> Numeric
  rule MaybeSortsCount(csorts?⟦⟧)             → 0
  rule MaybeSortsCount(csorts?⟦ (##csort*) ⟧) → ListLength(#csort*)

/** whether list of sorts has at least one binders */
func HasBinders(List<Core_csort_sort>) -> Boolean
  rule HasBinders(csort*⟦⟧) → FALSE
  rule HasBinders(csort*⟦ ##csort ##csort* ⟧)
  → Or(HasBindersSort(#csort), HasBinders(#csort*))

func HasBindersSort(Core_csort_sort) -> Boolean
  rule HasBindersSort(csort⟦ ##CONSTRUCTOR ##csorts? ⟧) → FALSE
  rule HasBindersSort(csort⟦ ##VARIABLE ⟧)              → FALSE
  rule HasBindersSort(csort⟦ [ ##csort ] ##csort2 ⟧)    → TRUE
  rule HasBindersSort(csort⟦ ( ##csort ) ##csort2 ⟧)    → HasBindersSort(#csort2)
  rule HasBindersSort(csort⟦ { ##cmapsort } ⟧)          → FALSE
  rule HasBindersSort(csort⟦ data ##csort ⟧)            → HasBindersSort(#csort)

//--- Rename builtin types to avoid conflict with Java types

func FixupPrimitiveType(String) -> String
rule FixupPrimitiveType(#typename)
→ If (StringEqual(#typename, "String"), "StringTerm",
  If (StringEqual(#typename, "Numeric"), "DoubleTerm",
       #typename))

//--- Find form in sort.

func FindForm(Option<Option<Core_cdecl_sort>>, String) -> Option<Core_cform_sort>
  rule FindForm(NONE, #formname)
  → NONE

  rule FindForm(SOME(NONE), #formname)
  → NONE

  rule FindForm(SOME(SOME(cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧)), #formname)
  → PickFirst(#cform*, [x] -> MatchConsForm(x, #formname))

func MatchConsForm(Core_cform_sort, String) -> Boolean
  rule MatchConsForm(cform⟦ ##CONSTRUCTOR ##csorts? ⟧, #formname)
  → Equal(#CONSTRUCTOR, #formname)

  rule MatchConsForm(#, #formname)
  → FALSE

//---- Sort tranlation

func SortParamToTypeParam(List<Core_csortvars_sort>, Boolean /* parameterize or parameterization? */) -> Text
  rule SortParamToTypeParam(csortvars?⟦ ⟧, #parameterize)
  → text⟦⟧

  rule SortParamToTypeParam(csortvars?⟦ ∀ ##variable_TOK+ . ⟧, #parameterize)
  → text⟦<⟨TextFold(Map([x] -> text⟦⟨ToJavaTypeParameter(x)⟩⟨If(#parameterize, text⟦ extends Term⟧, text⟦⟧)⟩⟧, #variable_TOK+), text⟦, ⟧)⟩>⟧

func MaybeSortsToTypeParams(List<Core_csorts_sort>) -> Text
  rule MaybeSortsToTypeParams(csorts?⟦ ⟧)
  → text⟦⟧

  rule MaybeSortsToTypeParams(csorts?⟦ ( ##csort* )⟧)
  → text⟦<⟨TextFold( Flatten(Map([x] -> SortToTypes(x), #csort*)), text⟦, ⟧)⟩>⟧


/** Get sort from annotation */
func MaybeSortAnnoToSort(List<Core_csortanno_sort>) -> Option<Core_sort_sort>
  rule MaybeSortAnnoToSort(csortanno?⟦ ⟧)
  → NONE

 rule MaybeSortAnnoToSort(csortanno?⟦ : ##csort ⟧)
  → #csort

/*
/** Convert sort annotation to equivalent Java type */
func MaybeSortAnnoToType(List<Core_csortanno_sort>) -> Text
  rule MaybeSortAnnoToType(csortanno?⟦ ⟧)
  → text⟦⟧

  rule MaybeSortAnnoToType(csortanno?⟦ : ##csort ⟧)
  → SortToType(#csort)*/

/* Translate Transscript sort to equivalent list of Java types:
 * a list of types corresponding to syntactic variable sorts and a type for the last sort
 */
func SortToTypes(Core_csort_sort) -> List<Text>
rule SortToTypes(#csort) → SortToTypes2(#csort, ())

func SortToTypes2(Core_csort_sort, List<Text> /* formal params */) -> List<Text>

  rule SortToTypes2(csort⟦ ##CONSTRUCTOR ##csorts? ⟧, ())
  → Cons(text⟦⟨ToJavaClassName(FixupPrimitiveType(#CONSTRUCTOR))⟩⟨MaybeSortsToTypeParams(#csorts?)⟩⟧, Nil)

  rule SortToTypes2(csort⟦ ##CONSTRUCTOR ##csorts? ⟧, Cons(#formal, #formals))
  → Cons(text⟦Closure⟨NumberToText(Plus(ListLength(#formals), 1))⟩<⟨
       ToJavaClassName(FixupPrimitiveType(#CONSTRUCTOR))⟩⟨MaybeSortsToTypeParams(#csorts?) /* Return type */⟩, ⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* Formal params */⟩>⟧, Nil)

  rule SortToTypes2(csort⟦ ##VARIABLE ⟧, ())
  → Cons(text⟦⟨ToJavaTypeParameter(#VARIABLE)⟩⟧, Nil)

  rule SortToTypes2(csort⟦ ##VARIABLE ⟧, Cons(#formal, #formals))
  → Cons(text⟦Closure⟨NumberToText(Plus(ListLength(#formals), 1))⟩<⟨#VARIABLE /* Return type */⟩, ⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* Formal params */⟩>⟧, Nil)

  // TODO: typed variable
  rule SortToTypes2(csort⟦ [ ##csort ] ##csort2 ⟧, #formals)
  → Cons(text⟦Variable⟧, SortToTypes2(#csort2, #formals))

  rule SortToTypes2(csort⟦ ( ##csort ) ##csort2 ⟧, #formals)
  → SortToTypes2(#csort2, Concat(#formals, SortToTypes(#csort)))

  // TODO: typed map`
  rule SortToTypes2(csort⟦ { ##cmapsort } ⟧, ())
  → Cons(text⟦MapTerm⟧, Nil)

  rule SortToTypes2(csort⟦ { ##cmapsort } ⟧, Cons(#formal, #formals))
  → Cons(text⟦Closure⟨NumberToText(Plus(ListLength(#formals), 1))⟩<MapTerm, ⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* Formal params */⟩>⟧, Nil)

  rule SortToTypes2(csort⟦ data ##csort ⟧, #formals)
  → SortToTypes2(#csort, #formals)

/* Same as above, expect ignore syntactic variables */
func SortToType(Core_csort_sort) -> Text
rule SortToType(#csort) → Last(SortToTypes(#csort)) // TODO: could optimize

/* Same as above, expect maybe get a sort */
func MaybeSortToType(Option<Core_csort_sort>) -> Text
rule MaybeSortToType(NONE)         → text⟦⟧
rule MaybeSortToType(SOME(#csort)) → Last(SortToTypes(#csort)) // TODO: could optimize

/* Sort qualifier to type */
func SortQualifierToType(Core_csortqualifier_sort) -> Text
rule SortQualifierToType(csortqualifier⟦ ##csort ::⟧)
→ SortToType(#csort)

//------ Function declaration translation
/*
func JavaFuncDesc(String, Core_cdecl_sort) -> Text
rule JavaFuncDesc(#classname, cdecl⟦ ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧)
→ text⟦
  final public static DynamicFunctionDescriptor ⟨Descriptor(#CONSTRUCTOR)⟩ =
    makeFunction(⟨Text-QuoteEscape(#CONSTRUCTOR)⟩, †⟨#classname⟩⟨JavaExtern(#extern_TOK?)⟩.class, "⟨ToJavaId(#CONSTRUCTOR)⟩", ⟨ThunkClass(#csort)⟩, ⟨MaybeSortsToSubIndex(#csorts?)⟩);⟧

func JavaExtern(List<Core_extern_sort>) -> Text
rule JavaExtern(extern_TOK?⟦⟧) → text⟦⟧
// Something is wrong with this rule.
//rule JavaExtern(extern_TOK?⟦ extern ⟧) → text⟦Extern⟧
rule JavaExtern(( #extern )) → text⟦Extern⟧

func ThunkClass(Core_csort_sort) -> Text
rule ThunkClass(csort⟦ ##CONSTRUCTOR ##csorts? ⟧) → text⟦⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨ToJavaClassName(#CONSTRUCTOR)⟩Thunk.class⟧
*/
// --- Generate array of int correponding to sub index in a flat array mixing binders and subs */

func MaybeSortsToSubIndex(List<Core_csorts_sort>) -> Text
  rule MaybeSortsToSubIndex(csorts?⟦⟧)
  → text⟦null⟧

  rule MaybeSortsToSubIndex(csorts?⟦ ( ##csort* ) ⟧)
  → text⟦new int[] { ⟨SortsToSubIndex(#csort*, 0, text⟦⟧)⟩ }⟧

func SortsToSubIndex(List<Core_csort_sort>, Numeric, Text) -> Text
  rule SortsToSubIndex(csort*⟦⟧, #index, #sep)
  → text⟦⟧

  rule SortsToSubIndex(csort*⟦ ##csort ##csort* ⟧, #index, #sep)
  → SortToSubIndex(Plus(Minus(ListLength(SortToTypes(#csort)), 1), #index), #csort*, #sep)

func SortToSubIndex(eager Numeric, List<Core_csort_sort>, Text) -> Text
  rule SortToSubIndex(#subindex, #csort*, #sep)
  → text⟦⟨#sep⟩⟨ NumberToText( #subindex ) ⟩⟨SortsToSubIndex(#csort*, Plus(#subindex, 1), text⟦,⟧)⟩⟧


/* Generate method for function. Start with method signature */
func JavaMethod(String, Text, {String : List<Core_cdecl_sort>},
           { String : Core_cdecl_sort }, { String : Core_cdecl_sort }) -> Text
rule JavaMethod(#constructor, #classname, #rules, #datasorts, #funcsorts)
→ text⟦final public static ⟨
          JavaMethodSig(SetDataSorts(SetFuncSorts(SetClassname(NewEnv, #classname), #funcsorts), #datasorts),
                        UnSOME(MapGet(#funcsorts, #constructor)),
                        MapGet(#rules, #constructor))⟩⟧

func JavaMethodSig(eager {String : JavaEnvEntry}, Core_cdecl_sort, Option<List<Core_cdecl_sort>>) -> Text
rule JavaMethodSig(#env, cdecl⟦ ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧, #rules)
→ text⟦⟨ReturnType(#csortvars?, #csort)⟩⟨ToJavaMethodName(#CONSTRUCTOR)⟩(Context context⟨
      JavaSigMaybeArgs(SetMethodName(SetThunkType(AddThunk(#env, text⟦⟧), ThunkType(#csort)), ToJavaMethodName(#CONSTRUCTOR)), #csorts?, #rules)⟩⟧   // )

// --- Generate return type

func ReturnType(List<Core_csortvars_sort>, Core_csort_sort) -> Text
rule ReturnType(#csortvars?, #csort)
→ text⟦⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ ⟨TextFold(SortToTypes(#csort), text⟦⟧)⟩ ⟧

// --- Generate thunk type

// TODO: maybe consolidate with SortToType
func ThunkType(Core_csort_sort) -> Text

  rule ThunkType(csort⟦ ##CONSTRUCTOR ##csorts? ⟧)
  → text⟦⟨ToJavaClassName(FixupPrimitiveType(#CONSTRUCTOR))⟩⟧

  rule ThunkType(csort⟦ ##VARIABLE ⟧) // polymorphic return type.
  → text⟦Poly⟧

  rule ThunkType(csort⟦ [ ##csort ] ##csort2 ⟧)
  → Error("Internal error: a function cannot return scoped values")

  rule ThunkType(csort⟦ ( ##csort ) ##csort2 ⟧)
  → Error("Internal error: a function cannot return another function")

  // TODO: typed map`
  rule ThunkType(csort⟦ { ##cmapsort } ⟧)
  → text⟦MapTerm⟧

  rule ThunkType(csort⟦ data ##csort ⟧)
  → ThunkType(#csort)

/*
rule ThunkType(#csort)
→ text⟦⟨TextFold(SortToTypes(#csort), text⟦⟧)⟩⟧*/

// --- Generate method signature

func JavaSigMaybeArgs(eager {String : JavaEnvEntry}, List<Core_csorts_sort>, Option<List<Core_cdecl_sort>>) -> Text
  rule JavaSigMaybeArgs(#env, csorts?⟦⟧, #rules)
  → JavaBody(#env, #rules)

  rule JavaSigMaybeArgs(#env, csorts?⟦ ( ##csort* ) ⟧, #rules)
  → JavaSigArgs(#env, #csort*, #rules)

// Generate method signature and record the argument names in the environment, keeping them in order
func JavaSigArgs(eager {String : JavaEnvEntry}, List<Core_csort_sort>, Option<List<Core_cdecl_sort>>) -> Text

  rule JavaSigArgs(#env, csort*⟦ ⟧, #rules)
  → JavaBody(#env, #rules)

  rule JavaSigArgs(#env, csort*⟦ ##csort ##csort* ⟧, #rules)
  → JavaSigArg(#env, #csort, FALSE, SortToTypes(#csort), #csort*, #rules)

func JavaSigArg(eager {String : JavaEnvEntry}, Core_csort_sort, Boolean /* data? */,
                List<Text> /* formal parameters */, List<Core_csort_sort>, Option<List<Core_cdecl_sort>>) -> Text

 // Monomorphic sort
   rule JavaSigArg(#env, csort⟦ ##CONSTRUCTOR ##csorts? ⟧, #data, Cons(#type, Nil), #csort*, #rules)
   → text⟦, ⟨#type⟩ ⟨value⟩⟨
       JavaSigArgs(AddThunk(AddParam(AddMaybeData(#env, #data, value), value, Core_csort_A1(#CONSTRUCTOR, #csorts?)), value), #csort*, #rules)⟩⟧

   // Sort variable
   rule JavaSigArg(#env, csort⟦ ##VARIABLE ⟧, #data, Cons(#type, Nil), #csort*, #rules)
   → text⟦, ⟨#type⟩ ⟨value⟩⟨
       JavaSigArgs(AddThunk(AddParam(AddMaybeData(#env, #data, value), value, Core_csort_A2(#VARIABLE)), value), #csort*, #rules)⟩⟧

   // Syntactic variable sort
   //rule JavaSigArgs(#env, csort⟦ [ ##csort ] ##csort2 ⟧, #data, Cons(#type, #types), #rules)
   rule JavaSigArg(#env, Core_csort_A3(#csort, #csort2), #data, Cons(#type, #types), #csort*, #rules)
   → text⟦, ⟨#type⟩ ⟨var⟩⟨
       JavaSigArg(AddThunk(AddParam(#env, var, #csort), var), #csort2, #data, #types, #csort*, #rules)⟩⟧

   // Formal parameter sort
   //rule JavaSigArgs(#env, csort⟦ ( ##csort ) ##csort2 ⟧, #data, #rules)
   rule JavaSigArg(#env, Core_csort_A4(#csort, #csort2), #data, #types, #csort*, #rules)
   → JavaSigArg(#env, #csort2, #data, #types, #csort*, #rules)

   rule JavaSigArg(#env, csort⟦ { ##cmapsort* } ⟧, #data, Cons(#type, Nil), #csort*, #rules)
   → text⟦, ⟨#type⟩ ⟨map⟩⟨
       JavaSigArgs(AddThunk(AddParam(AddMaybeData(#env, #data, map), map, Core_csort_A5(#cmapsort*)), map), #csort*, #rules)⟩⟧

   rule JavaSigArg(#env, csort⟦ data ##csort ⟧, #data, #types, #csort*, #rules)
   → JavaSigArg(#env, #csort, TRUE, #types, #csort*, #rules)

// --- Generate method body

func JavaBody(eager {String : JavaEnvEntry}, Option<List<Core_cdecl_sort>>) -> Text

  // No rules: it must be an external function (not yet checked but should)
  rule JavaBody(#env, NONE)
  → text⟦) {
        return ⟨GetClassname(#env)⟩Extern.⟨GetMethodName(#env)⟩(context⟨TextFold(GetThunk(#env), text⟦, ⟧)⟩);
      }⟧

  // At least one rule: not external
  rule JavaBody(#env, SOME(#rules))
  → text⟦
    ) {
        if (context.sd ++ < 256) {
          ⟨TextFold(Map([x] -> JavaApplyData(GetSink(#env), x), GetData(#env)), text⟦⟧)⟩
          ⟨TextFold(Map([x] -> JavaBodyRule(#env, x), #rules), text⟦⟧)⟩
        }
        return newLazy⟨GetThunkType(#env)⟩( c -> { return ⟨GetMethodName(#env)⟩(c⟨TextFold(GetThunk(#env), text⟦, ⟧)⟩); } );
      }⟧

// Generate code to normalize arguments marked as 'data'
func JavaApplyData(Text, Text) -> Text
rule JavaApplyData(#sink, #term)
→ text⟦⟨#term⟩.eval(context).release();⟧

// --- Start method body

func JavaBodyRule(eager {String : JavaEnvEntry}, Core_cdecl_sort) -> Text
  rule JavaBodyRule(#env, cdecl⟦ rule ##CONSTRUCTOR → ##cterm2 ⟧)
  → JavaContractum(#env, #cterm2)

  rule JavaBodyRule(#env, cdecl⟦ rule ##CONSTRUCTOR ( ##cterm* ) → ##cterm2 ⟧)
  → JavaPattern(#env, #cterm*, #cterm2)

// --- Pattern matching

func JavaPattern(eager {String : JavaEnvEntry}, List<Core_cterm_sort>, Core_cterm_sort) -> Text

// TODO: case where there is only one rule.
rule JavaPattern(#env, #cterms, #contractum)
→ text⟦⟨label⟩:{⟨JavaCasePattern(SetLabel(#env, label), #cterms, #contractum)⟩
}⟧

// Data sort helper indicating whether the current term is a method parameter, or an argument (local variable).
enum Storage | PARAMETER | ARGUMENT

// Iterate over top-level pattern arguments
func JavaCasePattern(eager {String : JavaEnvEntry}, List<Core_cterm_sort>, Core_cterm_sort) -> Text

rule JavaCasePattern(#env, cterm*⟦ ⟧, #contractum)
→ JavaContractum(#env, #contractum)

rule JavaCasePattern(#env, cterm*⟦ ##cterm ##cterm* ⟧, #contractum)
→ JavaPatternTerm(NextParam(#env), #cterm, CurrentParam(#env), SOME(CurrentParamSort(#env)), PARAMETER, [env] -> JavaCasePattern(env, #cterm*, #contractum))

// --- Term pattern matching

func JavaPatternTerm(eager {String : JavaEnvEntry}, Core_cterm_sort, Text /* Current term */,
                     Option<Core_csort_sort> /* Sort when known */, Storage, [{String : JavaEnvEntry}] -> Text) -> Text

  rule JavaPatternTerm(#env, cterm⟦ ##csortqualifier* ##CONSTRUCTOR ##cterms? ⟧, #term, #csort, #storage, [env]->#(env))
  → text⟦
      ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨ResolveTypeParamCons(#csort)⟩ ⟨value⟩ = force(context, ⟨#term⟩).⟨MethodNameAs(#CONSTRUCTOR)⟩(context);
      if (⟨value⟩ == null) {
        break ⟨GetLabel(#env)⟩;
      }⟨
      JavaPatternMaybeSubs(#env, #cterms?, value, FindForm(Maybe([x] -> LookupDataSortDecl(GetDataSorts(#env), x), #csort), #CONSTRUCTOR), [x] -> #(x))⟩⟧

  // TODO: check literal
  rule JavaPatternTerm(#env, cterm⟦ ##cliteral ⟧, #term, #csort, #storage, [env]->#(env))
  → #(#env)

  // REVISIT: bound variable reordering, ie. (x)(y)#(y, x)
  // For now only accepts patterns of the form (x)...(y)#(x, ... y)
  rule JavaPatternTerm(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #term, #csort, #storage, [env]->#(env))
  → text⟦
      /* ⟨Text-CommentToken(#METAVAR)⟩=⟨Text-CommentToken(Show(#term))⟩ */
      ⟨JavaPatternMaybeMetaArgs(#env, #METAVAR, #csubst?, #term, #csort, [x] -> #(x))⟩⟧

  rule JavaPatternTerm(#env, cterm⟦ ##VARIABLE ⟧, #term, #csort, #storage, [env]->#(env))
  → JavaPatternVariable(MaybeGetVar(#env, #VARIABLE), #env, #VARIABLE, #term, [env]->#(env))

  //rule JavaPatternTerm(#env, cterm⟦ [ ##VARIABLE ##csortanno? ] ##cterm ⟧, #term, PARAMETER, [env]->#(env))
  rule JavaPatternTerm(#env, Core_cterm_A6(#csortanno?, [x] -> #cterm(x)), #term, #csort, PARAMETER, [env]->#(env))
  → JavaPatternTerm(NextParam(AddVar(#env, var, Bound(#term, MaybeSortAnnoToSort(#csortanno?)))), #cterm(var), CurrentParam(#env), CurrentParamSort(#env), PARAMETER, [env]->#(env))

  //rule JavaPatternTerm(#env, cterm⟦ [ ##VARIABLE ##csortanno? ] ##cterm ⟧, #term, ARGUMENT, [env]->#(env))
  rule JavaPatternTerm(#env, Core_cterm_A6(#csortanno?, [x] -> #cterm(x)), #term,  #csort, ARGUMENT, [env]->#(env))
  → text⟦
      Variable ⟨boundvar⟩ = ⟨GetParent(#env)⟩.getVar⟨NumberToText(GetSubIndex(#env))⟩_⟨NumberToText(GetSubBinderIndex(#env))⟩();⟨
      JavaPatternTerm(IncSubBinderIndex(AddVar(#env, var, Bound(boundvar, MaybeSortAnnoToSort(#csortanno?)))), #cterm(var), #term, #csort, ARGUMENT, [env]->#(env))⟩⟧

  //rule JavaPatternTerm(#env, cterm⟦ ( ##VARIABLE ##csortanno? ) ##cterm ⟧, #term, #storage, [env]->#(env))
  rule JavaPatternTerm(#env, Core_cterm_A7(#csortanno?, [x] -> #cterm(x)), #term, #csort, #storage, [env]->#(env))
  → JavaPatternTerm(#env, #cterm(var), #term, #csort, #storage, [env]->#(env))

// Pattern matching on construction arguments.
func JavaPatternMaybeSubs(eager {String : JavaEnvEntry}, List<Core_cterms_sort>, Text, Option<Core_cform_sort>, [{String : JavaEnvEntry}] -> Text) -> Text

  rule JavaPatternMaybeSubs(#env, cterms?⟦⟧, #term, #cform, [env]->#(env))
  → #(#env)

  rule JavaPatternMaybeSubs(#env, cterms?⟦ ( ##cterm* ) ⟧, #term, SOME(cform⟦ ##CONSTRUCTOR ( ##csort* ) ⟧), [env]->#(env))
  → JavaPatternSubs(#env, #cterm*, #term, 1, SOME(#csort*), [env]->#(env))

  rule JavaPatternMaybeSubs(#env, cterms?⟦ ( ##cterm* ) ⟧, #term, NONE, [env]->#(env))
  → JavaPatternSubs(#env, #cterm*, #term, 1, NONE, [env]->#(env))

func JavaPatternSubs(eager {String : JavaEnvEntry}, List<Core_cterm_sort>,
                     Text /* parent term */, Numeric /* Current subindex */, Option<List<Core_csort_sort>>, /* sub sorts, if known */
                     [{String : JavaEnvEntry}] -> Text) -> Text

  rule JavaPatternSubs(#env, cterm*⟦⟧,  #term, #index, #csort*, [env]->#(env))
  → #(#env)

  rule JavaPatternSubs(#env, cterm*⟦ ##cterm ##cterm* ⟧, #term, #index, #csort*, [env]->#(env))
  → text⟦
      ⟨MaybeSortToType(SubSort(#env, #cterm, #csort*))⟩ ⟨sub⟩ = ⟨#term⟩.getField⟨FieldSuffix(#index)⟩();⟨
      JavaPatternTerm(SetSubBinderIndex(SetParent(SetSubIndex(#env, #index), #term), 1),
                  #cterm, sub, SubSort(#env, #cterm, #csort*), ARGUMENT,
                  [x] -> JavaPatternSubs(x, #cterm*, #term, NumberPlus(#index, 1), Maybe([x]->Tail(x), #csort*), [x] -> #(x)))⟩⟧

// --- Variable pattern matching outside of meta

func JavaPatternVariable(Option<VarEntry>, eager {String : JavaEnvEntry}, String /* TODO: Core_cvariable_sort when metaparser is fixed */, Text /* Current term */, [{String : JavaEnvEntry}] -> Text) -> Text

  // First variable occurrence: the term is a variable use.
  rule JavaPatternVariable(NONE, #env, #variable, #term, [env]->#(env))
  → text⟦
      Variable ⟨var⟩ = ⟨#term⟩.variable();⟨#(AddVar(#env, #variable, Free(var, NONE)))⟩⟧

  // Bound variable
  // TODO: update term's parent with evaluated term.
  // TODO: release acquired references.
  rule JavaPatternVariable(SOME(Bound(#javavar)), #env, #variable, #term, [env]->#(env))
  → text⟦
      ⟨#term⟩ = force(⟨GetSink(#env)⟩.context(), ⟨#term⟩);
      if (!isVariableUse(⟨#term⟩) || ⟨#javavar⟩ != ⟨#term⟩.variable()) {
        break ⟨GetLabel(#env)⟩;
      }⟨#(#env)⟩⟧

// --- pattern matching inside meta

// Iterate over meta arguments and find corresponding bound variables, and update environment
func JavaPatternMaybeMetaArgs(eager {String : JavaEnvEntry}, String, List<Core_csubst_sort>, Text /* Current term */, Option<Core_csort_sort>, [{String : JavaEnvEntry}] -> Text) -> Text

  rule JavaPatternMaybeMetaArgs(#env, #metavar, csubst?⟦⟧, #term, #csort, [env]->#(env))
  → #(AddMeta(#env, #metavar, #term, ()))

  // meta substitution
  rule JavaPatternMaybeMetaArgs(#env, #metavar, csubst?⟦ [ ##cterm* ] ⟧, #term, #csort, [env]->#(env))
  → #(AddMeta(#env, #metavar, #term, Map([x] -> JavaFindBoundVar(#env, x), #cterm*)))

func JavaFindBoundVar(eager {String : JavaEnvEntry},Core_cterm_sort) -> Text

  rule JavaFindBoundVar(#env, cterm⟦ ##VARIABLE ⟧)
  → GetVar(#env, #VARIABLE)

// Interpreter does not handle Fallback
//-(Fallback):
//JavaFindBoundVar(#env, #cterm)
//→ $(Error, $(:, "Invalid argument in metavariable: ", $(Show, #cterm)))


/* Extract type parameter from constructor sort */
func ResolveTypeParamCons(Option<Core_csort_sort>) -> Text
  rule ResolveTypeParamCons(NONE)
  → text⟦⟧

  rule ResolveTypeParamCons(SOME(csort⟦ ##CONSTRUCTOR ##csorts? ⟧))
  → MaybeSortsToTypeParams(#csorts?)

  rule ResolveTypeParamCons(SOME(#))
  → text⟦⟧

/* Get sub sort. If sort is not available, try to get it from qualifified term */
func SubSort(eager {String : JavaEnvEntry}, Core_cterm_sort, Option<List<Core_csort_sort>>) -> Option<Core_csort_sort>
  rule SubSort(#env, #cterm, NONE)
  → SubSortFromTerm(#env, #cterm)

  rule SubSort(#env, #cterm, SOME(csort*⟦ ##csort ##csort* ⟧))
  → SOME(#csort)

func SubSortFromTerm(eager {String : JavaEnvEntry}, Core_cterm_sort) -> Text

  // TODO: support for multiple sort qualifiers
  rule SubSortFromTerm(#env, cterm⟦ ##csort :: ##csortqualifier* ##CONSTRUCTOR ##cterms? ⟧)
  → SOME(#csort)

  rule SubSortFromTerm(#env, cterm⟦  ##CONSTRUCTOR ##cterms? ⟧)
  → NONE

  rule SubSortFromTerm(#env, cterm⟦ ##STRING ⟧)
  → SOME(csort⟦ String ⟧)

  rule SubSortFromTerm(#env, cterm⟦ ##NUMBER ⟧)
  → SOME(csort⟦ Numeric⟧)

  rule SubSortFromTerm(#env, cterm⟦ ##VARIABLE ⟧)
  → SubSortFromVar(MaybeGetVar(#env, #VARIABLE), #VARIABLE)

  rule SubSortFromTerm(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧)
  → MaybeSortAnnoToSort(#csortanno?)

  // TODO: maybe error?
  rule SubSortFromTerm(#env, Core_cterm_A6(#csortanno?, [x] -> #cterm(x)))
  → SubSortFromTerm(#env, #cterm(var))

    // TODO: maybe error?
  rule SubSortFromTerm(#env, Core_cterm_A7(#csortanno?, [x] -> #cterm(x)))
  → SubSortFromTerm(#env, #cterm(var))

func SubSortFromVar(Option<VarEntry>, String) -> Option<Core_csort_sort>

  rule SubSortFromVar(NONE, #var)
  → NONE

  rule SubSortFromVar(SOME(#varEntry), #var)
  → UnVarSort(#varEntry)

// ----- Contraction

func JavaContractum(eager {String : JavaEnvEntry}, Core_cterm_sort) -> Text
rule JavaContractum(#env, #term)
→ JavaStatementTerm(#env, #term)

func JavaStatementTerm(eager {String : JavaEnvEntry}, Core_cterm_sort) -> Text
rule JavaStatementTerm(#env, #cterm)
→ text⟦⟨JavaFreshesTerm(SetCounter(#env, 0), #cterm, [env] -> text⟦⟧)⟩⟨If(GetTail(#env), text⟦return ⟧, text⟦⟧)⟩⟨JavaExprTerm(SetCounter(#env, 0), #cterm, [env] -> text⟦⟧)⟩;⟧

// ---- Generate fresh variable - Only in Java statement mode

func JavaFreshesTerm(eager {String : JavaEnvEntry}, Core_cterm_sort, [{String : JavaEnvEntry}] -> Text) -> Text

  rule JavaFreshesTerm(#env, cterm⟦ ##csortqualifier* ##CONSTRUCTOR ##cterms? ⟧, [env]->#(env))
  → JavaFreshesMaybeTerms(#env, #cterms?, [env] -> #(env))

  rule JavaFreshesTerm(#env, cterm⟦ ##cliteral ⟧, [env] -> #(env))
  → #(#env)

  rule JavaFreshesTerm(#env, cterm⟦ ##VARIABLE ⟧, [env] -> #(env))
  → JavaFreshesVariable(#env, MaybeGetVar(#env, #VARIABLE), #VARIABLE, [env] -> #(env))

  rule JavaFreshesTerm(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, [env] -> #(env))
  → JavaFreshesMaybeTerms(#env, #cterms?, [env] -> JavaFreshesMaybeSubst(env, #csubst?, [env]->#(env)))

  rule JavaFreshesTerm(#env, Core_cterm_A6(#csortanno?, [x] -> #cterm(x)), [env] -> #(env))
  → text⟦
  Variable fresh⟨NumberToText(GetCounter(#env))⟩ = context.makeRefVariable("x");⟨JavaFreshesTerm(IncCounter(AddVar(#env, var, Fresh(text⟦fresh⟨NumberToText(GetCounter(#env))⟩⟧, MaybeSortAnnoToSort(#csortanno?)))), #cterm(var), [env] -> #(env))⟩⟧

  rule JavaFreshesTerm(#env, Core_cterm_A7(#csortanno?, [x] -> #cterm(x)), [env] -> #(env))
  → JavaFreshesTerm(#env, #cterm(var), [env] -> #(env))

func JavaFreshesMaybeTerms(eager {String : JavaEnvEntry}, List<Core_cterms_sort>, [{String : JavaEnvEntry}] -> Text) -> Text
  rule JavaFreshesMaybeTerms(#env, cterms?⟦⟧, [env] -> #(env))
  → #(#env)

  rule JavaFreshesMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧, [env] -> #(env))
  → JavaFreshesTerms(#env, #cterm*, [env] -> #(env))

func JavaFreshesTerms(eager {String : JavaEnvEntry}, List<Core_cterm_sort>, [{String : JavaEnvEntry}] -> Text) -> Text
  rule JavaFreshesTerms(#env, cterm*⟦⟧, [env] -> #(env))
  → #(#env)

  rule JavaFreshesTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, [env] -> #(env))
  → JavaFreshesTerm(#env, #cterm, [env] -> JavaFreshesTerms(env, #cterm*, [env] -> #(env)))

func JavaFreshesMaybeSubst(eager {String : JavaEnvEntry}, List<Core_csubst_sort>, [{String : JavaEnvEntry}] -> Text) -> Text
  rule JavaFreshesMaybeSubst(#env, csubst?⟦⟧, [env] -> #(env))
  → #(#env)

  rule JavaFreshesMaybeSubst(#env, csubst?⟦ [ ##cterm* ] ⟧, [env] -> #(env))
  → JavaFreshesTerms(#env, #cterm*, [env] -> #(env))

func JavaFreshesVariable(eager {String : JavaEnvEntry}, Option<VarEntry>, String, [{String : JavaEnvEntry}] -> Text) -> Text

  rule JavaFreshesVariable(#env, NONE, #var, [env] -> #(env))
  → text⟦
      Variable fresh⟨NumberToText(GetCounter(#env))⟩ = context.makeRefVariable(⟨#var⟩);⟨
        #(IncCounter(AddVar(#env, var, Fresh(text⟦fresh⟨NumberToText(GetCounter(#env))⟩⟧, NONE))))⟩⟧

  rule JavaFreshesVariable(#env,  SOME(#), #var, [env] -> #(env))
  → #(#env)

// ---- Generate term code - Java expression mode

func JavaExprTerm(eager {String : JavaEnvEntry}, Core_cterm_sort, [{String : JavaEnvEntry}] -> Text) -> Text

  rule JavaExprTerm(#env, cterm⟦ ##csortqualifier* ##CONSTRUCTOR ##cterms? ⟧, [env] -> #(env))
  → JavaExprConstruction(#env, #CONSTRUCTOR, #cterms?, [env] -> #(env))

  rule JavaExprTerm(#env, cterm⟦ ##cliteral ⟧, [env] -> #(env))
  → text⟦
      ⟨Literal(#cliteral)⟩⟨#(#env)⟩⟧

  rule JavaExprTerm(#env, cterm⟦ ##VARIABLE ⟧, [env] -> #(env))
  → JavaExprVar(#env, MaybeGetVar(#env, #VARIABLE), [env] -> #(env))

  rule JavaExprTerm(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, [env] -> #(env))
  → JavaExprMeta(#env, #METAVAR, #cterms?, #csubst?, [env] -> #(env))

  //rule JavaExprTerm(#env, cterm⟦ [ ##VARIABLE ] ##cterm ⟧, [env]->#(env))
  rule JavaExprTerm(#env, Core_cterm_A6(#csortanno?, [x] -> #cterm(x)), [env] -> #(env))
  → text⟦
      fresh⟨NumberToText(GetCounter(#env))⟩, ⟨JavaExprTerm(AddVar(IncCounter(#env), var, Fresh(text⟦fresh⟨NumberToText(GetCounter(#env))⟩⟧, MaybeSortAnnoToSort(#csortanno?))), #cterm(var), [env] -> #(env))⟩⟧

  //rule JavaExprTerm(#env, cterm⟦ ( ##VARIABLE ) ##cterm ⟧, [env]->#(env))
  rule JavaExprTerm(#env, Core_cterm_A7(#csortanno?, [x] -> #cterm(x)), [env] -> #(env))
  → text⟦newClosure((c⟨JavaExprLambda(#env, Core_cterm_A7(#csortanno?, [x] -> #cterm(x)), [env] -> #(env))⟩⟧

// ---- construction expression

func JavaExprConstruction(eager {String : JavaEnvEntry}, String, List<Core_cterms_sort>, [{String : JavaEnvEntry}] -> Text) -> Text

rule JavaExprConstruction(#env, #constructor, #cterms?, [env] -> #(env))
→ text⟦⟨ToJavaClassName(#constructor)⟩(context⟨JavaExprMaybeTerms(#env, #cterms?, [env] -> #(env))⟩⟧

func JavaExprMaybeTerms(eager {String : JavaEnvEntry}, List<Core_cterms_sort>, [{String : JavaEnvEntry}] -> Text) -> Text
  rule JavaExprMaybeTerms(#env, cterms?⟦⟧, [env] -> #(env))
  → text⟦)⟨#(#env)⟩⟧

  rule JavaExprMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧, [env] -> #(env))
  → JavaExprTerms(#env, #cterm*, [env] -> #(env))

func JavaExprTerms(eager {String : JavaEnvEntry}, List<Core_cterm_sort>, [{String : JavaEnvEntry}] -> Text) -> Text
  rule JavaExprTerms(#env, cterm*⟦⟧, [env] -> #(env))
  → text⟦)⟨#(#env)⟩⟧

  rule JavaExprTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, [env] -> #(env))
  → text⟦, ⟨JavaExprTerm(#env, #cterm, [env] -> JavaExprTerms(env, #cterm*, [env] -> #(env)))⟩⟧

// --- Variable

func JavaExprVar(eager {String : JavaEnvEntry}, Option<VarEntry>, [{String : JavaEnvEntry}] -> Text) -> Text

  rule JavaExprVar(#env, NONE, [env] -> #(env))
  → text⟦⟧   // Error will be raised by javac

  rule JavaExprVar(#env, SOME(Formal(#var, #type)), [env] -> #(env))
  → text⟦⟨#var⟩⟨#(#env)⟩⟧

  // fallback
  // TODO: robustness
  rule JavaExprVar(#env, SOME(#varEntry), [env] -> #(env))
  → text⟦new Var⟨SortToType(UnSOME(UnVarSort(#varEntry)))⟩(⟨UnVarVar(#varEntry)⟩)⟨#(#env)⟩⟧

// ----  metavar expression

func JavaExprMeta(eager {String : JavaEnvEntry}, String, List<Core_cterms_sort>, List<Core_csubst_sort>, [{String : JavaEnvEntry}] -> Text) -> Text

  // No arguments -> just return the metavariable.
  rule JavaExprMeta(#env, #metavar, cterms?⟦⟧, csubst?⟦⟧, [env] -> #(env))
  → text⟦⟨GetMetaVar(#env, #metavar)⟩⟨#(#env)⟩⟧

  // Apply arguments -> call lambda
  rule JavaExprMeta(#env, #metavar, cterms?⟦ ( ##cterm* ) ⟧, csubst?⟦⟧, [env] -> #(env))
  → text⟦⟨GetMetaVar(#env, #metavar)⟩.apply(context⟨JavaExprTerms(#env, #cterm*, [env] -> #(env))⟩⟧

  // Substitution
  rule JavaExprMeta(#env, #metavar, cterms?⟦⟧, csubst?⟦ [ ##cterm* ] ⟧, [env] -> #(env))
  → text⟦subst(context, ⟨GetMetaVar(#env, #metavar)⟩⟨JavaExprMetaArgs(#env, GetMetaArgs(#env, #metavar), #cterm*, [env] -> #(env))⟩⟧

  // TODO: call and subsitution

func JavaExprMetaArgs(eager {String : JavaEnvEntry}, List<Text> /* pattern args */, List<Core_cterm_sort> /* contraction args */,
                     [{String : JavaEnvEntry}] -> Text) -> Text

  rule JavaExprMetaArgs(#env, (), #args,  [env] -> #(env))
  → text⟦)⟨#(#env)⟩⟧

  rule JavaExprMetaArgs(#env, Cons(#binder, #binders), Cons(#arg, #args), [env] -> #(env))
  → text⟦,⟨#binder⟩,⟨JavaExprTerm(#env, #arg, [env] -> JavaExprMetaArgs(env, #binders, #args, [env] -> #(env)))⟩⟧

// ---- lambda expression

func JavaExprLambda(eager {String : JavaEnvEntry}, Core_cterm_sort, [{String : JavaEnvEntry}] -> Text) -> Text

  rule JavaExprLambda(#env, Core_cterm_A7(#csortanno?, [x] -> #cterm(x)), [env]->#(env))
  → text⟦, p⟨NumberToText(GetCounter(#env))⟩⟨JavaExprLambda(AddVar(IncCounter(#env), var, Formal(text⟦p⟨NumberToText(GetCounter(#env))⟩⟧, MaybeSortAnnoToSort(#csortanno?))), #cterm(var), [env] -> #(env))⟩⟧

  // fallback
  rule JavaExprLambda(#env, #cterm, [env]->#(env))
  → text⟦) -> ⟨JavaExprTerm(#env, #cterm, [env] -> text⟦)⟨#(env)⟩⟧)⟩⟧

// ----- initModule

/* Generate code initializing a module.
   Dynamically register data and function descriptors.
*/
func InitModule({ String : Core_cdecl_sort }, { String : Core_cdecl_sort }, List<String>) -> Text

rule InitModule(#data, #func, #imports)
→ text⟦
private static boolean initialized = false;
public static void init(Context context) {
}⟧

func RegisterImport(eager String) -> Text
rule RegisterImport(#name)
→ text⟦
⟨PathToImport(#name)⟩.init(context);⟧

func RegisterDataSort(Core_cdecl_sort) -> Text
rule RegisterDataSort(cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧)
→ TextFold(Map([x] -> RegisterDataForm(x), #cform*), text⟦⟧)

func RegisterDataForm(Core_cform_sort) -> Text
rule RegisterDataForm(cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
→ text⟦
context.register(⟨Descriptor(#CONSTRUCTOR)⟩);⟧

func RegisterFuncSort(Core_cdecl_sort) -> Text
rule RegisterFuncSort(cdecl⟦ ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧)
→ text⟦
context.register(⟨Descriptor(#CONSTRUCTOR)⟩);⟧

/* Print package declaration */
func PackageDeclaration -> Text
rule PackageDeclaration → PackageDeclaration2(GetEnv("javabasepackage", ""), GetEnv("javapackage", ""))

func PackageDeclaration2(String, String) -> Text
rule PackageDeclaration2(#base, #sub)
→ text⟦
package †⟨#base⟩⟨PackageDeclaration3(If(StringEqual(Trim(#base), ""),"", "."), #sub)⟩;⟧

func PackageDeclaration3(String, String) -> Text
rule PackageDeclaration3(#sep, #sub)
→ If(StringEqual(Trim(#sub), ""), text⟦⟧, text⟦†⟨#sep⟩†⟨#sub⟩⟧)

// Print java import
func PathToImport(String) -> Text

rule PathToImport(#name)
→ PathToImport2(If(StartsWith(#name, "Std::"), "org.transscript.compiler", GetEnv("javabasepackage", "")), PathToDot(DownCaseFirst(#name)))

func PathToImport2(String, String) -> Text

rule PathToImport2(#package, #name)
→  text⟦⟨StringToText(#package)⟩.⟨StringToText(#name)⟩⟧

func PathToDot(String) -> String
rule PathToDot(#path) → PathToDot2(Replace(#path, "::", "."))

func PathToDot2(String) -> String
rule PathToDot2(#subpackage)
→
If(Contains(#subpackage, "."),
    ConcatString(ConcatString(BeforeLast(#subpackage, "."), "."), UpCaseFirst(AfterLast(#subpackage, "."))),
    UpCaseFirst(#subpackage))

// Print class name
func ClassName(String) -> String
rule ClassName(#name) → UpCaseFirst(AfterLast(BeforeLast(#name, "."), "/"))



// ----------- Code generation environment

// To change when upgrade to crsx4.

enum VarEntry
  | Free(Text /* Java var */, Option<Core_csort_sort>)
  | Bound(Text /* Java var */, Option<Core_csort_sort>)
  | Fresh(Text /* Java var */, Option<Core_csort_sort>)
  | Formal(Text /* Java var */, Option<Core_csort_sort>)

enum MetaEntry | MetaVar(Text,       /* Java variable associated with the meta variable*/
                         List<Text>) /* Java variables associated to the meta variable bound variables */

enum JavaEnvEntry | ENum(Numeric) |  EText(Text) | ETexts(List<Text>) | EBool(Boolean) | EMapMeta({String : MetaEntry})
                  | EMapVar({ String : VarEntry }) | EMapDecl({ String : Core_cdecl_sort })
                  | EParams(List<Pair<Text Core_csort_sort>>)


func NewEnv -> {String : JavaEnvEntry}
rule NewEnv →
    MapPut2("sink"        , EText(text⟦⟧),    /* Current sink. */
    MapPut2("params"      , EParams(()),     /* Java method arguments. */
    MapPut2("thunk"       , ETexts(()),     /* thunk arguments */
    MapPut2("label"       , EText(text⟦⟧),    /* Current pattern block label. */
    MapPut2("tail"        , EBool(TRUE),   /* Tail? */
    MapPut2("meta"        , EMapMeta(MapNew),  /* Map meta variable to java variables */
    MapPut2("vars"        , EMapVar(MapNew),   /* Map variable to VarEntry */
    MapPut2("parent"      , EText(text⟦⟧),    /* Sub parent (if any) */
    MapPut2("subindex"    , EText(text⟦⟧),    /* Sub index */
    MapPut2("binderindex" , ENum(0),         /* Current sub binder index */
    MapPut2("binders"     , ETexts(()),    /* Binders list being constructed in contraction */
    MapPut2("data"        , ETexts(()),    /* List of parameters marked as data */
    MapNew))))))))))))


// --- Java printing helpers

// Print construction descriptor name
func Descriptor(String) -> Text
rule Descriptor(#constructor) → ToJavaIdString(#constructor)

// Print literal as a java string
func Literal(Core_cliteral_sort) -> Text
rule Literal(cliteral⟦ ##STRING ⟧) → text⟦newStringTerm(⟨Text-QuoteEscape(#STRING)⟩)⟧
rule Literal(cliteral⟦ ##NUMBER ⟧) → text⟦newDoubleTerm(⟨NumberToText(#NUMBER)⟩)⟧

// Convert constructor to legal Java ID
func ToJavaId(String) -> Text
rule ToJavaId(#constructor) → Text-Mangle(UpCaseFirst(#constructor))

// Convert constructor to legal Java ID
func ToJavaIdString(String) -> Text
rule ToJavaIdString(#name) → Text-Mangle(#name)

// --- Helpers.

func GetValue<a>(eager {String : JavaEnvEntry}, String, [{String : JavaEnvEntry}] -> a) -> a
rule GetValue(#env, #key, [x] -> #unwrap(x))
→ #unwrap(UnSOME(MapGet(#env, #key)))

func SetValue(eager {String : JavaEnvEntry}, String, eager JavaEnvEntry) -> {String : JavaEnvEntry}
rule SetValue(#env, #key, #value)
→ MapPut(#env, #key, #value)

func UnNum(JavaEnvEntry) -> Numeric
rule UnNum(ENum(#)) → #

func UnText(JavaEnvEntry) -> Text
rule UnText(EText(#)) → #

func UnTexts(JavaEnvEntry) -> List<Text>
rule UnTexts(ETexts(#)) → #

func UnParams(JavaEnvEntry) -> List<Pair<Text Core_csort_sort>>
rule UnParams(EParams(#)) → #

func UnBool(JavaEnvEntry) -> Boolean
rule UnBool(EBool(#)) → #

func UnMapMeta(JavaEnvEntry) -> {String : MetaEntry}
rule UnMapMeta(EMapMeta(#)) → #

func UnMapVar(JavaEnvEntry) -> { String : VarEntry }
rule UnMapVar(EMapVar(#)) → #

func UnMapDecl(JavaEnvEntry) -> { String : Core_cdecl_sort }
rule UnMapDecl(EMapDecl(#)) → #

func UnVarVar(VarEntry) -> Text
rule UnVarVar(Bound(#1, #2)) → #1
rule UnVarVar(Free(#1, #2)) → #1
rule UnVarVar(Fresh(#1, #2)) → #1
rule UnVarVar(Formal(#1, #2)) → #1

func UnVarSort(VarEntry) -> Option<Core_sort_sort>
rule UnVarSort(Bound(#1, #2)) → #2
rule UnVarSort(Free(#1, #2)) → #2
rule UnVarSort(Fresh(#1, #2)) → #2
rule UnVarSort(Formal(#1, #2)) → #2

func UnMetaVar(MetaEntry) -> Text
rule UnMetaVar(MetaVar(#1, #2)) → #1

func UnMetaArgs(MetaEntry) -> List<Text>
rule UnMetaArgs(MetaVar(#1, #2)) → #2

// --- Data sorts

func GetDataSorts(eager {String : JavaEnvEntry}) -> { String : Core_cdecl_sort }
rule GetDataSorts(#env) → GetValue(#env, "datasorts", [x] -> UnMapDecl(x))

func SetDataSorts(eager {String : JavaEnvEntry}, { String : Core_cdecl_sort }) -> {String : JavaEnvEntry}
rule SetDataSorts(#env, #sorts) → SetValue(#env, "datasorts", EMapDecl(#sorts))

func IsDataSort(eager {String : JavaEnvEntry}, String) -> Boolean
rule IsDataSort(#env, #cons) → HasOption(MapGet(GetDataSorts(#env), #cons))

// --- Function sorts

func GetFuncSorts(eager {String : JavaEnvEntry}) -> { String : Core_cdecl_sort }
rule GetFuncSorts(#env) → GetValue(#env, "funcsorts", [x] -> UnMapDecl(x))

func SetFuncSorts(eager {String : JavaEnvEntry}, { String : Core_cdecl_sort }) -> {String : JavaEnvEntry}
rule SetFuncSorts(#env, #sorts) → SetValue(#env, "funcsorts", EMapDecl(#sorts))

func IsFuncSort(eager {String : JavaEnvEntry}, String) -> Boolean
rule IsFuncSort(#env, #cons) → HasOption(MapGet(GetFuncSorts(#env), #cons))

// --- Top-level classname

func GetClassname(eager {String : JavaEnvEntry}) -> Text
rule GetClassname(#env) → GetValue(#env, "classname", [x] -> UnText(x))

func SetClassname(eager {String : JavaEnvEntry}, Text) -> {String : JavaEnvEntry}
rule SetClassname(#env, #classname) → SetValue(#env, "classname", EText(#classname))


// --- Sink

func GetSink(eager {String : JavaEnvEntry}) -> Text
rule GetSink(#env) → GetValue(#env, "sink", [x] -> UnText(x))

func SetSink(eager {String : JavaEnvEntry}, Text) -> {String : JavaEnvEntry}
rule SetSink(#env, #sink) → SetValue(#env, "sink", EText(#sink))

// --- Step method arguments

func GetParams(eager {String : JavaEnvEntry}) -> List<Pair<Text Core_csort_sort>>
rule GetParams(#env) → GetValue(#env, "params", [x] -> UnParams(x))

func SetParams(eager {String : JavaEnvEntry}, List<Pair<Text Core_csort_sort>>) -> {String : JavaEnvEntry}
rule SetParams(#env, #params) → SetValue(#env, "params",  EParams(#params))

func AddParam(eager {String : JavaEnvEntry}, Text, Core_csort_sort) -> {String : JavaEnvEntry}
rule AddParam(#env, #param, #csort) → SetValue(#env, "params", EParams(Append(PairCons(#param, #csort), GetParams(#env))))

// Move to the next parameter
func NextParam(eager {String : JavaEnvEntry}) -> {String : JavaEnvEntry}
rule NextParam(#env) → SetParams(#env, Tail(GetParams(#env)))

// Get the current parameter text
func CurrentParam(eager {String : JavaEnvEntry}) -> Text
rule CurrentParam(#env) → Fst(Head(GetParams(#env)))

// Get the current parameter text
func CurrentParamSort(eager {String : JavaEnvEntry}) -> Core_csort_sort
rule CurrentParamSort(#env) → Snd(Head(GetParams(#env)))

// --- Current method name

func GetMethodName(eager {String : JavaEnvEntry}) -> Text
rule GetMethodName(#env) → GetValue(#env, "methodname", [x] -> UnText(x))

func SetMethodName(eager {String : JavaEnvEntry}, Text) -> {String : JavaEnvEntry}
rule SetMethodName(#env, #name) → SetValue(#env, "methodname", EText(#name))

// --- Thunk type

func GetThunkType(eager {String : JavaEnvEntry}) -> Text
rule GetThunkType(#env) → GetValue(#env, "thunktype", [x] -> UnText(x))

func SetThunkType(eager {String : JavaEnvEntry}, Text) -> {String : JavaEnvEntry}
rule SetThunkType(#env, #type) → SetValue(#env, "thunktype", EText(#type))

// --- Thunk arguments

func GetThunk(eager {String : JavaEnvEntry}) -> List<Text>
rule GetThunk(#env) → GetValue(#env, "thunk", [x] -> UnTexts(x))

func SetThunk(eager {String : JavaEnvEntry}, List<Text>) -> {String : JavaEnvEntry}
rule SetThunk(#env, #thunk) → SetValue(#env, "thunk", ETexts(#thunk))

func AddThunk(eager {String : JavaEnvEntry}, Text) -> {String : JavaEnvEntry}
rule AddThunk(#env, #thunk) → SetValue(#env, "thunk", ETexts(Append(#thunk, GetThunk(#env))))

// --- Rule case label

func GetLabel(eager {String : JavaEnvEntry}) -> Text
rule GetLabel(#env) → GetValue(#env, "label", [x] -> UnText(x))

func SetLabel(eager {String : JavaEnvEntry}, Text) -> {String : JavaEnvEntry}
rule SetLabel(#env, #label) → SetValue(#env, "label", EText(#label))

// --- Tail mode.

func GetTail(eager {String : JavaEnvEntry}) -> Boolean
rule GetTail(#env) → GetValue(#env, "tail", [x] -> UnBool(x))

func SetTail(eager {String : JavaEnvEntry}) -> {String : JavaEnvEntry}
rule SetTail(#env) → SetValue(#env, "tail", EBool(TRUE))

func UnsetTail(eager {String : JavaEnvEntry}) -> {String : JavaEnvEntry}
rule UnsetTail(#env) → SetValue(#env, "tail", EBool(FALSE))

// --- Meta

func GetMetas(eager {String : JavaEnvEntry}) -> {String : MetaEntry}
rule GetMetas(#env) → GetValue(#env, "meta", [x] -> UnMapMeta(x))

func GetMetaVar(eager {String : JavaEnvEntry}, String) -> Text
rule GetMetaVar(#env, #metavar) → UnMetaVar(UnSOME(MapGet(GetMetas(#env), #metavar)))

func GetMetaArgs(eager {String : JavaEnvEntry}, String) -> List<Text>
rule GetMetaArgs(#env, #metavar) → UnMetaArgs(UnSOME(MapGet(GetMetas(#env), #metavar)))

func AddMeta(eager {String : JavaEnvEntry}, String, Text, List<Text>) -> {String : JavaEnvEntry}
rule AddMeta(#env, #metavar, #term, #boundvars)
→ SetValue(#env,  "meta", EMapMeta(MapPut(GetMetas(#env), #metavar, MetaVar(#term, #boundvars))))

// --- Variable

func GetVars(eager {String : JavaEnvEntry}) -> { String : VarEntry }
rule GetVars(#env) → GetValue(#env, "vars", [x] -> UnMapVar(x))

func GetVar(eager {String : JavaEnvEntry}, String) -> Text
rule GetVar(#env, #var) → UnVarVar(UnSOME(MapGetVar(GetVars(#env), #var)))

func MaybeGetVar(eager {String : JavaEnvEntry}, String) -> Option<VarEntry>
rule MaybeGetVar(#env, #var) → MapGetVar(GetVars(#env), #var)

func AddVar(eager {String : JavaEnvEntry}, String /* TODO: Core_cvariable_sort */, VarEntry) -> {String : JavaEnvEntry}
rule AddVar(#env, #var, #entry)
→ SetValue(#env, "vars", EMapVar(MapPut(GetVars(#env), #var, #entry)))

// --- Parent term

func GetParent(eager {String : JavaEnvEntry}) -> Text
rule GetParent(#env) → GetValue(#env, "parent", [x] -> UnText(x))

func SetParent(eager {String : JavaEnvEntry}, Text) -> {String : JavaEnvEntry}
rule SetParent(#env, #parent)
→ SetValue(#env, "parent",  EText(#parent))

// --- sub index

func GetSubIndex(eager {String : JavaEnvEntry}) -> Numeric
rule GetSubIndex(#env) → GetValue(#env, "subindex", [x] -> UnNum(x))

func SetSubIndex(eager {String : JavaEnvEntry}, Numeric) -> {String : JavaEnvEntry}
rule SetSubIndex(#env, #index)
→ SetValue(#env, "subindex", ENum(#index))

// --- sub binder index

func GetSubBinderIndex(eager {String : JavaEnvEntry}) -> Numeric
rule GetSubBinderIndex(#env) → GetValue(#env, "binderindex", [x] -> UnNum(x))

func SetSubBinderIndex(eager {String : JavaEnvEntry}, Numeric) -> {String : JavaEnvEntry}
rule SetSubBinderIndex(#env, #index)
→ SetValue(#env, "binderindex", ENum(#index))

func IncSubBinderIndex(eager {String : JavaEnvEntry}) -> {String : JavaEnvEntry}
rule IncSubBinderIndex(#env)
→ SetValue(#env, "binderindex", ENum(Plus(GetSubBinderIndex(#env), 1)))

// --- Binders

func GetBinders(eager {String : JavaEnvEntry}) -> List<Text>
rule GetBinders(#env) → GetValue(#env, "binders", [x] -> UnTexts(x))

func SetBinders(eager {String : JavaEnvEntry}, List<Text>) -> {String : JavaEnvEntry}
rule SetBinders(#env, #binders) → SetValue(#env, "binders", ETexts(#binders))

func AddBinder(eager {String : JavaEnvEntry}, Text) -> {String : JavaEnvEntry}
rule AddBinder(#env, #binders) → SetValue(#env, "binders", ETexts(Append(#binders, GetBinders(#env))))

// --- General purpose counter

func GetCounter(eager {String : JavaEnvEntry}) -> Numeric
rule GetCounter(#env) → GetValue(#env, "counter", [x] -> UnNum(x))

func SetCounter(eager {String : JavaEnvEntry}, Numeric) -> {String : JavaEnvEntry}
rule SetCounter(#env, #index)
→ SetValue(#env, "counter", ENum(#index))

func IncCounter(eager {String : JavaEnvEntry}) -> {String : JavaEnvEntry}
rule IncCounter(#env)
→ SetValue(#env, "counter", ENum(Plus(GetCounter(#env), 1)))

// --- Parameters marked as data

func GetData(eager {String : JavaEnvEntry}) -> List<Text>
rule GetData(#env) → GetValue(#env, "data", [x] -> UnTexts(x))

func AddMaybeData(eager {String : JavaEnvEntry}, Boolean, Text) -> {String : JavaEnvEntry}
rule AddMaybeData(#env, FALSE, #term) → #env

rule AddMaybeData(#env, TRUE, #term)
→ SetValue(#env, "data", ETexts(Append(#term, GetData(#env))))
