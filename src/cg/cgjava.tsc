// Copyright (c) 2016 IBM Corporation.
/*
 * TransScript Java 8 backend code generator
 */


import Std::Core
import Std::String
import Std::Num
import Std::Text
import Std::Listdef
import Std::Pairdef
import Std::Mapdef
import Std::Language

import Core::Core
import Core::Utils
import Text::Text4
import Systemdef

// ===== API

/* Generates Java code for the given `#module` */
func ToJavaM(#system: TSystem, #module: Module) -> Result
→ ToJavaAux(#system, #module, TargetJavaFilename(GetModuleURL(#module), GetConfigDef(#system, "build-dir", ""),
    GetSystemURL(#system), GetConfigDef(#system, "package", "")))

func ToJavaAux(#system: TSystem, #module: Module, #source: String) -> Result
→
SaveResource<Text4_text_sort Result>("text", #source, text⟦
/** Generated File */
†⟨PackageDeclaration(GetModuleURL(#module), GetSystemURL(#system), GetConfigDef(#system, "package", ""))⟩

import java.util.function.Function;

import org.transscript.runtime.Context;
import org.transscript.runtime.Term;
import org.transscript.runtime.Variable;
import org.transscript.runtime.VariableUse;
import org.transscript.runtime.LazyTerm;
import org.transscript.runtime.StringTerm;
import org.transscript.runtime.StringTerm.VarStringTerm;
import org.transscript.runtime.DoubleTerm;
import org.transscript.runtime.DoubleTerm.VarDoubleTerm;
import org.transscript.runtime.MapTerm;
import static org.transscript.runtime.Term.force;
import static org.transscript.runtime.Term.subst;
import static org.transscript.runtime.Functions.*;
import static org.transscript.runtime.StringTerm.lazyStringTerm;
import static org.transscript.runtime.StringTerm.lazyStringTermMaker;
import static org.transscript.runtime.StringTerm.stringTerm;
import static org.transscript.runtime.StringTerm.varStringTerm;
import static org.transscript.runtime.DoubleTerm.lazyDoubleTerm;
import static org.transscript.runtime.DoubleTerm.lazyDoubleTermMaker;
import static org.transscript.runtime.DoubleTerm.doubleTerm;
import static org.transscript.runtime.MapTerm.lazyMapTerm;
import static org.transscript.runtime.MapTerm.lazyMapTermMaker;
import static org.transscript.runtime.LazyTerm.thunk;

†⟨JavaUnit(GetModuleURL(#module), GetImportsM(#module), GetRulesM(#module), GetDataSortsM(#module), GetFuncSortsM(#module), HasOption<String>(GetConfig(#system, "bootstrap")))⟩
⟧, Success((#source,)))

// --- Translate module

/* Generate class for the given module */
func JavaUnit(#url: String, #imports: List<Core_cqconstructor_sort>, #rules: {String:List<Core_cdecl_sort>},
                #datasorts: {String:Core_cdecl_sort}, #funcsorts: {String: Core_cdecl_sort}, #bootstrap: Bool) -> Text4_text_sort
→ text⟦
†⟨TextFold(Map<Core_cqconstructor_sort Text4_text_sort>((x) -> JavaImport(x, #bootstrap), #imports), text⟦⟧)⟩

@SuppressWarnings("unused")
public class ⟨STRING:ClassName(#url)⟩ {

  /* Typed enumerations */
  †⟨TextFold( Map<Core_cdecl_sort Text4_text_sort>((x) ->EnumToClass(x, ClassName(#url)), MapValues<String Core_cdecl_sort>(#datasorts)), text⟦⟧)⟩
  †⟨TextFold( Map<String Text4_text_sort>((x) ->JavaMethod(x, text⟦⟨STRING:ClassName(#url)⟩⟧, #rules, #datasorts, #funcsorts), MapKeys<String Core_cdecl_sort>(#funcsorts)), text⟦⟧)⟩
  †⟨InitModule(#datasorts, #funcsorts, #imports, #bootstrap)⟩
}⟧

func JavaImport(Core_cqconstructor_sort, Bool) -> Text4_text_sort
rule JavaImport(#name, #bootstrap)
→ text⟦
import static †⟨PathToImport(QConsToString(#name, "::"), #bootstrap)⟩.*;⟧ // TODO: maybe use '.' separator

//-------------- Translate enumerations

/* Generate interfaces corresponding to the enum type */
func EnumToClass(Core_cdecl_sort, String) -> Text4_text_sort
rule EnumToClass(cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧, #classname)
→ text⟦

†⟨TextFold(Map<Core_cform_sort Text4_text_sort>((x) -> FormToMethodNew(#CONSTRUCTOR, #csortvars?, x), #cform*), text⟦⟧)⟩

static public †⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ ⟨STRING: ToJavaClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ lazy⟨STRING: ToJavaClassName(#CONSTRUCTOR)⟩(Function<Context, ⟨STRING: ToJavaClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩> function)
{
  return new Lazy⟨STRING: ToJavaClassName(#CONSTRUCTOR)⟩(function);
}

static public †⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ ThunkMaker<⟨STRING: ToJavaClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩> lazy⟨STRING: ToJavaClassName(#CONSTRUCTOR)⟩Maker()
{
  return ⟨STRING: #classname⟩::lazy⟨STRING: ToJavaClassName(#CONSTRUCTOR)⟩;
}

public interface ⟨STRING: ToJavaClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ extends Term
{
  †⟨TextFold(Map<Core_cform_sort Text4_text_sort>((x) -> FormToMethodAs(#CONSTRUCTOR, #csortvars?, x), #cform*), text⟦⟧)⟩
}

†⟨TextFold(Map<Core_cform_sort Text4_text_sort>((x) -> FormToImplValue(#CONSTRUCTOR, #csortvars?, x), #cform*), text⟦⟧)⟩

static class Lazy⟨STRING: ToJavaClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ extends LazyTerm<⟨STRING: ToJavaClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩> implements ⟨STRING: ToJavaClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩
{

  protected Lazy⟨STRING: ToJavaClassName(#CONSTRUCTOR)⟩(⟨STRING: ToJavaClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ value)
	{
		super(value);
	}

  public Lazy⟨STRING: ToJavaClassName(#CONSTRUCTOR)⟩(Function<Context, ⟨STRING: ToJavaClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩> function)
	{
		super(function);
	}

  †⟨TextFold(Map<Core_cform_sort Text4_text_sort>((x) -> FormToMethodMemoAs(#CONSTRUCTOR, #csortvars?, x), #cform*), text⟦⟧)⟩

  @Override
	public ⟨STRING: ToJavaClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ copy(Context c)
	{
		return new Lazy⟨STRING: ToJavaClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩(value);
	}

}⟧

/* Generate a 'new' static method for each enum value */

// TODO: optimize constant value.
func FormToMethodNew(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text4_text_sort
  rule FormToMethodNew(#constructor, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
  → text⟦
    static public †⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ ⟨STRING: ToJavaClassName(#constructor)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ ⟨STRING: ToJavaMethodName(#CONSTRUCTOR)⟩ (Context context†⟨MaybeSortsToJFormalParams(#csorts?, text⟦, ⟧)⟩)
    {
      return new †⟨EValueClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩(†⟨MaybeSortsToArgs(#csorts?)⟩);
    }⟧

  rule FormToMethodNew(#constructor, #csortvars?, cform⟦ allows-variable ⟧)
  → text⟦
    static †⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ Var⟨STRING: ToJavaClassName(#constructor)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ ⟨STRING: ToJavaMethodName(ConcatString("var", #constructor))⟩ (Context ctx, String hint)
    {
      return new Var⟨STRING: ToJavaClassName(#constructor)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩(ctx.makeGlobalName(hint));
    }⟧

// --- Generate a 'as' method for each enum value

func FormToMethodAs(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text4_text_sort
  rule FormToMethodAs(#enumname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
  → text⟦
    default †⟨EValueClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ †⟨MethodNameAs(#CONSTRUCTOR)⟩(Context context)
    {
      return null;
    }⟧

  rule FormToMethodAs(#enumname, #csortvars?, cform⟦ allows-variable ⟧)
  → text⟦⟧

func FormToMethodMemoAs(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text4_text_sort
  rule FormToMethodMemoAs(#enumname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
  → text⟦
   @Override
   final public †⟨EValueClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ †⟨MethodNameAs(#CONSTRUCTOR)⟩(Context context)
   {
     return eval(context).†⟨MethodNameAs(#CONSTRUCTOR)⟩(context);
   }⟧

 rule FormToMethodMemoAs(#enumname, #csortvars?, cform⟦ allows-variable ⟧)
 → text⟦⟧

func MethodNameAs(String) -> Text4_text_sort
rule MethodNameAs(#formCons) → text⟦⟨STRING: ToJavaMethodName(ConcatString("as", #formCons))⟩⟧

// --- Generate an static class for the enumeration value

func FormToImplValue(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text4_text_sort
  rule FormToImplValue(#typename, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
  → text⟦
      public static class †⟨EValueClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ implements ⟨STRING: ToJavaClassName(#typename)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩
      {
          †⟨MaybeSortsToClassFields(#csorts?)⟩

          †⟨MaybeSortsToDefaultConstructor(#csorts?,  EValueClassName(#CONSTRUCTOR))⟩

          public †⟨EValueClassName(#CONSTRUCTOR)⟩(†⟨MaybeSortsToJFormalParams(#csorts?, text⟦⟧)⟩)
          {
            †⟨MaybeSortsToInitFields(#csorts?)⟩
          }

          @Override
          public †⟨EValueClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ †⟨MethodNameAs(#CONSTRUCTOR)⟩(Context context)
          {
            return this;
          }

          @Override
          public Term copy(Context c)
          {
            return new †⟨EValueClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩();
          }

          †⟨MaybeSortsToGetValue(#csorts?)⟩
          †⟨MaybeSortsToGetSubs(#csorts?)⟩
          †⟨MaybeSortsToSetSubs(#csorts?)⟩
          †⟨MaybeSortsToGetBinder(#csorts?)⟩
          †⟨MaybeSortsToSetBinder(#csorts?)⟩

      }⟧

  rule FormToImplValue(#typename, #csortvars?, cform⟦ allows-variable⟧)
  → text⟦
      static class Var⟨STRING: ToJavaClassName(#typename)⟩†⟨SortParamToTypeParam(#csortvars?, TRUE)⟩Use extends VariableUse implements ⟨STRING: ToJavaClassName(#typename)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩
      {
        public Var⟨STRING: ToJavaClassName(#typename)⟩Use(Variable var)
        {
          super(var);
        }
    }

    public static class Var⟨STRING: ToJavaClassName(#typename)⟩†⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ extends Variable
    {
      public Var⟨STRING: ToJavaClassName(#typename)⟩(String name)
      {
        super(name);
      }

      @Override
      protected Var⟨STRING: ToJavaClassName(#typename)⟩Use newVarUse()
      {
        return new Var⟨STRING: ToJavaClassName(#typename)⟩Use(this);
      }

      @Override
		  public Var⟨STRING: ToJavaClassName(#typename)⟩Use use()
		  {
			  return (Var⟨STRING: ToJavaClassName(#typename)⟩Use) super.use();
		  }

      @Override
      public Variable make(Context ctx, String hint)
  	  {
  		  return new Var⟨STRING: ToJavaClassName(#typename)⟩(ctx.makeGlobalName(hint));
  	  }

    }

    ⟧

//--- Default empty constructor

func MaybeSortsToDefaultConstructor(List<Core_csorts_sort>, Text4_text_sort) -> Text4_text_sort
  rule MaybeSortsToDefaultConstructor(csorts?⟦⟧, #classname)
  → text⟦⟧

  rule MaybeSortsToDefaultConstructor(csorts?⟦ ( ##csort*) ⟧, #classname)
  → text⟦private †⟨#classname⟩() {}⟧

//--- Class fields

func MaybeSortsToClassFields(List<Core_csorts_sort>) -> Text4_text_sort
  rule MaybeSortsToClassFields(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToClassFields(csorts?⟦ ( ##csort* ) ⟧)
  → text⟦
    /* Form arguments */
    †⟨SortsToClassFields(#csort*, 1)⟩⟧

func SortsToClassFields(List<Core_csort_sort>, Numeric) -> Text4_text_sort
  rule SortsToClassFields(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToClassFields(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦†⟨SortToClassFields(SortToTypes(#csort), #index, 1)⟩†⟨SortsToClassFields(#csort*, Plus(#index, 1))⟩⟧

func SortToClassFields(List<Text4_text_sort>, Numeric, Numeric) -> Text4_text_sort
  rule SortToClassFields(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex)
  → text⟦†⟨#type⟩ field†⟨FieldSuffix(#index)⟩;⟧

  rule SortToClassFields(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex)
  → text⟦
     †⟨#type⟩ var†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩;
     †⟨SortToClassFields(#types, #index, Plus(#subindex, 1))⟩⟧

//--- Class fields initialization

func MaybeSortsToInitFields(List<Core_csorts_sort>) -> Text4_text_sort
  rule MaybeSortsToInitFields(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToInitFields(csorts?⟦ ( ##csort* ) ⟧)
  → SortsToInitFields(#csort*, 1)

func SortsToInitFields(List<Core_csort_sort>, Numeric) -> Text4_text_sort
  rule SortsToInitFields(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToInitFields(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦†⟨SortToInitFields(SortToTypes(#csort), #index, 1)⟩†⟨SortsToInitFields(#csort*, Plus(#index, 1))⟩⟧

func SortToInitFields(List<Text4_text_sort>, Numeric, Numeric) -> Text4_text_sort
  rule SortToInitFields(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex)
  → text⟦this.field†⟨FieldSuffix(#index)⟩ = param†⟨FieldSuffix(#index)⟩;⟧

  rule SortToInitFields(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex)
  → text⟦this.var†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩ = param†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩; †⟨SortToInitFields(#types, #index, Plus(#subindex, 1))⟩⟧

// --- sub function

func MaybeSortsToGetSubs(List<Core_csorts_sort>) -> Text4_text_sort
  rule MaybeSortsToGetSubs(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToGetSubs(csorts?⟦ ( ##csort* ) ⟧)
  → text⟦
      @Override
      public Term sub(int i) {
       switch (i) {
         †⟨SortsToGetSubs(#csort*, 0)⟩
         default: return null;
        }
      }⟧

func SortsToGetSubs(List<Core_csort_sort>, Numeric) -> Text4_text_sort
  rule SortsToGetSubs(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToGetSubs(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦†⟨SortToGetSubs(SortToTypes(#csort), #index, 0)⟩†⟨SortsToGetSubs(#csort*, Plus(#index, 1))⟩⟧

func SortToGetSubs(List<Text4_text_sort>, Numeric, Numeric) -> Text4_text_sort

  rule SortToGetSubs(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex)
  → text⟦case †⟨NumberToText(#index)⟩: return field†⟨FieldSuffix(Plus(#index, 1))⟩;⟧

  rule SortToGetSubs(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex)
  → SortToGetSubs(#types, #index, Plus(#subindex, 1))

// --- SetSub function

func MaybeSortsToSetSubs(List<Core_csorts_sort>) -> Text4_text_sort
  rule MaybeSortsToSetSubs(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToSetSubs(csorts?⟦ ( ##csort* ) ⟧)
  → text⟦
      @Override
      public void setSub(int i, Term sub) {
        switch (i) {
             †⟨SortsToSetSubs(#csort*, 0)⟩
             default: throw new IndexOutOfBoundsException();
           }
         }⟧

func SortsToSetSubs(List<Core_csort_sort>, Numeric) -> Text4_text_sort
  rule SortsToSetSubs(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToSetSubs(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦†⟨SortToSetSubs(SortToTypes(#csort), #index, 0)⟩†⟨SortsToSetSubs(#csort*, Plus(#index, 1))⟩⟧

func SortToSetSubs(List<Text4_text_sort>, Numeric, Numeric) -> Text4_text_sort

  rule SortToSetSubs(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex)
  → text⟦
      case †⟨NumberToText(#index)⟩:
        field†⟨FieldSuffix(Plus(#index, 1))⟩ = (†⟨#type⟩) sub;
        break;⟧

  rule SortToSetSubs(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex)
  → SortToSetSubs(#types, #index, Plus(#subindex, 1))

// --- binder function

func MaybeSortsToGetBinder(List<Core_csorts_sort>) -> Text4_text_sort
  rule MaybeSortsToGetBinder(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToGetBinder(csorts?⟦ ( ##csort* ) ⟧)
  → If<Text4_text_sort>(HasBinders(#csort*),
      ()->text⟦
        @Override
        public Variable binder(int i, int j) {
          switch (i) {
            †⟨SortsToGetBinder(#csort*, 0)⟩
            default: return null;
          }
        }⟧,
      ()->text⟦⟧)

func SortsToGetBinder(List<Core_csort_sort>, Numeric) -> Text4_text_sort
  rule SortsToGetBinder(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToGetBinder(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦
      †⟨If<Text4_text_sort>(HasBindersSort(#csort),
        ()->text⟦
          case †⟨NumberToText(#index)⟩: {
            switch (j) {
              †⟨SortToGetBinder(SortToTypes(#csort), #index, 0)⟩
              default: return null;
            }
          }⟧,
        ()->text⟦⟧)⟩
      †⟨SortsToGetBinder(#csort*, Plus(#index, 1))⟩⟧

func SortToGetBinder(List<Text4_text_sort>, Numeric, Numeric) -> Text4_text_sort

  rule SortToGetBinder(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex)
  → text⟦⟧

  rule SortToGetBinder(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex)
  → text⟦
      case †⟨NumberToText(#subindex)⟩: return var†⟨NumberToText(Plus(#index, 1))⟩_†⟨NumberToText(Plus(#subindex, 1))⟩;
      †⟨SortToGetBinder(#types, #index, Plus(#subindex, 1))⟩⟧

// --- setBinder function

func MaybeSortsToSetBinder(List<Core_csorts_sort>) -> Text4_text_sort
  rule MaybeSortsToSetBinder(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToSetBinder(csorts?⟦ ( ##csort* ) ⟧)
  → If<Text4_text_sort>(HasBinders(#csort*),
      ()->text⟦
        @Override
        public void setBinder(int i, int j, Variable var) {
         switch (i) {
           †⟨SortsToSetBinder(#csort*, 0)⟩
           default: throw new IndexOutOfBoundsException();
          }
        }⟧,
      ()->text⟦⟧)

func SortsToSetBinder(List<Core_csort_sort>, Numeric) -> Text4_text_sort
  rule SortsToSetBinder(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToSetBinder(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦
      †⟨If<Text4_text_sort>(HasBindersSort(#csort),
        () -> text⟦
          case †⟨NumberToText(#index)⟩: {
            switch (j) {
              †⟨SortToSetBinder(SortToTypes(#csort), #index, 0)⟩
              default: throw new IndexOutOfBoundsException();
            }
            break;
          }⟧,
        () -> text⟦⟧)⟩
      †⟨SortsToSetBinder(#csort*, Plus(#index, 1))⟩⟧

func SortToSetBinder(List<Text4_text_sort>, Numeric, Numeric) -> Text4_text_sort

  rule SortToSetBinder(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex)
  → text⟦⟧

  rule SortToSetBinder(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex)
  → text⟦
      case †⟨NumberToText(#subindex)⟩:
        var†⟨NumberToText(Plus(#index, 1))⟩_†⟨NumberToText(Plus(#subindex, 1))⟩ = (†⟨#type⟩) var;
        break;
      †⟨SortToSetBinder(#types, #index, Plus(#subindex, 1))⟩⟧


//--- Sort to formal parameters

func MaybeSortsToJFormalParams(List<Core_csorts_sort>, Text4_text_sort) -> Text4_text_sort
  rule MaybeSortsToJFormalParams(csorts?⟦⟧, #sep)
  → text⟦⟧

  rule MaybeSortsToJFormalParams(csorts?⟦ ( ##csort*) ⟧, #sep)
  → SortsToJFormalParams(#csort*, 1, #sep)

func SortsToJFormalParams(List<Core_csort_sort>, Numeric, Text4_text_sort) -> Text4_text_sort
  rule SortsToJFormalParams(csort*⟦⟧, #index, #sep)
  → text⟦⟧

  rule SortsToJFormalParams(csort*⟦ ##csort ##csort* ⟧, #index, #sep)
  → text⟦†⟨#sep⟩†⟨SortToJFormalParams(SortToTypes(#csort), #index, 1)⟩†⟨SortsToJFormalParams(#csort*, Plus(#index, 1), text⟦, ⟧)⟩⟧

func SortToJFormalParams(List<Text4_text_sort>, Numeric, Numeric) -> Text4_text_sort
  rule SortToJFormalParams(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex)
  → text⟦†⟨#type⟩ param†⟨FieldSuffix(#index)⟩⟧

  rule SortToJFormalParams(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex)
  → text⟦†⟨#type⟩ param†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩, †⟨SortToJFormalParams(#types, #index, Plus(#subindex, 1))⟩⟧

//--- Sort to function call arguments

func MaybeSortsToArgs(List<Core_csorts_sort>) -> Text4_text_sort
  rule MaybeSortsToArgs(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToArgs(csorts?⟦ ( ##csort*) ⟧)
  → SortsToArgs(#csort*, 1, text⟦⟧)

func SortsToArgs(List<Core_csort_sort>, Numeric, Text4_text_sort) -> Text4_text_sort
  rule SortsToArgs(csort*⟦⟧, #index, #sep)
  → text⟦⟧

  rule SortsToArgs(csort*⟦ ##csort ##csort* ⟧, #index, #sep)
  → text⟦†⟨#sep⟩†⟨SortToArgs(SortToTypes(#csort), #index, 1)⟩†⟨SortsToArgs(#csort*, Plus(#index, 1), text⟦, ⟧)⟩⟧

func SortToArgs(List<Text4_text_sort>, Numeric, Numeric) -> Text4_text_sort
  rule SortToArgs(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex)
  → text⟦param†⟨FieldSuffix(#index)⟩⟧

  rule SortToArgs(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex)
  → text⟦param†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩, †⟨SortToArgs(#types, #index, Plus(#subindex, 1))⟩⟧

//--- Get value method implementation

func MaybeSortsToGetValue(List<Core_csorts_sort>) -> Text4_text_sort
  rule MaybeSortsToGetValue(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToGetValue(csorts?⟦ ( ##csort* ) ⟧)
  → SortsToGetValue(#csort*, 1)

func SortsToGetValue(List<Core_csort_sort>, Numeric) -> Text4_text_sort
  rule SortsToGetValue(csort*⟦ ⟧, #index)
  → text⟦⟧

  rule SortsToGetValue(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦†⟨SortToGetValue(SortToTypes(#csort), #index, 1)⟩†⟨SortsToGetValue(#csort*, Plus(#index, 1))⟩⟧

func SortToGetValue(List<Text4_text_sort>, Numeric, Numeric) -> Text4_text_sort
  rule SortToGetValue(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex)
  → text⟦public †⟨#type⟩ getField†⟨FieldSuffix(#index)⟩(Context ctx, boolean force) {
            if (force)
               field†⟨FieldSuffix(#index)⟩ = force(ctx, field†⟨FieldSuffix(#index)⟩);
            return field†⟨FieldSuffix(#index)⟩;
         }⟧

  rule SortToGetValue(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex)
  → text⟦public †⟨#type⟩ getVar†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩() {
           return var†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩;
        }
        †⟨SortToGetValue(#types, #index, Plus(#subindex, 1))⟩⟧

//--- Helpers

func FieldSuffix(Numeric) -> Text4_text_sort
  rule FieldSuffix(#index)
  → NumberToText(#index)

func MaybeSortsCount(List<Core_csorts_sort>) -> Numeric
  rule MaybeSortsCount(csorts?⟦⟧)             → 0
  rule MaybeSortsCount(csorts?⟦ (##csort*) ⟧) → ListLength<Core_csort_sort>(#csort*)

/** whether list of sorts has at least one binders */
func HasBinders(List<Core_csort_sort>) -> Bool
  rule HasBinders(csort*⟦⟧) → FALSE
  rule HasBinders(csort*⟦ ##csort ##csort* ⟧)
  → Or(HasBindersSort(#csort), HasBinders(#csort*))

func HasBindersSort(Core_csort_sort) -> Bool
  rule HasBindersSort(csort⟦ ##CONSTRUCTOR ##csorts? ⟧) → FALSE
  rule HasBindersSort(csort⟦ ##VARIABLE ⟧)              → FALSE
  rule HasBindersSort(csort⟦ [ ##csort ] ##csort2 ⟧)    → TRUE
  rule HasBindersSort(csort⟦ ( ##csort ) ##csort2 ⟧)    → HasBindersSort(#csort2)
  rule HasBindersSort(csort⟦ { ##cmapsort } ⟧)          → FALSE
  rule HasBindersSort(csort⟦ data ##csort ⟧)            → HasBindersSort(#csort)
  rule HasBindersSort(csort⟦ thunk ##csort ⟧)           → HasBindersSort(#csort)

/** Generate classname corresponding to an enumeration value */
func EValueClassName(String) -> Text4_text_sort
rule EValueClassName(#name) → text⟦_⟨STRING:#name⟩⟧

//--- Rename builtin types to avoid conflict with Java types

func FixupPrimitiveType(String) -> String
rule FixupPrimitiveType(#typename)
→ If<String>(StringEqual(#typename, "String"), ()->"StringTerm",
  ()->If<String>(StringEqual(#typename, "Numeric"), ()->"DoubleTerm",
       ()->#typename))


//---- Sort tranlation

func SortParamToTypeParam(List<Core_csortvars_sort>, Bool /* parameterize or parameterization? */) -> Text4_text_sort
  rule SortParamToTypeParam(csortvars?⟦ ⟧, #parameterize)
  → text⟦⟧

  rule SortParamToTypeParam(csortvars?⟦ ∀ ##variable_TOK+ . ⟧, #parameterize)
  → text⟦<†⟨TextFold(Map<String Text4_text_sort>((x) -> text⟦⟨STRING: ToJavaTypeParameter(x)⟩†⟨If<Text4_text_sort>(#parameterize, ()->text⟦ extends Term⟧, ()->text⟦⟧)⟩⟧, #variable_TOK+), text⟦, ⟧)⟩>⟧

func MaybeSortsToTypeParams(List<Core_csorts_sort>) -> Text4_text_sort
  rule MaybeSortsToTypeParams(csorts?⟦ ⟧)
  → text⟦⟧

  rule MaybeSortsToTypeParams(csorts?⟦ ( ##csort* )⟧)
  → text⟦<†⟨TextFold( Flatten<Text4_text_sort>(Map<Core_csort_sort List>((x) -> SortToTypes(x), #csort*)), text⟦, ⟧)⟩>⟧

/** Convert sort annotation to equivalent Java type */
func MaybeSortAnnoToType(List<Core_csortanno_sort>) -> Text4_text_sort
  rule MaybeSortAnnoToType(csortanno?⟦ ⟧)
  → text⟦⟧

  rule MaybeSortAnnoToType(csortanno?⟦ : ##csort ⟧)
  → SortToType(#csort)

/* Translate Transscript sort to equivalent list of Java types:
 * a list of types corresponding to syntactic variable sorts and a type for the last sort
 */
func SortToTypes(Core_csort_sort) -> List<Text4_text_sort>
rule SortToTypes(#csort) → SortToTypes2(#csort, ())

func SortToTypes2(Core_csort_sort, List<Text4_text_sort> /* formal params */) -> List<Text4_text_sort>

  rule SortToTypes2(csort⟦ ##CONSTRUCTOR ##csorts? ⟧, ())
  → Cons(text⟦⟨STRING: ToJavaClassName(FixupPrimitiveType(#CONSTRUCTOR))⟩†⟨MaybeSortsToTypeParams(#csorts?)⟩⟧, Nil)

  rule SortToTypes2(csort⟦ ##CONSTRUCTOR ##csorts? ⟧, Cons(#formal:Text4_text_sort, #formals:List<Text4_text_sort>))
  → Cons(text⟦Closure†⟨NumberToText(Plus(ListLength<Text4_text_sort>(#formals), 1))⟩<⟨STRING:
       ToJavaClassName(FixupPrimitiveType(#CONSTRUCTOR))⟩†⟨MaybeSortsToTypeParams(#csorts?) /* Return type */⟩, †⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* JFormal params */⟩>⟧, Nil)

  rule SortToTypes2(csort⟦ ##VARIABLE ⟧, ())
  → Cons(text⟦⟨STRING: ToJavaTypeParameter(#VARIABLE)⟩⟧, Nil)

  rule SortToTypes2(csort⟦ ##VARIABLE ⟧, Cons(#formal:Text4_text_sort, #formals:List<Text4_text_sort>))
  → Cons(text⟦Closure†⟨NumberToText(Plus(ListLength<Text4_text_sort>(#formals), 1))⟩<⟨STRING: #VARIABLE /* Return type */⟩, †⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* JFormal params */⟩>⟧, Nil)

  rule SortToTypes2(csort⟦ [ ##csort ] ##csort2 ⟧, #formals)
  → Cons(text⟦Var†⟨SortToType(#csort)⟩⟧, SortToTypes2(#csort2, #formals))

  rule SortToTypes2(csort⟦ ( ##csort ) ##csort2 ⟧, #formals)
  → SortToTypes2(#csort2, Concat<Text4_text_sort>(#formals, SortToTypes(#csort)))

  rule SortToTypes2(csort⟦ { ##csort1 : ##csort2 } ⟧, ())
  → Cons(text⟦MapTerm<†⟨SortToType(#csort1)⟩,†⟨SortToType(#csort2)⟩>⟧, Nil)

  rule SortToTypes2(csort⟦ { ##cmapsort } ⟧, Cons(#formal:Text4_text_sort, #formals:List<Text4_text_sort>))
  → Cons(text⟦Closure†⟨NumberToText(Plus(ListLength<Text4_text_sort>(#formals), 1))⟩<MapTerm, †⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* JFormal params */⟩>⟧, Nil)

  rule SortToTypes2(csort⟦ data ##csort ⟧, #formals)
  → SortToTypes2(#csort, #formals)

  rule SortToTypes2(csort⟦ thunk ##csort ⟧, #formals)
  → Cons(text⟦LazyTerm<†⟨SortToType(#csort)⟩>⟧, Nil)

/* Same as above, expect ignore syntactic variables */
func SortToType(Core_csort_sort) -> Text4_text_sort
rule SortToType(#csort) → Last<Text4_text_sort>(SortToTypes(#csort)) // TODO: could optimize

/* Same as above, expect maybe get a sort */
func MaybeSortToType(Option<Core_csort_sort>) -> Text4_text_sort
rule MaybeSortToType(NONE)         → text⟦⟧
rule MaybeSortToType(SOME(#csort:Core_csort_sort)) → Last<Text4_text_sort>(SortToTypes(#csort)) // TODO: could optimize

/* Sort qualifier to type */
func SortQualifierToType(Core_csortqualifier_sort) -> Text4_text_sort
rule SortQualifierToType(csortqualifier⟦ ##csort ::⟧)
→ SortToType(#csort)

//-------------- Translate functions and rules

/* Generate method for function. Start with method signature */
func JavaMethod(String, Text4_text_sort, {String : List<Core_cdecl_sort>},
           { String : Core_cdecl_sort }, { String : Core_cdecl_sort }) -> Text4_text_sort
rule JavaMethod(#constructor, #classname, #rules, #datasorts, #funcsorts)
→ text⟦final public static †⟨
          JavaMethodSig(JSetDataSorts(JSetFuncSorts(JSetClassname(JNewEnv, #classname), #funcsorts), #datasorts),
                        UnSOME<Core_cdecl_sort>(MapGet<String Core_cdecl_sort>(#funcsorts, #constructor)),
                        MapGet<String List>(#rules, #constructor))⟩⟧

func JavaMethodSig({String : JEnvEntry}, Core_cdecl_sort, Option<List<Core_cdecl_sort>>) -> Text4_text_sort
rule JavaMethodSig(#env, cdecl⟦ ##canno* ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧, #rules)
→ text⟦†⟨ReturnType(#csortvars?, #csort)⟩⟨STRING:ToJavaMethodName(#CONSTRUCTOR)⟩(Context context†⟨ThunkMakerSig(#csortvars?)⟩†⟨
      JavaSigMaybeArgs(
         JSetMethodName(
           JJSetThunkMaker(
             JAddThunk(
               SetContext(SetFnAnno(#env, #canno*), text⟦context⟧, 1),
               ThunkMakerArg(#csortvars?)),
             ThunkMaker(#csort)),
           text⟦⟨STRING: ToJavaMethodName(#CONSTRUCTOR)⟩⟧), #csorts?, #rules)⟩⟧   // )

// --- Generate return type

func ReturnType(List<Core_csortvars_sort>, Core_csort_sort) -> Text4_text_sort
rule ReturnType(#csortvars?, #csort)
→ text⟦†⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ †⟨TextFold(SortToTypes(#csort), text⟦⟧)⟩ ⟧

/* Since Java erases sort parameters at runtime, need to pass them along */
func ThunkMakerSig(List<Core_csortvars_sort>) -> Text4_text_sort
rule ThunkMakerSig(csortvars?⟦             ⟧) → text⟦⟧
rule ThunkMakerSig(csortvars?⟦ ∀ ##variable_TOK+ . ⟧) → TextFold(Map<String Text4_text_sort>((x)->ThunkMakerSigHelper(x), #variable_TOK+), text⟦⟧)

func ThunkMakerSigHelper(String) -> Text4_text_sort
rule ThunkMakerSigHelper(#) → text⟦, ThunkMaker<⟨STRING: #⟩> tm⟨STRING: #⟩⟧

/* Associated function generating thunk maker argument */
func ThunkMakerArg(List<Core_csortvars_sort>) -> Text4_text_sort
rule ThunkMakerArg(csortvars?⟦             ⟧) → text⟦⟧
rule ThunkMakerArg(csortvars?⟦ ∀ ##variable_TOK+ . ⟧) → TextFold(Map<String Text4_text_sort>((x)->ThunkMakerArgHelper(x), #variable_TOK+), text⟦⟧)

func ThunkMakerArgHelper(String) -> Text4_text_sort
rule ThunkMakerArgHelper(#) → text⟦, tm⟨STRING: #⟩⟧

// --- Generate thunk type

func ThunkMaker(Core_csort_sort) -> Text4_text_sort

  rule ThunkMaker(csort⟦ ##CONSTRUCTOR ##csorts? ⟧)
  → text⟦lazy⟨STRING: ToJavaClassName(FixupPrimitiveType(#CONSTRUCTOR))⟩⟧

  rule ThunkMaker(csort⟦ ##VARIABLE ⟧) // polymorphic return type.
  → text⟦tm⟨STRING: #VARIABLE⟩.apply⟧

  rule ThunkMaker(csort⟦ [ ##csort ] ##csort2 ⟧)
  → Error<Text4_text_sort>("Internal error: a function cannot return scoped values")

  rule ThunkMaker(csort⟦ ( ##csort ) ##csort2 ⟧)
  → Error<Text4_text_sort>("Internal error: a function cannot return another function")

  // Java infers map types.
  rule ThunkMaker(csort⟦ { ##cmapsort } ⟧)
  → text⟦lazyMapTerm⟧

  rule ThunkMaker(csort⟦ data ##csort ⟧)
  → ThunkMaker(#csort)

  rule ThunkMaker(csort⟦ thunk ##csort ⟧)
  → ThunkMaker(#csort)

// --- Generate method signature

func JavaSigMaybeArgs({String : JEnvEntry}, List<Core_csorts_sort>, Option<List<Core_cdecl_sort>>) -> Text4_text_sort
  rule JavaSigMaybeArgs(#env, csorts?⟦⟧, #rules)
  → JavaBody(#env, #rules)

  rule JavaSigMaybeArgs(#env, csorts?⟦ ( ##csort* ) ⟧, #rules)
  → JavaSigArgs(#env, #csort*, #rules)

// Generate method signature and record the argument names in the environment, keeping them in order
func JavaSigArgs({String : JEnvEntry}, List<Core_csort_sort>, Option<List<Core_cdecl_sort>>) -> Text4_text_sort

  rule JavaSigArgs(#env, csort*⟦ ⟧, #rules)
  → JavaBody(#env, #rules)

  rule JavaSigArgs(#env, csort*⟦ ##csort ##csort* ⟧, #rules)
  → JavaSigArg(#env, #csort, FALSE, SortToTypes(#csort), #csort*, #rules)

func JavaSigArg({String : JEnvEntry}, Core_csort_sort, Bool /* data? */,
                List<Text4_text_sort> /* formal parameters */, List<Core_csort_sort>, Option<List<Core_cdecl_sort>>) -> Text4_text_sort

 // Monomorphic sort
   rule JavaSigArg(#env, csort⟦ ##CONSTRUCTOR ##csorts? ⟧, #data, Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #csort*, #rules)
   → text⟦, †⟨#type⟩ ⟨STRING: value:String⟩†⟨
       JavaSigArgs(JAddThunk(JAddParam(AddMaybeData(#env, #data, text⟦⟨STRING: value⟩⟧), text⟦⟨STRING: value⟩⟧, Core_csort_A1(#CONSTRUCTOR, #csorts?)), text⟦⟨STRING: value⟩⟧), #csort*, #rules)⟩⟧

   // Sort variable
   rule JavaSigArg(#env, csort⟦ ##VARIABLE ⟧, #data, Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #csort*, #rules)
   → text⟦, †⟨#type⟩ ⟨STRING: value:String⟩†⟨
       JavaSigArgs(JAddThunk(JAddParam(AddMaybeData(#env, #data, text⟦⟨STRING: value⟩⟧), text⟦⟨STRING: value⟩⟧, Core_csort_A2(#VARIABLE)), text⟦⟨STRING: value⟩⟧), #csort*, #rules)⟩⟧

   // Syntactic variable sort
   //rule JavaSigArgs(#env, csort⟦ [ ##csort ] ##csort2 ⟧, #data, Cons(#type, #types), #rules)
   rule JavaSigArg(#env, Core_csort_A3(#csort:Core_csort_sort, #csort2:Core_csort_sort), #data, Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #csort*, #rules)
   → text⟦, †⟨#type⟩ ⟨STRING: var:String⟩†⟨
       JavaSigArg(JAddThunk(JAddParam(#env, text⟦⟨STRING: var⟩⟧, #csort), text⟦⟨STRING: var⟩⟧), #csort2, #data, #types, #csort*, #rules)⟩⟧

   // JFormal parameter sort
   //rule JavaSigArgs(#env, csort⟦ ( ##csort ) ##csort2 ⟧, #data, #rules)
   rule JavaSigArg(#env, Core_csort_A4(#csort:Core_csort_sort, #csort2:Core_csort_sort), #data, #types, #csort*, #rules)
   → JavaSigArg(#env, #csort2, #data, #types, #csort*, #rules)

   rule JavaSigArg(#env, csort⟦ { ##cmapsort* } ⟧, #data, Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #csort*, #rules)
   → text⟦, †⟨#type⟩ ⟨STRING: map:String⟩†⟨
       JavaSigArgs(JAddThunk(JAddParam(AddMaybeData(#env, #data, text⟦⟨STRING: map⟩⟧), text⟦⟨STRING: map⟩⟧, Core_csort_A5(#cmapsort*)), text⟦⟨STRING: map⟩⟧), #csort*, #rules)⟩⟧

   rule JavaSigArg(#env, csort⟦ data ##csort ⟧, #data, #types, #csort*, #rules)
   → JavaSigArg(#env, #csort, TRUE, #types, #csort*, #rules)

   rule JavaSigArg(#env, csort⟦ thunk ##csort ⟧, #data, #types, #csort*, #rules)
   → JavaSigArg(#env, #csort, #data, #types, #csort*, #rules)

// --- Generate method body

func JavaBody({String : JEnvEntry}, Option<List<Core_cdecl_sort>>) -> Text4_text_sort

  // No rules: it must be an external function (not yet checked but should)
  rule JavaBody(#env, NONE)
  → text⟦) {
        return †⟨JGetClassname(#env)⟩Extern.†⟨JGetMethodName(#env)⟩(context†⟨TextFold(JGetThunk(#env), text⟦, ⟧)⟩);
      }⟧

  // At least one rule: not external
  rule JavaBody(#env, SOME(#rules:List<Core_cdecl_sort>))
  → text⟦
    ) {
        †⟨TextFold(Map<Core_cdecl_sort Text4_text_sort>((x) -> JavaBodyRule(#env, x), #rules), text⟦⟧)⟩

        †⟨FallbackThunk(#env, HasAnnotation("Fallback", GetFnAnno(#env)))⟩
      }⟧

// Generate code to normalize arguments marked as 'data'
func JavaApplyData(Text4_text_sort) -> Text4_text_sort
rule JavaApplyData(#term)
→ text⟦†⟨#term⟩.eval(context).release();⟧

/* Generate fallback thunk (or error) if function is not complete */
func FallbackThunk({String : JEnvEntry}, Bool) -> Text4_text_sort

  rule FallbackThunk(#env, TRUE)  → text⟦⟧

  rule FallbackThunk(#env, FALSE)
  //→ text⟦return †⟨JJGetThunkMaker(#env)⟩(c -> †⟨JGetMethodName(#env)⟩(c†⟨TextFold(JGetThunk(#env), text⟦, ⟧)⟩));⟧
  → text⟦throw new RuntimeException("Missing case");⟧

// --- Start method body

func JavaBodyRule({String : JEnvEntry}, Core_cdecl_sort) -> Text4_text_sort
  rule JavaBodyRule(#env, cdecl⟦ rule ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##csortanno? → ##cterm ⟧)
  → JavaContractum(#env, #cterm)

  rule JavaBodyRule(#env, cdecl⟦ rule ##csortqualifier* ##CONSTRUCTOR ##csortargs? ( ##cterm* ) ##csortanno? → ##cterm2 ⟧)
  → JavaPattern(#env, #cterm*, #cterm2)

// --- Pattern matching

func JavaPattern({String : JEnvEntry}, List<Core_cterm_sort>, Core_cterm_sort) -> Text4_text_sort

// TODO: case where there is only one rule.
rule JavaPattern(#env, #cterms, #contractum)
→ text⟦⟨STRING: label:String⟩:{†⟨JavaCasePattern(JSetLabel(#env, text⟦⟨STRING: label⟩⟧), #cterms, #contractum)⟩
}⟧

// Data sort helper indicating whether the current term is a method parameter, or an argument (local variable).
enum Storage | PARAMETER | ARGUMENT

// Iterate over top-level pattern arguments
func JavaCasePattern({String : JEnvEntry}, List<Core_cterm_sort>, Core_cterm_sort) -> Text4_text_sort

rule JavaCasePattern(#env, cterm*⟦ ⟧, #contractum)
→ JavaContractum(#env, #contractum)

rule JavaCasePattern(#env, cterm*⟦ ##cterm ##cterm* ⟧, #contractum)
→ JavaPatternTerm(JNextParam(#env), #cterm, JCurrentParam(#env), SOME(JCurrentParamSort(#env)), PARAMETER, (env) -> JavaCasePattern(env, #cterm*, #contractum))

// --- Term pattern matching

func JavaPatternTerm({String : JEnvEntry}, Core_cterm_sort, Text4_text_sort /* Current term */,
                     Option<Core_csort_sort> /* Sort when known */, Storage, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaPatternTerm(#env, cterm⟦ ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #term, #csort, #storage, #cont)
  → text⟦
      †⟨ForceParameter(#env, #term, #storage)⟩
      †⟨EValueClassName(#CONSTRUCTOR)⟩†⟨ResolveTypeParamCons(#csort)⟩ ⟨STRING: value:String⟩ = †⟨#term⟩.†⟨MethodNameAs(#CONSTRUCTOR)⟩(context);
      if (⟨STRING: value⟩ == null) {
        break †⟨JGetLabel(#env)⟩;
      }†⟨
      JavaPatternMaybeSubs(#env, #cterms?, text⟦⟨STRING: value⟩⟧, MaybeFindFormI(JGetDataSorts(#env), #csort, #CONSTRUCTOR), #cont)⟩⟧
//FindForm(Maybe<Core_csort_sort Option>((x) -> LookupDataSortDecl(JGetDataSorts(#env), x), #csort), #CONSTRUCTOR)

  // TODO: check literal
  rule JavaPatternTerm(#env, cterm⟦ ##cliteral ⟧, #term, #csort, #storage, #cont)
  → #cont(#env)

  // REVISIT: bound variable reordering, ie. (x)(y)#(y, x)
  // For now only accepts patterns of the form (x)...(y)#(x, ... y)
  rule JavaPatternTerm(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #term, #csort, #storage, #cont)
  → text⟦†⟨JavaPatternMaybeMetaArgs(#env, #METAVAR, #csubst?, #term, #csort, #cont)⟩⟧


  rule JavaPatternTerm(#env, cterm⟦ ##VARIABLE ⟧, #term, #csort, #storage, #cont)
  → JavaPatternVariable(JMaybeGetVar(#env, #VARIABLE), #env, #VARIABLE, #term, #cont)

  rule JavaPatternTerm(#env, cterm⟦ [ v ##csortanno?[] ] ##cterm[v] ⟧, #term, #csort, PARAMETER, #cont)
  //rule JavaPatternTerm(#env, Core_cterm_A6(#csortanno?:List<Core_csortanno_sort>, [x] -> #cterm[x]: Core_cterm_sort), #term, #csort, PARAMETER, #cont)
  → JavaPatternTerm(JNextParam(JAddVar(#env, var:String, JBound(#term, MaybeSortAnnoToSort(#csortanno?)))), #cterm[var], JCurrentParam(#env), SOME(JCurrentParamSort(#env)), PARAMETER, #cont)

  rule JavaPatternTerm(#env, cterm⟦ [ v ##csortanno?[v] ] ##cterm[v] ⟧, #term, #csort, ARGUMENT, #cont)
  //rule JavaPatternTerm(#env, Core_cterm_A6(#csortanno?:List<Core_csortanno_sort>, [x] -> #cterm[x]: Core_cterm_sort), #term,  #csort, ARGUMENT, #cont)
  → text⟦
      Variable ⟨STRING: boundvar:String⟩ = †⟨GetParent(#env)⟩.getVar†⟨NumberToText(GetSubIndex(#env))⟩_†⟨NumberToText(GetSubBinderIndex(#env))⟩();†⟨
      JavaPatternTerm(IncSubBinderIndex(JAddVar(#env, var:String, JBound(text⟦⟨STRING: boundvar⟩⟧, MaybeSortAnnoToSort(#csortanno?)))), #cterm[var], #term, #csort, ARGUMENT, #cont)⟩⟧

  //rule JavaPatternTerm(#env, cterm⟦ ( ##VARIABLE ##csortanno? ) ##cterm ⟧, #term, #storage, #cont)
  //rule JavaPatternTerm(#env, Core_cterm_A7(#csortanno?:List<Core_csortanno_sort>, [x] -> #cterm[x]: Core_cterm_sort), #term, #csort, #storage, #cont)
  rule JavaPatternTerm(#env, cterm⟦ ( f ##csortanno?[] ) ##cterm[f] ⟧, #term, #csort, #storage, #cont)
  → JavaPatternTerm(#env, #cterm[var:String], #term, #csort, #storage, #cont)

// Pattern matching on construction arguments.
func JavaPatternMaybeSubs({String : JEnvEntry}, List<Core_cterms_sort>, Text4_text_sort, Option<Pair<Core_cdecl_sort Core_cform_sort>>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaPatternMaybeSubs(#env, cterms?⟦⟧, #term, #cform, #cont)
  → #cont(#env)

  rule JavaPatternMaybeSubs(#env, cterms?⟦()⟧, #term, #cform, #cont)
  → #cont(#env)

  rule JavaPatternMaybeSubs(#env, cterms?⟦ ( ##cterm* ) ⟧, #term, SOME(Pair<Core_cdecl_sort Core_cform_sort>::PairCons(#cdecl:Core_cdecl_sort, cform⟦ ##CONSTRUCTOR ( ##csort* ) ⟧)), #cont)
  → JavaPatternSubs(#env, #cterm*, #term, 1, SOME(#csort*), #cont)

  rule JavaPatternMaybeSubs(#env, cterms?⟦ ( ##cterm* ) ⟧, #term, NONE, #cont)
  → JavaPatternSubs(#env, #cterm*, #term, 1, NONE, #cont)

func JavaPatternSubs({String : JEnvEntry}, List<Core_cterm_sort>,
                     Text4_text_sort /* parent term */, Numeric /* Current subindex */, Option<List<Core_csort_sort>>, /* sub sorts, if known */
                     ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaPatternSubs(#env, cterm*⟦⟧,  #term, #index, #csort*, #cont)
  → #cont(#env)

  rule JavaPatternSubs(#env, cterm*⟦ ##cterm ##cterm* ⟧, #term, #index, #csort*, #cont)
  → text⟦
      †⟨MaybeSortToType(SubSort(#env, #cterm, #csort*))⟩ ⟨STRING: sub:String⟩ = †⟨#term⟩.getField†⟨FieldSuffix(#index)⟩(†⟨GetContext(#env)⟩, true);†⟨
      JavaPatternTerm(SetSubBinderIndex(SetParent(SetSubIndex(#env, #index), #term), 1),
                  #cterm, text⟦⟨STRING: sub⟩⟧, SubSort(#env, #cterm, #csort*), ARGUMENT,
                  (x) -> JavaPatternSubs(x, #cterm*, #term, NumberPlus(#index, 1), Maybe<List List>((x)->Tail<Core_csort_sort>(x), #csort*), #cont))⟩⟧


// --- Variable pattern matching outside of meta

func JavaPatternVariable(Option<JVarEntry>, {String : JEnvEntry}, String, Text4_text_sort /* Current term */, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // First variable occurrence: the term is a variable use.
  rule JavaPatternVariable(NONE, #env, #variable, #term, #cont)
  → text⟦
      Variable ⟨STRING: var:String⟩ = †⟨#term⟩.variable();†⟨#cont(JAddVar(#env, #variable, JFree(text⟦⟨STRING: var⟩⟧, NONE)))⟩⟧

  // JBound variable
  // TODO: update term's parent with evaluated term.
  // TODO: release acquired references.
  rule JavaPatternVariable(SOME(JVarEntry::JBound(#javavar:Text4_text_sort, #sort:Option<Core_csort_sort>)), #env, #variable, #term, #cont)
  → text⟦
      †⟨#term⟩ = force(context, †⟨#term⟩);
      if (!isVariableUse(†⟨#term⟩) || †⟨#javavar⟩ != †⟨#term⟩.variable()) {
        break †⟨JGetLabel(#env)⟩;
      }†⟨#cont(#env)⟩⟧

// --- pattern matching inside meta

// Iterate over meta arguments and find corresponding bound variables, and update environment
func JavaPatternMaybeMetaArgs({String : JEnvEntry}, String, List<Core_csubst_sort>, Text4_text_sort /* Current term */, Option<Core_csort_sort>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaPatternMaybeMetaArgs(#env, #metavar, csubst?⟦⟧, #term, #csort, #cont)
  → #cont(JAddMeta(#env, #metavar, #term, ()))

  // meta substitution
  rule JavaPatternMaybeMetaArgs(#env, #metavar, csubst?⟦ [ ##cterm* ] ⟧, #term, #csort, #cont)
  → #cont(JAddMeta(#env, #metavar, #term, Map<Core_cterm_sort Text4_text_sort>((x) -> JavaFindJBoundVar(#env, x), #cterm*)))

func JavaFindJBoundVar({String : JEnvEntry}, Core_cterm_sort) -> Text4_text_sort

  rule JavaFindJBoundVar(#env, cterm⟦ ##VARIABLE ⟧)
  → JGetVar(#env, #VARIABLE)

// Interpreter does not handle Fallback
//-(Fallback):
//JavaFindJBoundVar(#env, #cterm)
//→ $(Error, $(:, "Invalid argument in metavariable: ", $(Show, #cterm)))

//  --------- Helper function for pattern matching

/* Generate force call if term is a parameter */
func ForceParameter({String : JEnvEntry}, Text4_text_sort, Storage) -> Text4_text_sort
  rule ForceParameter(#env, #term, PARAMETER) →  text⟦†⟨#term⟩ = force(†⟨GetContext(#env)⟩, †⟨#term⟩);⟧
  rule ForceParameter(#env, #term, #storage)  →  text⟦⟧

/* Extract type parameter from constructor sort */
func ResolveTypeParamCons(Option<Core_csort_sort>) -> Text4_text_sort
  rule ResolveTypeParamCons(NONE)
  → text⟦⟧

  rule ResolveTypeParamCons(SOME(csort⟦ ##CONSTRUCTOR ##csorts? ⟧))
  → MaybeSortsToTypeParams(#csorts?)

  rule ResolveTypeParamCons(SOME(#:Core_csort_sort))
  → text⟦⟧

/* Get sub sort. Get it from term and if not available on sort */
func SubSort({String : JEnvEntry}, Core_cterm_sort, Option<List<Core_csort_sort>>) -> Option<Core_csort_sort>
rule SubSort(#env, #cterm, #csorts?)
→ SubSort2(SubSortFromTerm(#env, #cterm), #csorts?)

func SubSort2(Option<Core_csort_sort>, Option<List<Core_csort_sort>>) -> Option<Core_csort_sort>
rule SubSort2(SOME(#csort:Core_csort_sort), #)       → SOME(#csort)
rule SubSort2(NONE, NONE)                            → NONE
rule SubSort2(NONE, SOME(csort*⟦ ##csort ##csort* ⟧)) → SOME(#csort)

// TODO: enable when fixing issue #19
//rule SubSort2(NONE, SOME(csort*⟦ ⟧))                  → Error<Option>("Error: could not find type for sub term.")

func SubSortFromTerm({String : JEnvEntry}, Core_cterm_sort) -> Option<Core_csort_sort>

  // TODO: support for multiple sort qualifiers
  rule SubSortFromTerm(#env, cterm⟦ ##csort :: ##csortqualifier* ##CONSTRUCTOR ##csortargs?  ##cterms? ##csortanno? ⟧)
  → SOME(#csort)

  rule SubSortFromTerm(#env, cterm⟦ ##CONSTRUCTOR ##csortargs?  ##cterms? ##csortanno? ⟧)
  → NONE

  rule SubSortFromTerm(#env, cterm⟦ ##STRING ⟧)
  → SOME(csort⟦ String ⟧)

  rule SubSortFromTerm(#env, cterm⟦ ##NUMBER ⟧)
  → SOME(csort⟦ Numeric⟧)

  rule SubSortFromTerm(#env, cterm⟦ ##VARIABLE ⟧)
  → SubSortFromVar(JMaybeGetVar(#env, #VARIABLE), #VARIABLE)

  rule SubSortFromTerm(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧)
  → MaybeSortAnnoToSort(#csortanno?)

  // TODO: maybe error?
  rule SubSortFromTerm(#env, cterm⟦ [ x ##csortanno?[] ] ##cterm[x] ⟧)
  //rule SubSortFromTerm(#env, Core_cterm_A6(#csortanno?:List<Core_csortanno_sort>, [x] -> #cterm[x] : Core_cterm_sort))
  → SubSortFromTerm(#env, #cterm[var:String])

  // TODO: maybe error?
  rule SubSortFromTerm(#env, cterm⟦ ( f ##csortanno?[] ) ##cterm[f] ⟧)
  //rule SubSortFromTerm(#env, Core_cterm_A7(#csortanno?:List<Core_csortanno_sort>, [x] -> #cterm[x] : Core_cterm_sort))
  → SubSortFromTerm(#env, #cterm[var:String])

func SubSortFromVar(Option<JVarEntry>, String) -> Option<Core_csort_sort>

  rule SubSortFromVar(NONE, #var)
  → NONE

  rule SubSortFromVar(SOME(#varEntry:JVarEntry), #var)
  → UnJVarSort(#varEntry)

// ----- Contraction

func JavaContractum({String : JEnvEntry}, Core_cterm_sort) -> Text4_text_sort
rule JavaContractum(#env, #term)
→ JavaStatementTerm(#env, #term)

func JavaStatementTerm({String : JEnvEntry}, Core_cterm_sort) -> Text4_text_sort
rule JavaStatementTerm(#env, #cterm)
→ text⟦†⟨JavaJFreshesTerm(SetCounter(#env, 0), #cterm, (env) ->
     text⟦†⟨If<Text4_text_sort>(JGetTail(env), ()->text⟦return ⟧, ()->text⟦⟧)⟩†⟨JavaExprTerm(SetCounter(env, 0), #cterm, (env) -> text⟦⟧)⟩;⟧)⟩⟧

// ---- Generate fresh variable - Only in Java statement mode

func JavaJFreshesTerm({String : JEnvEntry}, Core_cterm_sort, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaJFreshesTerm(#env, cterm⟦ ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #cont)
  → JavaJFreshesMaybeTerms(#env, #cterms?, #cont)

  rule JavaJFreshesTerm(#env, cterm⟦ ##cliteral ⟧, #cont)
  → #cont(#env)

  rule JavaJFreshesTerm(#env, cterm⟦ ##VARIABLE ##csortanno? ⟧, #cont)
  → JavaJFreshesVariable(#env, JMaybeGetVar(#env, #VARIABLE), #VARIABLE, #csortanno?, #cont)

  rule JavaJFreshesTerm(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #cont)
  → JavaJFreshesMaybeTerms(#env, #cterms?, (env) -> JavaJFreshesMaybeSubst(env, #csubst?, #cont))

//  rule JavaJFreshesTerm(#env, Core_cterm_A6(#csortanno?:List<Core_csortanno_sort>, [x] -> #cterm[x]:Core_cterm_sort), #cont)
  rule JavaJFreshesTerm(#env, cterm⟦ [ x ##csortanno?[] ] ##cterm[x] ⟧, #cont)
  → JavaJFreshesVariable(#env, NONE, var:String, #csortanno?, (env) -> JavaJFreshesTerm(env, #cterm[var], #cont))

  //→ text⟦
  //Variable fresh†⟨NumberToText(GetCounter(#env))⟩ = context.makeVariable("x");†⟨JavaJFreshesTerm(IncCounter(JAddVar(#env, var:Core_cterm_sort, JFresh(text⟦fresh†⟨NumberToText(GetCounter(#env))⟩⟧, MaybeSortAnnoToSort(#csortanno?)))), #cterm[var], #cont)⟩⟧

  // TODO: track var to avoid generating dummy fresh variables
  //rule JavaJFreshesTerm(#env, Core_cterm_A7(#csortanno?:List<Core_csortanno_sort>, [x] -> #cterm[x]:Core_cterm_sort), #cont)
  rule JavaJFreshesTerm(#env, cterm⟦ ( f ##csortanno?[] ) ##cterm[f] ⟧, #cont)
  → JavaJFreshesTerm(#env, #cterm[var:String], #cont)

  rule JavaJFreshesTerm(#env, cterm⟦ thunk ##cterm ⟧, #cont)
  → JavaJFreshesTerm(#env, #cterm, #cont)

func JavaJFreshesMaybeTerms({String : JEnvEntry}, List<Core_cterms_sort>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaJFreshesMaybeTerms(#env, cterms?⟦⟧, #cont)
  → #cont(#env)

  rule JavaJFreshesMaybeTerms(#env, cterms?⟦ () ⟧, #cont)
  → #cont(#env)

  rule JavaJFreshesMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧, #cont)
  → JavaJFreshesTerms(#env, #cterm*, #cont)

func JavaJFreshesTerms({String : JEnvEntry}, List<Core_cterm_sort>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort
  rule JavaJFreshesTerms(#env, cterm*⟦⟧, #cont)
  → #cont(#env)

  rule JavaJFreshesTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, #cont)
  → JavaJFreshesTerm(#env, #cterm, (env) -> JavaJFreshesTerms(env, #cterm*, #cont))

func JavaJFreshesMaybeSubst({String : JEnvEntry}, List<Core_csubst_sort>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort
  rule JavaJFreshesMaybeSubst(#env, csubst?⟦⟧, #cont)
  → #cont(#env)

  rule JavaJFreshesMaybeSubst(#env, csubst?⟦ [ ##cterm* ] ⟧, #cont)
  → JavaJFreshesTerms(#env, #cterm*, #cont)

func JavaJFreshesVariable({String : JEnvEntry}, Option<JVarEntry>, String, List<Core_csortanno_sort>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // untyped fresh var
  rule JavaJFreshesVariable(#env, NONE, #var, csortanno?⟦  ⟧, #cont)
  → text⟦
      VarStringTerm fresh†⟨NumberToText(GetCounter(#env))⟩ = varStringTerm(†⟨GetContext(#env)⟩, †⟨Text-QuoteEscape(Show<String>(#var))⟩);†⟨
        #cont(IncCounter(JAddVar(#env, #var, JFresh(text⟦fresh†⟨NumberToText(GetCounter(#env))⟩⟧, NONE))))⟩⟧

  // New typed fresh variable
  rule JavaJFreshesVariable(#env, NONE, #var, csortanno?⟦ : ##csort ⟧, #cont)
  → text⟦
      Var†⟨SortToType(#csort)⟩ fresh†⟨NumberToText(GetCounter(#env))⟩ = var†⟨SortToType(#csort)⟩(†⟨GetContext(#env)⟩, †⟨Text-QuoteEscape(Show<String>(#var))⟩);⟨
        #cont(IncCounter(JAddVar(#env, #var, JFresh(text⟦fresh†⟨NumberToText(GetCounter(#env))⟩⟧, SOME(#csort)))))⟩⟧

  // Variable already exists
  rule JavaJFreshesVariable(#env, SOME(#:JVarEntry), #var, #csortanno?, #cont)
  → #cont(#env)

// ---- Generate term code - Java expression mode

func JavaExprTerm({String : JEnvEntry}, Core_cterm_sort, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaExprTerm(#env, cterm⟦ ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #cont)
  → JavaExprConstruction(#env, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #cont)

  rule JavaExprTerm(#env, cterm⟦ ##cliteral ⟧, #cont)
  → text⟦
      †⟨Literal(#cliteral)⟩†⟨#cont(#env)⟩⟧

  rule JavaExprTerm(#env, cterm⟦ ##VARIABLE ##csortanno? ⟧, #cont)
  → JavaExprMaybeVar(#env, JMaybeGetVar(#env, #VARIABLE), #VARIABLE, #cont)

  rule JavaExprTerm(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #cont)
  → JavaExprMeta(#env, #METAVAR, #cterms?, #csubst?, #cont)

  rule JavaExprTerm(#env, cterm⟦ [ x ##csortanno?[] ] ##cterm[x] ⟧, #cont)
  //rule JavaExprTerm(#env, Core_cterm_A6(#csortanno?:List<Core_csortanno_sort>, [x] -> #cterm[x] : Core_cterm_sort), #cont)
  → text⟦
      fresh†⟨NumberToText(GetCounter(#env))⟩, †⟨JavaExprTerm(JAddVar(IncCounter(#env), var:String, JFresh(text⟦fresh†⟨NumberToText(GetCounter(#env))⟩⟧, MaybeSortAnnoToSort(#csortanno?))), #cterm[var], #cont)⟩⟧

  rule JavaExprTerm(#env, cterm⟦ ( f ##csortanno?[] ) ##cterm[f] ⟧, #cont)
  //rule JavaExprTerm(#env, Core_cterm_A7(#csortanno?:List<Core_csortanno_sort>, [x] -> #cterm[x] : Core_cterm_sort), #cont)
  → text⟦newClosure((†⟨GetContext(NewContext(#env))⟩†⟨JavaExprLambda(NewContext(#env), Core_cterm_A7(#csortanno?, [y:String] -> #cterm[y]), #cont)⟩⟧

  rule JavaExprTerm(#env, cterm⟦ thunk ##cterm ⟧, #cont)
  → text⟦thunk(†⟨GetContext(NewContext(#env))⟩ -> ⟨JavaExprTerm(NewContext(#env), #cterm, (env) -> text⟦)⟨#cont(env)⟩⟧)⟩⟧


// ---- construction expression

func JavaExprConstruction({String : JEnvEntry}, String,  List<Core_csortargs_sort>, List<Core_cterms_sort>, List<Core_csortanno_sort>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaExprConstruction(#env, #constructor, #csortargs?, #cterms?, #csortanno?, #cont)
  → text⟦⟨STRING: ToJavaMethodName(#constructor)⟩(context†⟨JavaExprThunkArgs(#csortargs?)⟩†⟨JavaExprMaybeTerms(#env, #cterms?, #cont)⟩⟧

func JavaExprMaybeTerms({String : JEnvEntry}, List<Core_cterms_sort>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaExprMaybeTerms(#env, cterms?⟦⟧, #cont)
  → text⟦)†⟨#cont(#env)⟩⟧

  rule JavaExprMaybeTerms(#env, cterms?⟦()⟧, #cont)
  → text⟦)†⟨#cont(#env)⟩⟧

  rule JavaExprMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧, #cont)
  → JavaExprTerms(#env, #cterm*, #cont)

func JavaExprTerms({String : JEnvEntry}, List<Core_cterm_sort>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort
  rule JavaExprTerms(#env, cterm*⟦⟧, #cont)
  → text⟦)†⟨#cont(#env)⟩⟧

  rule JavaExprTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, #cont)
  → text⟦, †⟨JavaExprTerm(#env, #cterm, (env) -> JavaExprTerms(env, #cterm*, #cont))⟩⟧


func JavaExprThunkArgs(List<Core_csortargs_sort>) -> Text4_text_sort
  rule JavaExprThunkArgs(csortargs?⟦              ⟧) → text⟦⟧
  rule JavaExprThunkArgs(csortargs?⟦ < ##csort* > ⟧) → TextFold(Map<Core_csort_sort Text4_text_sort>((x)->JavaExprThunkArg(x), #csort*), text⟦⟧)

func JavaExprThunkArg(Core_csort_sort) -> Text4_text_sort
  rule JavaExprThunkArg(csort⟦ ##VARIABLE ⟧) → text⟦, tm⟨STRING: #VARIABLE⟩⟧
  rule JavaExprThunkArg(csort⟦ ##csort    ⟧) → text⟦, †⟨ThunkMaker(#csort)⟩Maker()⟧

// --- Variable

func JavaExprMaybeVar({String : JEnvEntry}, Option<JVarEntry>, String, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaExprMaybeVar(#env, NONE, #svar, #cont) // JFresh variable must have been declared
  → #cont(#env)

  rule JavaExprMaybeVar(#env, SOME(JVarEntry::JFormal(#var:Text4_text_sort, #type:Option<Core_csort_sort>)), #svar, #cont)
  → text⟦†⟨#var⟩†⟨#cont(#env)⟩⟧

  // fallback
  rule JavaExprMaybeVar(#env, SOME(#varEntry:JVarEntry), #svar, #cont)
  → text⟦†⟨UnJVarVar(#varEntry)⟩.use()†⟨#cont(#env)⟩⟧

// ----  metavar expression

func JavaExprMeta({String : JEnvEntry}, String, List<Core_cterms_sort>, List<Core_csubst_sort>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

   // TODO: check that metavar is defined

  // No arguments -> just return the metavariable.
  rule JavaExprMeta(#env, #metavar, cterms?⟦⟧, csubst?⟦⟧, #cont)
  → text⟦†⟨JGetMetaVar(#env, #metavar)⟩†⟨#cont(#env)⟩⟧

  // No arguments in parenthesis -> call lambda with no param.
  rule JavaExprMeta(#env, #metavar, cterms?⟦ () ⟧, csubst?⟦⟧, #cont)
  → text⟦†⟨JGetMetaVar(#env, #metavar)⟩.eval(context)†⟨#cont(#env)⟩⟧

  // Apply arguments -> call lambda
  rule JavaExprMeta(#env, #metavar, cterms?⟦ ( ##cterm* ) ⟧, csubst?⟦⟧, #cont)
  → text⟦†⟨JGetMetaVar(#env, #metavar)⟩.eval(context†⟨JavaExprTerms(#env, #cterm*, #cont)⟩⟧

  // Substitution
  rule JavaExprMeta(#env, #metavar, cterms?⟦⟧, csubst?⟦ [ ##cterm* ] ⟧, #cont)
  → text⟦subst(context, †⟨JGetMetaVar(#env, #metavar)⟩†⟨JavaExprMetaArgs(#env, JGetMetaArgs(#env, #metavar), #cterm*, #cont)⟩⟧

  // TODO: call and subsitution

func JavaExprMetaArgs({String : JEnvEntry}, List<Text4_text_sort> /* pattern args */, List<Core_cterm_sort> /* contraction args */,
                     ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaExprMetaArgs(#env, (), #args,  #cont)
  → text⟦)†⟨#cont(#env)⟩⟧

  rule JavaExprMetaArgs(#env, Cons(#binder:Text4_text_sort,  #binders: List<Text4_text_sort>), Cons(#arg:Core_cterm_sort, #args:List<Core_cterm_sort>), #cont)
  → text⟦,†⟨#binder⟩,†⟨JavaExprTerm(#env, #arg, (env) -> JavaExprMetaArgs(env, #binders, #args, #cont))⟩⟧

// ---- lambda expression

func JavaExprLambda({String : JEnvEntry}, Core_cterm_sort, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaExprLambda(#env, Core_cterm_A7(#csortanno?:List<Core_csortanno_sort>, [x] -> #cterm[x]: Core_cterm_sort), #cont)
  → text⟦, p†⟨NumberToText(GetCounter(#env))⟩†⟨JavaExprLambda(JAddVar(IncCounter(#env), var:String, JFormal(text⟦p†⟨NumberToText(GetCounter(#env))⟩⟧, MaybeSortAnnoToSort(#csortanno?))), #cterm[var], #cont)⟩⟧

  // fallback
  rule JavaExprLambda(#env, #cterm, #cont)
  → text⟦) -> †⟨JavaExprTerm(#env, #cterm, (env) -> text⟦)†⟨#cont(env)⟩⟧)⟩⟧

//--- Find form in sort.
/*
func FindForm(Option<Option<Core_cdecl_sort>>, String) -> Option<Core_cform_sort>
  rule FindForm(NONE, #formname)
  → NONE

  rule FindForm(SOME(Option<Core_cdecl_sort>::NONE), #formname)
  → NONE

  rule FindForm(SOME(Option<Core_cdecl_sort>::SOME(cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧)), #formname)
  → PickFirst<Core_cform_sort>(#cform*, (x) -> MatchConsForm(x, #formname))
*/
// ----- initModule

/* Generate code initializing a module. */
func InitModule({ String : Core_cdecl_sort }, { String : Core_cdecl_sort }, List<Core_cqconstructor_sort>, Bool) -> Text4_text_sort

rule InitModule(#data, #func, #imports, #bootstrap)
→ text⟦
    private static boolean initialized = false;
    public static void init(Context context) {
      if (!initialized) {
        initialized = true;
        †⟨TextFold(Map<Core_cdecl_sort Text4_text_sort>((sort)->RegisterDataSort(sort), MapValues<String Core_cdecl_sort>(#data)), text⟦⟧)⟩
        †⟨TextFold(Map<Core_cqconstructor_sort Text4_text_sort>((qcons)->RegisterImport(qcons, #bootstrap),  #imports), text⟦⟧)⟩
      }
}⟧

func RegisterImport(#name: Core_cqconstructor_sort, #bootstrap: Bool) -> Text4_text_sort
→ text⟦
    †⟨PathToImport(QConsToString(#name, "::"), #bootstrap)⟩.init(context);⟧ // TODO: maybe use '.' sep

func RegisterDataSort(Core_cdecl_sort) -> Text4_text_sort
rule RegisterDataSort(cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧)
→ TextFold(Map<Core_cform_sort Text4_text_sort>((x) -> RegisterDataForm(x), #cform*), text⟦⟧)

func RegisterDataForm(Core_cform_sort) -> Text4_text_sort
  rule RegisterDataForm(cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
  → text⟦
  context.register(†⟨Text-QuoteEscape(#CONSTRUCTOR)⟩, †⟨EValueClassName(#CONSTRUCTOR)⟩::new);⟧

  rule RegisterDataForm(cform⟦ allows-variable ⟧)
  → text⟦⟧

/* Print package declaration */
func PackageDeclaration(#url: String, #mainurl: String, #package: String) -> Text4_text_sort
→ PackageDeclaration2(#package, Replace(RelativePath(#url, #mainurl), "/", "."))

func PackageDeclaration2(#base: String, #sub: String) -> Text4_text_sort
→ text⟦package ⟨STRING:#base⟩†⟨PackageDeclaration3(If<String>(StringEqual(Trim(#base), ""), ()->"", ()->"."), #sub)⟩;⟧

func PackageDeclaration3(#sep: String, #sub:String) -> Text4_text_sort
→ If<Text4_text_sort>(StringEqual(Trim(#sub), ""), ()->text⟦⟧, ()->text⟦⟨STRING:#sep⟩⟨STRING:#sub⟩⟧)

// --- Print java import. Treat Std:: as special (unless bootstrapping) All other prefixes are relative to javapackage

func PathToImport(#name: String, #bootstrap: Bool) -> Text4_text_sort
→ PathToImport2(If<String>(And(Not(#bootstrap), StartsWith(#name, "Std::")), ()->"org.transscript.compiler", ()->GetEnv("javabasepackage", "")),
                Map<String String>((s)->DownCaseFirst(s), Split(#name, "::")))

func PathToImport2(#basepkg: String , #path: List<String>) -> Text4_text_sort
→ If<Text4_text_sort>(StringEqual(#basepkg, ""),
    ()->JoinPath(#path),
    ()->text⟦†⟨StringToText(#basepkg)⟩.†⟨JoinPath(#path)⟩⟧)

/* Join path component together, making sure the last one starts with an upper case character */
func JoinPath(List<String>) -> Text4_text_sort
rule JoinPath((                               )) → text⟦⟧
rule JoinPath(Cons(#:String, List<String>::Nil)) → text⟦⟨STRING: UpCaseFirst(#)⟩⟧
rule JoinPath(Cons(#:String, #s: List<String> )) → text⟦⟨STRING: #⟩.†⟨JoinPath(#s)⟩⟧

// Print class name
func ClassName(String) -> String
rule ClassName(#name) → UpCaseFirst(AfterLast(BeforeLast(#name, "."), "/"))

/* Get the absolute name of the target java file */
@Extern func TargetJavaFilename(#input: String, #dest: String, #mainurl:String, #package: String) -> String

/* Get sub directory of `#module` relative to `#mainmodule` */
@Extern func RelativePath(#input: String, #mainurl:String) -> String

// --- Java printing helpers

// Print literal as a java string
func Literal(Core_cliteral_sort) -> Text4_text_sort
rule Literal(cliteral⟦ ##STRING ⟧) → text⟦stringTerm(†⟨Text-QuoteEscape(#STRING)⟩)⟧
rule Literal(cliteral⟦ ##NUMBER ⟧) → text⟦doubleTerm(⟨STRING: #NUMBER⟩)⟧

// Convert constructor to legal Java ID
func ToJavaId(String) -> Text4_text_sort
rule ToJavaId(#constructor) → Text-Mangle(UpCaseFirst(#constructor))

// Convert constructor to legal Java ID
func ToJavaIdString(String) -> Text4_text_sort
rule ToJavaIdString(#name) → Text-Mangle(#name)

// -- Java Code generation environment

// To change when upgrade to TS.

enum JVarEntry
  | JFree(Text4_text_sort /* Java var */, Option<Core_csort_sort>)
  | JBound(Text4_text_sort /* Java var */, Option<Core_csort_sort>)
  | JFresh(Text4_text_sort /* Java var */, Option<Core_csort_sort>)
  | JFormal(Text4_text_sort /* Java var */, Option<Core_csort_sort>)

enum JMetaEntry | JMetaVar(Text4_text_sort,       /* Java variable associated with the meta variable*/
                         List<Text4_text_sort>) /* Java variables associated to the meta variable bound variables */

enum JEnvEntry | JNum(Numeric) |  JText(Text4_text_sort) | JTexts(List<Text4_text_sort>) | JBool(Bool)
                  | JMapMeta({String : JMetaEntry})
                  | JMapVar({ String : JVarEntry }) | JMapDecl({ String : Core_cdecl_sort })
                  | JParams(List<Pair<Text4_text_sort Core_csort_sort>>)
                  | JContext(Text4_text_sort /* context java variable */, Numeric /* Counter */)
                  | JFnAnno(List<Core_canno_sort>)

func JNewEnv -> {String : JEnvEntry}
rule JNewEnv →
    MapPut<String JEnvEntry>(
    MapPut<String JEnvEntry>(
    MapPut<String JEnvEntry>(
    MapPut<String JEnvEntry>(
    MapPut<String JEnvEntry>(
    MapPut<String JEnvEntry>(
    MapPut<String JEnvEntry>(
    MapPut<String JEnvEntry>(
    MapPut<String JEnvEntry>(
    MapPut<String JEnvEntry>(
    MapPut<String JEnvEntry>(MapNew<String JEnvEntry>,
      "params"      , JParams(())),     /* Java method arguments. */
      "thunk"       , JTexts(())),     /* thunk arguments */
      "label"       , JText(text⟦⟧)),    /* Current pattern block label. */
      "tail"        , JBool(TRUE)),   /* Tail? */
      "meta"        , JMapMeta(MapNew<String JMetaEntry>)),  /* Map meta variable to java variables */
      "vars"        , JMapVar(MapNew<String JVarEntry>)),   /* Map variable to JVarEntry */
      "parent"      , JText(text⟦⟧)),    /* Sub parent (if any) */
      "subindex"    , JText(text⟦⟧)),    /* Sub index */
      "binderindex" , JNum(0)),         /* Current sub binder index */
      "binders"     , JTexts(())),    /* Binders list being constructed in contraction */
      "data"        , JTexts(()))    /* List of parameters marked as data */



// --- Helpers.

func JGetValue<a>({String : JEnvEntry}, String, (JEnvEntry) -> a) -> a
rule JGetValue(#env, #key, #unwrap)
→ #unwrap(UnSOME<JEnvEntry>(MapGet<String JEnvEntry>(#env, #key)))

func JSetValue({String : JEnvEntry}, String, JEnvEntry) -> {String : JEnvEntry}
rule JSetValue(#env, #key, #value)
→ MapPut<String JEnvEntry>(#env, #key, #value)

func UnJNum(JEnvEntry) -> Numeric
rule UnJNum(JNum(#)) → #

func UnJText(JEnvEntry) -> Text4_text_sort
rule UnJText(JText(#)) → #

func UnJTexts(JEnvEntry) -> List<Text4_text_sort>
rule UnJTexts(JTexts(#)) → #

func UnJParams(JEnvEntry) -> List<Pair<Text4_text_sort Core_csort_sort>>
rule UnJParams(JParams(#)) → #

func UnJBool(JEnvEntry) -> Bool
rule UnJBool(JBool(#)) → #

func UnJMapMeta(JEnvEntry) -> {String : JMetaEntry}
rule UnJMapMeta(JMapMeta(#)) → #

func UnJMapVar(JEnvEntry) -> { String : JVarEntry }
rule UnJMapVar(JMapVar(#)) → #

func UnJMapDecl(JEnvEntry) -> { String : Core_cdecl_sort }
rule UnJMapDecl(JMapDecl(#)) → #

func UnJVarVar(JVarEntry) -> Text4_text_sort
rule UnJVarVar(JBound(#1, #2)) → #1
rule UnJVarVar(JFree(#1, #2)) → #1
rule UnJVarVar(JFresh(#1, #2)) → #1
rule UnJVarVar(JFormal(#1, #2)) → #1

func UnJVarSort(JVarEntry) -> Option<Core_csort_sort>
rule UnJVarSort(JBound(#1, #2)) → #2
rule UnJVarSort(JFree(#1, #2)) → #2
rule UnJVarSort(JFresh(#1, #2)) → #2
rule UnJVarSort(JFormal(#1, #2)) → #2

func UnJMetaVar(JMetaEntry) -> Text4_text_sort
rule UnJMetaVar(JMetaVar(#1, #2)) → #1

func UnJMetaArgs(JMetaEntry) -> List<Text4_text_sort>
rule UnJMetaArgs(JMetaVar(#1, #2)) → #2

func UnJContext(JEnvEntry) -> Text4_text_sort
rule UnJContext(JContext(#1, #2)) → #1

func UnJContextCount(JEnvEntry) -> Numeric
rule UnJContextCount(JContext(#1, #2)) → #2

func UnJFnAnno(JEnvEntry) -> List<Core_canno_sort>
rule UnJFnAnno(JFnAnno(#1)) → #1

// --- Data sorts

func JGetDataSorts({String : JEnvEntry}) -> { String : Core_cdecl_sort }
rule JGetDataSorts(#env) → JGetValue<{ String : Core_cdecl_sort }>(#env, "datasorts", (x) -> UnJMapDecl(x))

func JSetDataSorts({String : JEnvEntry}, { String : Core_cdecl_sort }) -> {String : JEnvEntry}
rule JSetDataSorts(#env, #sorts) → JSetValue(#env, "datasorts", JMapDecl(#sorts))

func JIsDataSort({String : JEnvEntry}, String) -> Bool
rule JIsDataSort(#env, #cons) → HasOption<Core_cdecl_sort>(MapGet<String Core_cdecl_sort>(JGetDataSorts(#env), #cons))

// --- Function sorts

func JGetFuncSorts({String : JEnvEntry}) -> { String : Core_cdecl_sort }
rule JGetFuncSorts(#env) → JGetValue<{ String : Core_cdecl_sort }>(#env, "funcsorts", (x) -> UnJMapDecl(x))

func JSetFuncSorts({String : JEnvEntry}, { String : Core_cdecl_sort }) -> {String : JEnvEntry}
rule JSetFuncSorts(#env, #sorts) → JSetValue(#env, "funcsorts", JMapDecl(#sorts))

func JIsFuncSort({String : JEnvEntry}, String) -> Bool
rule JIsFuncSort(#env, #cons) → HasOption<Core_cdecl_sort>(MapGet<String Core_cdecl_sort>(JGetFuncSorts(#env), #cons))

// --- Top-level classname

func JGetClassname({String : JEnvEntry}) -> Text4_text_sort
rule JGetClassname(#env) → JGetValue<Text4_text_sort>(#env, "classname", (x) -> UnJText(x))

func JSetClassname({String : JEnvEntry}, Text4_text_sort) -> {String : JEnvEntry}
rule JSetClassname(#env, #classname) → JSetValue(#env, "classname", JText(#classname))

// --- Step method arguments

func JGetParams({String : JEnvEntry}) -> List<Pair<Text4_text_sort Core_csort_sort>>
rule JGetParams(#env) → JGetValue<List>(#env, "params", (x) -> UnJParams(x))

func JSetParams({String : JEnvEntry}, List<Pair<Text4_text_sort Core_csort_sort>>) -> {String : JEnvEntry}
rule JSetParams(#env, #params) → JSetValue(#env, "params",  JParams(#params))

func JAddParam({String : JEnvEntry}, Text4_text_sort, Core_csort_sort) -> {String : JEnvEntry}
rule JAddParam(#env, #param, #csort) → JSetValue(#env, "params", JParams(Append<Pair>(PairCons(#param, #csort), JGetParams(#env))))

// Move to the next parameter
func JNextParam({String : JEnvEntry}) -> {String : JEnvEntry}
rule JNextParam(#env) → JSetParams(#env, Tail<Pair>(JGetParams(#env)))

// Get the current parameter text
func JCurrentParam({String : JEnvEntry}) -> Text4_text_sort
rule JCurrentParam(#env) → Fst<Text4_text_sort Core_csort_sort>(Head<Pair>(JGetParams(#env)))

// Get the current parameter text
func JCurrentParamSort({String : JEnvEntry}) -> Core_csort_sort
rule JCurrentParamSort(#env) → Snd<Text4_text_sort Core_csort_sort>(Head<Pair>(JGetParams(#env)))

// --- Current method name

func JGetMethodName({String : JEnvEntry}) -> Text4_text_sort
rule JGetMethodName(#env) → JGetValue<Text4_text_sort>(#env, "methodname", (x) -> UnJText(x))

func JSetMethodName({String : JEnvEntry}, Text4_text_sort) -> {String : JEnvEntry}
rule JSetMethodName(#env, #name) → JSetValue(#env, "methodname", JText(#name))

// --- Thunk type

func JJGetThunkMaker({String : JEnvEntry}) -> Text4_text_sort
rule JJGetThunkMaker(#env) → JGetValue<Text4_text_sort>(#env, "thunkmaker", (x) -> UnJText(x))

func JJSetThunkMaker({String : JEnvEntry}, Text4_text_sort) -> {String : JEnvEntry}
rule JJSetThunkMaker(#env, #type) → JSetValue(#env, "thunkmaker", JText(#type))

// --- Thunk arguments

func JGetThunk({String : JEnvEntry}) -> List<Text4_text_sort>
rule JGetThunk(#env) → JGetValue<List>(#env, "thunk", (x) -> UnJTexts(x))

func JSetThunk({String : JEnvEntry}, List<Text4_text_sort>) -> {String : JEnvEntry}
rule JSetThunk(#env, #thunk) → JSetValue(#env, "thunk", JTexts(#thunk))

func JAddThunk({String : JEnvEntry}, Text4_text_sort) -> {String : JEnvEntry}
rule JAddThunk(#env, #thunk) → JSetValue(#env, "thunk", JTexts(Append<Text4_text_sort>(#thunk, JGetThunk(#env))))

// --- Rule case label

func JGetLabel({String : JEnvEntry}) -> Text4_text_sort
rule JGetLabel(#env) → JGetValue<Text4_text_sort>(#env, "label", (x) -> UnJText(x))

func JSetLabel({String : JEnvEntry}, Text4_text_sort) -> {String : JEnvEntry}
rule JSetLabel(#env, #label) → JSetValue(#env, "label", JText(#label))

// --- Tail mode.

func JGetTail({String : JEnvEntry}) -> Bool
rule JGetTail(#env) → JGetValue<Bool>(#env, "tail", (x) -> UnJBool(x))

func JSetTail({String : JEnvEntry}) -> {String : JEnvEntry}
rule JSetTail(#env) → JSetValue(#env, "tail", JBool(TRUE))

func JUnsetTail({String : JEnvEntry}) -> {String : JEnvEntry}
rule JUnsetTail(#env) → JSetValue(#env, "tail", JBool(FALSE))

// --- Meta

func JGetMetas({String : JEnvEntry}) -> {String : JMetaEntry}
rule JGetMetas(#env) → JGetValue<{String:JMetaEntry}>(#env, "meta", (x) -> UnJMapMeta(x))

func JGetMetaVar({String : JEnvEntry}, String) -> Text4_text_sort
rule JGetMetaVar(#env, #metavar) → UnJMetaVar(UnSOME<JMetaEntry>(MapGet<String JMetaEntry>(JGetMetas(#env), #metavar)))

func JGetMetaArgs({String : JEnvEntry}, String) -> List<Text4_text_sort>
rule JGetMetaArgs(#env, #metavar) → UnJMetaArgs(UnSOME<JMetaEntry>(MapGet<String JMetaEntry>(JGetMetas(#env), #metavar)))

func JAddMeta({String : JEnvEntry}, String, Text4_text_sort, List<Text4_text_sort>) -> {String : JEnvEntry}
rule JAddMeta(#env, #metavar, #term, #boundvars)
→ JSetValue(#env,  "meta", JMapMeta(MapPut<String JMetaEntry>(JGetMetas(#env), #metavar, JMetaVar(#term, #boundvars))))

// --- Variable

func JGetVars({String : JEnvEntry}) -> { String : JVarEntry }
rule JGetVars(#env) → JGetValue<{String:JVarEntry}>(#env, "vars", (x) -> UnJMapVar(x))

func JGetVar({String : JEnvEntry}, String) -> Text4_text_sort
rule JGetVar(#env, #var) → UnJVarVar(UnSOME<JVarEntry>(MapGetVar<String JVarEntry String>(JGetVars(#env), #var)))

func JMaybeGetVar({String : JEnvEntry}, String) -> Option<JVarEntry>
rule JMaybeGetVar(#env, #var) → MapGetVar<String JVarEntry String>(JGetVars(#env), #var)

func JAddVar({String : JEnvEntry}, String /* TODO: Core_cterm_sort */, JVarEntry) -> {String : JEnvEntry}
rule JAddVar(#env, #var, #entry)
→ JSetValue(#env, "vars", JMapVar(MapPutVar<String JVarEntry String>(JGetVars(#env), #var, #entry)))

// --- Parent term

func GetParent({String : JEnvEntry}) -> Text4_text_sort
rule GetParent(#env) → JGetValue<Text4_text_sort>(#env, "parent", (x) -> UnJText(x))

func SetParent({String : JEnvEntry}, Text4_text_sort) -> {String : JEnvEntry}
rule SetParent(#env, #parent)
→ JSetValue(#env, "parent",  JText(#parent))

// --- sub index

func GetSubIndex({String : JEnvEntry}) -> Numeric
rule GetSubIndex(#env) → JGetValue<Numeric>(#env, "subindex", (x) -> UnJNum(x))

func SetSubIndex({String : JEnvEntry}, Numeric) -> {String : JEnvEntry}
rule SetSubIndex(#env, #index)
→ JSetValue(#env, "subindex", JNum(#index))

// --- sub binder index

func GetSubBinderIndex({String : JEnvEntry}) -> Numeric
rule GetSubBinderIndex(#env) → JGetValue<Numeric>(#env, "binderindex", (x) -> UnJNum(x))

func SetSubBinderIndex({String : JEnvEntry}, Numeric) -> {String : JEnvEntry}
rule SetSubBinderIndex(#env, #index)
→ JSetValue(#env, "binderindex", JNum(#index))

func IncSubBinderIndex({String : JEnvEntry}) -> {String : JEnvEntry}
rule IncSubBinderIndex(#env)
→ JSetValue(#env, "binderindex", JNum(Plus(GetSubBinderIndex(#env), 1)))

// --- Binders

func GetBinders({String : JEnvEntry}) -> List<Text4_text_sort>
rule GetBinders(#env) → JGetValue<List>(#env, "binders", (x) -> UnJTexts(x))

func SetBinders({String : JEnvEntry}, List<Text4_text_sort>) -> {String : JEnvEntry}
rule SetBinders(#env, #binders) → JSetValue(#env, "binders", JTexts(#binders))

func AddBinder({String : JEnvEntry}, Text4_text_sort) -> {String : JEnvEntry}
rule AddBinder(#env, #binders) → JSetValue(#env, "binders", JTexts(Append<Text4_text_sort>(#binders, GetBinders(#env))))

// --- General purpose counter

func GetCounter({String : JEnvEntry}) -> Numeric
rule GetCounter(#env) → JGetValue<Numeric>(#env, "counter", (x) -> UnJNum(x))

func SetCounter({String : JEnvEntry}, Numeric) -> {String : JEnvEntry}
rule SetCounter(#env, #index)
→ JSetValue(#env, "counter", JNum(#index))

func IncCounter({String : JEnvEntry}) -> {String : JEnvEntry}
rule IncCounter(#env)
→ JSetValue(#env, "counter", JNum(Plus(GetCounter(#env), 1)))

// --- Parameters marked as data

func GetData({String : JEnvEntry}) -> List<Text4_text_sort>
rule GetData(#env) → JGetValue<List>(#env, "data", (x) -> UnJTexts(x))

func AddMaybeData({String : JEnvEntry}, Bool, Text4_text_sort) -> {String : JEnvEntry}
rule AddMaybeData(#env, FALSE, #term) → #env

rule AddMaybeData(#env, TRUE, #term)
→ JSetValue(#env, "data", JTexts(Append<Text4_text_sort>(#term, GetData(#env))))

// --- Context

func GetContext({String : JEnvEntry}) -> Text4_text_sort
rule GetContext(#env) → JGetValue<Text4_text_sort>(#env, "context", (x) -> UnJContext(x))

func GetContextCount({String : JEnvEntry}) -> Numeric
rule GetContextCount(#env) → JGetValue<Numeric>(#env, "context", (x) -> UnJContextCount(x))

func SetContext({String : JEnvEntry}, Text4_text_sort, Numeric) -> {String : JEnvEntry}
rule SetContext(#env, #context, #count) → JSetValue(#env, "context", JContext(#context, #count))

func NewContext({String : JEnvEntry}) -> {String : JEnvEntry}
rule NewContext(#env)
→ SetContext(#env, text⟦c†⟨NumberToText(GetContextCount(#env))⟩⟧, Plus(GetContextCount(#env), 1))

// --- function annotation

func GetFnAnno({String : JEnvEntry}) -> List<Core_canno_sort>
rule GetFnAnno(#env) → JGetValue<List>(#env, "fnanno", (x) -> UnJFnAnno(x))

func SetFnAnno({String : JEnvEntry}, List<Core_canno_sort>) -> {String : JEnvEntry}
rule SetFnAnno(#env, #anno*) → JSetValue(#env, "fnanno", JFnAnno(#anno*))
