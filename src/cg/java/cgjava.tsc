// Copyright (c) 2016 IBM Corporation.
/*
 * Tosca Java 8 backend code generator
 */
import std::core
import std::string
import std::num
import std::text
import std::listdef
import std::pairdef
import std::mapdef
import std::language
import std::text::Text4

import core::Core
import core::utils
import systemdef

// ===== API

/* Generates Java code for the given `#module` */
func ToJavaM(#system: TSystem, #module: Module) -> Result
→ ToJavaAux(#system, #module, TargetJavaFilename(GetModuleURL(#module), GetConfigDef(#system, "build-dir", ""),
    GetSystemURL(#system), GetConfigDef(#system, "package", "")))

func ToJavaAux(#system: TSystem, #module: Module, #source: String) -> Result
→ SaveResource("text", #source, text⟦
      /** Generated File */
      †⟨PackageDeclaration(GetModuleURL(#module), GetSystemURL(#system), GetConfigDef(#system, "package", ""))⟩

      import java.util.function.Function;

      import org.transscript.runtime.Context;
      import org.transscript.runtime.Term;
      import org.transscript.runtime.RefTerm;
      import org.transscript.runtime.Variable;
      import org.transscript.runtime.VariableUse;
      import org.transscript.runtime.LazyTerm;
      import org.transscript.runtime.StringTerm;
      import org.transscript.runtime.StringTerm.VarStringTerm;
      import org.transscript.runtime.DoubleTerm;
      import org.transscript.runtime.DoubleTerm.VarDoubleTerm;
      import org.transscript.runtime.AppendableTerm;
      import org.transscript.runtime.MapTerm;
      import static org.transscript.runtime.Ref.ref;
      import static org.transscript.runtime.Term.unbox;
      import static org.transscript.runtime.Term.force;
      import static org.transscript.runtime.Term.subst;
      import static org.transscript.runtime.Functions.*;
      import static org.transscript.runtime.StringTerm.lazyStringTerm;
      import static org.transscript.runtime.StringTerm.lazyStringTermMaker;
      import static org.transscript.runtime.StringTerm.stringTerm;
      import static org.transscript.runtime.StringTerm.varStringTerm;
      import static org.transscript.runtime.DoubleTerm.lazyDoubleTerm;
      import static org.transscript.runtime.DoubleTerm.lazyDoubleTermMaker;
      import static org.transscript.runtime.DoubleTerm.doubleTerm;
      import static org.transscript.runtime.MapTerm.lazyMapTerm;
      import static org.transscript.runtime.MapTerm.lazyMapTermMaker;
      import static org.transscript.runtime.AppendableTerm.appendableTerm;
      import static org.transscript.runtime.LazyTerm.thunk;

      †⟨JavaUnit(GetModuleURL(#module), GetImportsM(#module), GetRulesM(#module), GetDataSortsM(#module), GetFuncSortsM(#module), HasOption(GetConfig(#system, "bootstrap")))⟩
    ⟧,
    Success((#source,)))

// --- Translate module

/* Generate class for the given module */
func JavaUnit(#url: String, #imports: List<Core_cqidentifier_sort>, #rules: {String:List<Core_cdecl_sort>},
                #datasorts: {String:Core_cdecl_sort}, #funcsorts: {String: Core_cdecl_sort}, #bootstrap: Bool) -> Text4_text_sort
→ text⟦
     †⟨TextFoldES(Map((imp) -> JavaImport(imp, #bootstrap), #imports))⟩

     @SuppressWarnings("unused")
     public class ⟨STRING:ClassName(#url)⟩ {→
       †⟨TextMapFoldES((x)->EnumToClass(x, ClassName(#url)), MapValues(#datasorts))⟩
       †⟨TextMapFoldES((x)->JavaMethod(x, text⟦⟨STRING:ClassName(#url)⟩⟧, #rules, #datasorts, #funcsorts), MapKeys(#funcsorts))⟩
       †⟨InitModule(ClassName(#url), #datasorts, #funcsorts, #imports, #bootstrap)⟩
     ←}⟧

func JavaImport(#name: Core_cqidentifier_sort, #bootstrap: Bool) -> Text4_text_sort
→ text⟦
    import static †⟨PathToImport(JoinQIdentifier(#name, "::", TRUE), #bootstrap)⟩.*;⟧ // TODO: maybe use '.' separator

//-------------- Translate enumerations

/* Generate interfaces corresponding to the enum type */
func EnumToClass(Core_cdecl_sort, String) -> Text4_text_sort
rule EnumToClass(cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧, #classname)
→ text⟦

      †⟨TextMapFoldES((form)->FormToMethodNew(#CONSTRUCTOR, #csortvars?, form), #cform*)⟩

      static public †⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ ⟨STRING: Mangle(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ lazy⟨STRING: Mangle(#CONSTRUCTOR)⟩(Function<Context, ⟨STRING: Mangle(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩> function)
      {
        return new Lazy⟨STRING: Mangle(#CONSTRUCTOR)⟩(function);
      }

      static public †⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ ThunkMaker<⟨STRING: Mangle(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩> lazy⟨STRING: Mangle(#CONSTRUCTOR)⟩Maker()
      {
        return ⟨STRING: #classname⟩::lazy⟨STRING: Mangle(#CONSTRUCTOR)⟩;
      }

      public interface ⟨STRING: Mangle(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ extends Term
      {
        †⟨TextMapFoldES((form)->FormToMethodAs(#CONSTRUCTOR, #csortvars?, form), #cform*)⟩
      }

      †⟨TextMapFoldES((form) -> FormToImplValue(#CONSTRUCTOR, #csortvars?, form), #cform*)⟩

      static class Lazy⟨STRING: Mangle(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ extends LazyTerm<⟨STRING: Mangle(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩> implements ⟨STRING: Mangle(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩
      {

        protected Lazy⟨STRING: Mangle(#CONSTRUCTOR)⟩(⟨STRING: Mangle(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ value)
      	{
      		super(value);
      	}

        public Lazy⟨STRING: Mangle(#CONSTRUCTOR)⟩(Function<Context, ⟨STRING: Mangle(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩> function)
      	{
      		super(function);
      	}

        †⟨TextMapFoldES((form)->FormToMethodMemoAs(#CONSTRUCTOR, #csortvars?, form), #cform*)⟩

        @Override
      	public ⟨STRING: Mangle(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ copy(Context c)
      	{
      		return new Lazy⟨STRING: Mangle(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩(value);
      	}
      }⟧

// --- Generate a 'new' static method for each enum value */

// TODO: optimize constant value.
func FormToMethodNew(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text4_text_sort
  rule FormToMethodNew(#constructor, #csortvars?, cform⟦ ##CONSTRUCTOR ##csortsdefault? ⟧)
  → text⟦
      static public †⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ ⟨STRING: Mangle(#constructor)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ ⟨STRING: Mangle(#CONSTRUCTOR)⟩ (Context context†⟨JavaMaybeSortsToFormalParams(MaybeSortsDefaultToMaybeSorts(#csortsdefault?), text⟦, ⟧)⟩)
      {
        return new †⟨EValueClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩(†⟨MaybeSortsToArgs(MaybeSortsDefaultToMaybeSorts(#csortsdefault?))⟩);
      }⟧

  rule FormToMethodNew(#constructor, #csortvars?, cform⟦ allows-variable ⟧)
  → text⟦
       static public †⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ Var⟨STRING: Mangle(#constructor)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ ⟨STRING: Mangle(ConcatString("var", #constructor))⟩ (Context ctx, String hint)
       {
         return new Var⟨STRING: Mangle(#constructor)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩(ctx.makeGlobalName(hint));
       }⟧

// --- Generate a 'as' method for each enum value

func FormToMethodAs(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text4_text_sort
  rule FormToMethodAs(#enumname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csortsdefault? ⟧)
  → text⟦
       default †⟨EValueClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ †⟨MethodNameAs(#CONSTRUCTOR)⟩(Context context)
       {
         return null;
       }⟧

  rule FormToMethodAs(#enumname, #csortvars?, cform⟦ allows-variable ⟧)
  → text⟦
       default Var⟨STRING: Mangle(#enumname)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ variable()
       {
         return null;
       }⟧

func FormToMethodMemoAs(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text4_text_sort
  rule FormToMethodMemoAs(#enumname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csortsdefault? ⟧)
  → text⟦
   @Override
   final public †⟨EValueClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ †⟨MethodNameAs(#CONSTRUCTOR)⟩(Context context)
   {
     return eval(context).†⟨MethodNameAs(#CONSTRUCTOR)⟩(context);
   }⟧

 rule FormToMethodMemoAs(#enumname, #csortvars?, cform⟦ allows-variable ⟧)
 → text⟦⟧

func MethodNameAs(#formCons: String) -> Text4_text_sort
→ text⟦⟨STRING: Mangle(ConcatString("as", #formCons))⟩⟧

// --- Generate an static class for the enumeration value

func FormToImplValue(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text4_text_sort
  rule FormToImplValue(#typename, #csortvars?, cform⟦ ##CONSTRUCTOR ##csortsdefault? ⟧)
  → text⟦
      public static class †⟨EValueClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ extends RefTerm implements ⟨STRING: Mangle(#typename)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩
      {
          †⟨MaybeSortsToClassFields(MaybeSortsDefaultToMaybeSorts(#csortsdefault?))⟩

          †⟨MaybeSortsToDefaultConstructor(MaybeSortsDefaultToMaybeSorts(#csortsdefault?),  EValueClassName(#CONSTRUCTOR))⟩

          public †⟨EValueClassName(#CONSTRUCTOR)⟩(†⟨JavaMaybeSortsToFormalParams(MaybeSortsDefaultToMaybeSorts(#csortsdefault?), text⟦⟧)⟩)
          {
            †⟨MaybeSortsToInitFields(MaybeSortsDefaultToMaybeSorts(#csortsdefault?))⟩
          }

          @Override
          public †⟨EValueClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ †⟨MethodNameAs(#CONSTRUCTOR)⟩(Context context)
          {
            return this;
          }

          @Override
          public java.lang.String symbol()
          {
            return †⟨Text-QuoteEscape(#CONSTRUCTOR)⟩;
          }

          @Override
          public Term copy(Context c)
          {
            return new †⟨EValueClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩();
          }

          †⟨MaybeSortsToGetValue(MaybeSortsDefaultToMaybeSorts(#csortsdefault?))⟩
          †⟨MaybeSortsToGetSubs(MaybeSortsDefaultToMaybeSorts(#csortsdefault?))⟩
          †⟨MaybeSortsToSetSubs(MaybeSortsDefaultToMaybeSorts(#csortsdefault?))⟩
          †⟨MaybeSortsToGetBinder(MaybeSortsDefaultToMaybeSorts(#csortsdefault?))⟩
          †⟨MaybeSortsToSetBinder(MaybeSortsDefaultToMaybeSorts(#csortsdefault?))⟩

      }⟧

  rule FormToImplValue(#typename, #csortvars?, cform⟦ allows-variable ⟧)
  → text⟦
      static class Var⟨STRING: Mangle(#typename)⟩†⟨SortParamToTypeParam(#csortvars?, TRUE)⟩Use extends VariableUse implements ⟨STRING: Mangle(#typename)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩
      {
        public Var⟨STRING: Mangle(#typename)⟩Use(Variable var)
        {
          super(var);
        }

        public Var⟨STRING: Mangle(#typename)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ variable()
        {
          return (Var⟨STRING: Mangle(#typename)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩) super.variable();
        }

    }

    public static class Var⟨STRING: Mangle(#typename)⟩†⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ extends Variable
    {
      public Var⟨STRING: Mangle(#typename)⟩(String name)
      {
        super(name);
      }

      @Override
      protected Var⟨STRING: Mangle(#typename)⟩Use newVarUse()
      {
        return new Var⟨STRING: Mangle(#typename)⟩Use(this);
      }

      @Override
		  public Var⟨STRING: Mangle(#typename)⟩Use use()
		  {
			  return (Var⟨STRING: Mangle(#typename)⟩Use) super.use();
		  }

      @Override
      public Variable make(Context ctx, String hint)
  	  {
  		  return new Var⟨STRING: Mangle(#typename)⟩(ctx.makeGlobalName(hint));
  	  }

    }

    ⟧

//--- Default empty constructor

func MaybeSortsToDefaultConstructor(List<Core_csorts_sort>, Text4_text_sort) -> Text4_text_sort
rule MaybeSortsToDefaultConstructor(csorts?⟦              ⟧, #classname) → text⟦⟧
rule MaybeSortsToDefaultConstructor(csorts?⟦ ( ##csort* ) ⟧, #classname) → text⟦private †⟨#classname⟩() {}⟧

//--- Class fields

func MaybeSortsToClassFields(List<Core_csorts_sort>) -> Text4_text_sort
rule MaybeSortsToClassFields(csorts?⟦              ⟧) → text⟦⟧
rule MaybeSortsToClassFields(csorts?⟦ ( ##csort* ) ⟧) → text⟦ /* Form arguments */ †⟨SortsToClassFields(#csort*, 1)⟩⟧

func SortsToClassFields(List<Core_csort_sort>, Numeric) -> Text4_text_sort

  rule SortsToClassFields(csort*⟦                  ⟧, #index)
  → text⟦⟧

  rule SortsToClassFields(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦†⟨SortToClassFields(SortToTypes(#csort), #index, 1)⟩†⟨SortsToClassFields(#csort*, Plus(#index, 1))⟩⟧

func SortToClassFields(List<Text4_text_sort>, Numeric, Numeric) -> Text4_text_sort

  rule SortToClassFields(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex)
  → text⟦†⟨#type⟩ field†⟨FieldSuffix(#index)⟩;⟧

  rule SortToClassFields(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex)
  → text⟦
     †⟨#type⟩ var†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩;
     †⟨SortToClassFields(#types, #index, Plus(#subindex, 1))⟩⟧

//--- Class fields initialization

func MaybeSortsToInitFields(List<Core_csorts_sort>) -> Text4_text_sort
rule MaybeSortsToInitFields(csorts?⟦              ⟧) → text⟦⟧
rule MaybeSortsToInitFields(csorts?⟦ ( ##csort* ) ⟧) → SortsToInitFields(#csort*, 1)

func SortsToInitFields(List<Core_csort_sort>, Numeric) -> Text4_text_sort
  rule SortsToInitFields(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToInitFields(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦†⟨SortToInitFields(SortToTypes(#csort), #index, 1)⟩†⟨SortsToInitFields(#csort*, Plus(#index, 1))⟩⟧

func SortToInitFields(List<Text4_text_sort>, Numeric, Numeric) -> Text4_text_sort
  rule SortToInitFields(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex)
  → text⟦this.field†⟨FieldSuffix(#index)⟩ = param†⟨FieldSuffix(#index)⟩;⟧

  rule SortToInitFields(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex)
  → text⟦this.var†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩ = param†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩; †⟨SortToInitFields(#types, #index, Plus(#subindex, 1))⟩⟧

// --- sub function

func MaybeSortsToGetSubs(List<Core_csorts_sort>) -> Text4_text_sort
  rule MaybeSortsToGetSubs(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToGetSubs(csorts?⟦ ( ##csort* ) ⟧)
  → text⟦
      @Override
      public Term sub(int i) {
       switch (i) {
         †⟨SortsToGetSubs(#csort*, 0)⟩
         default: return null;
        }
      }⟧

func SortsToGetSubs(List<Core_csort_sort>, Numeric) -> Text4_text_sort

  rule SortsToGetSubs(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToGetSubs(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦†⟨SortToGetSubs(SortToTypes(#csort), #index, 0)⟩†⟨SortsToGetSubs(#csort*, Plus(#index, 1))⟩⟧

func SortToGetSubs(List<Text4_text_sort>, Numeric, Numeric) -> Text4_text_sort

  rule SortToGetSubs(Cons(#type, Nil), #index, #subindex)
  → text⟦case †⟨NumberToText(#index)⟩: return field†⟨FieldSuffix(Plus(#index, 1))⟩;⟧

  rule SortToGetSubs(Cons(#type, #types), #index, #subindex)
  → SortToGetSubs(#types, #index, Plus(#subindex, 1))

// --- SetSub function

func MaybeSortsToSetSubs(List<Core_csorts_sort>) -> Text4_text_sort
  rule MaybeSortsToSetSubs(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToSetSubs(csorts?⟦ ( ##csort* ) ⟧)
  → text⟦
      @Override
      public void setSub(int i, Term sub) {
        switch (i) {
             †⟨SortsToSetSubs(#csort*, 0)⟩
             default: throw new IndexOutOfBoundsException();
           }
         }⟧

func SortsToSetSubs(List<Core_csort_sort>, Numeric) -> Text4_text_sort
  rule SortsToSetSubs(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToSetSubs(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦†⟨SortToSetSubs(SortToTypes(#csort), #index, 0)⟩†⟨SortsToSetSubs(#csort*, Plus(#index, 1))⟩⟧

func SortToSetSubs(List<Text4_text_sort>, Numeric, Numeric) -> Text4_text_sort

  rule SortToSetSubs(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex)
  → text⟦
      case †⟨NumberToText(#index)⟩:
        field†⟨FieldSuffix(Plus(#index, 1))⟩ = (†⟨#type⟩) sub;
        break;⟧

  rule SortToSetSubs(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex)
  → SortToSetSubs(#types, #index, Plus(#subindex, 1))

// --- binder function

func MaybeSortsToGetBinder(List<Core_csorts_sort>) -> Text4_text_sort
  rule MaybeSortsToGetBinder(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToGetBinder(csorts?⟦ ( ##csort* ) ⟧)
  → If(HasBinders(#csort*),
      ()->text⟦
        @Override
        public Variable binder(int i, int j) {
          switch (i) {
            †⟨SortsToGetBinder(#csort*, 0)⟩
            default: return null;
          }
        }⟧,
      ()->text⟦⟧)

func SortsToGetBinder(List<Core_csort_sort>, Numeric) -> Text4_text_sort
  rule SortsToGetBinder(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToGetBinder(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦
      †⟨If(HasBindersSort(#csort),
        ()->text⟦
          case †⟨NumberToText(#index)⟩: {
            switch (j) {
              †⟨SortToGetBinder(SortToTypes(#csort), #index, 0)⟩
              default: return null;
            }
          }⟧,
        ()->text⟦⟧)⟩
      †⟨SortsToGetBinder(#csort*, Plus(#index, 1))⟩⟧

func SortToGetBinder(List<Text4_text_sort>, Numeric, Numeric) -> Text4_text_sort

  rule SortToGetBinder(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex)
  → text⟦⟧

  rule SortToGetBinder(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex)
  → text⟦
      case †⟨NumberToText(#subindex)⟩: return var†⟨NumberToText(Plus(#index, 1))⟩_†⟨NumberToText(Plus(#subindex, 1))⟩;
      †⟨SortToGetBinder(#types, #index, Plus(#subindex, 1))⟩⟧

// --- setBinder function

func MaybeSortsToSetBinder(List<Core_csorts_sort>) -> Text4_text_sort
  rule MaybeSortsToSetBinder(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToSetBinder(csorts?⟦ ( ##csort* ) ⟧)
  → If<Text4_text_sort>(HasBinders(#csort*),
      ()->text⟦
        @Override
        public void setBinder(int i, int j, Variable var) {
         switch (i) {
           †⟨SortsToSetBinder(#csort*, 0)⟩
           default: throw new IndexOutOfBoundsException();
          }
        }⟧,
      ()->text⟦⟧)

func SortsToSetBinder(List<Core_csort_sort>, Numeric) -> Text4_text_sort
  rule SortsToSetBinder(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToSetBinder(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦
      †⟨If<Text4_text_sort>(HasBindersSort(#csort),
        () -> text⟦
          case †⟨NumberToText(#index)⟩: {
            switch (j) {
              †⟨SortToSetBinder(SortToTypes(#csort), #index, 0)⟩
              default: throw new IndexOutOfBoundsException();
            }
            break;
          }⟧,
        () -> text⟦⟧)⟩
      †⟨SortsToSetBinder(#csort*, Plus(#index, 1))⟩⟧

func SortToSetBinder(List<Text4_text_sort>, Numeric, Numeric) -> Text4_text_sort

  rule SortToSetBinder(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex)
  → text⟦⟧

  rule SortToSetBinder(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex)
  → text⟦
      case †⟨NumberToText(#subindex)⟩:
        var†⟨NumberToText(Plus(#index, 1))⟩_†⟨NumberToText(Plus(#subindex, 1))⟩ = (†⟨#type⟩) var;
        break;
      †⟨SortToSetBinder(#types, #index, Plus(#subindex, 1))⟩⟧


//--- Sort to formal parameters

func JavaMaybeSortsToFormalParams(List<Core_csorts_sort>, Text4_text_sort) -> Text4_text_sort
  rule JavaMaybeSortsToFormalParams(csorts?⟦⟧, #sep)
  → text⟦⟧

  rule JavaMaybeSortsToFormalParams(csorts?⟦ ( ##csort*) ⟧, #sep)
  → JavaSortsToFormalParams(#csort*, 1, #sep)

func JavaSortsToFormalParams(List<Core_csort_sort>, Numeric, Text4_text_sort) -> Text4_text_sort
  rule JavaSortsToFormalParams(csort*⟦⟧, #index, #sep)
  → text⟦⟧

  rule JavaSortsToFormalParams(csort*⟦ ##csort ##csort* ⟧, #index, #sep)
  → text⟦†⟨#sep⟩†⟨JavaSortToFormalParams(SortToTypes(#csort), #index, 1)⟩†⟨JavaSortsToFormalParams(#csort*, Plus(#index, 1), text⟦, ⟧)⟩⟧

func JavaSortToFormalParams(List<Text4_text_sort>, Numeric, Numeric) -> Text4_text_sort
  rule JavaSortToFormalParams((#type,), #index, #subindex)
  → text⟦†⟨#type⟩ param†⟨FieldSuffix(#index)⟩⟧

  rule JavaSortToFormalParams((#type, #types...), #index, #subindex)
  → text⟦†⟨#type⟩ param†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩, †⟨JavaSortToFormalParams(#types, #index, Plus(#subindex, 1))⟩⟧

//--- Sort to function call arguments

func MaybeSortsToArgs(List<Core_csorts_sort>) -> Text4_text_sort
  rule MaybeSortsToArgs(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToArgs(csorts?⟦ ( ##csort*) ⟧)
  → SortsToArgs(#csort*, 1, text⟦⟧)

func SortsToArgs(List<Core_csort_sort>, Numeric, Text4_text_sort) -> Text4_text_sort
  rule SortsToArgs(csort*⟦⟧, #index, #sep)
  → text⟦⟧

  rule SortsToArgs(csort*⟦ ##csort ##csort* ⟧, #index, #sep)
  → text⟦†⟨#sep⟩†⟨SortToArgs(SortToTypes(#csort), #index, 1)⟩†⟨SortsToArgs(#csort*, Plus(#index, 1), text⟦, ⟧)⟩⟧

func SortToArgs(List<Text4_text_sort>, Numeric, Numeric) -> Text4_text_sort
  rule SortToArgs(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex)
  → text⟦param†⟨FieldSuffix(#index)⟩⟧

  rule SortToArgs(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex)
  → text⟦param†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩, †⟨SortToArgs(#types, #index, Plus(#subindex, 1))⟩⟧

//--- Get value method implementation

func MaybeSortsToGetValue(List<Core_csorts_sort>) -> Text4_text_sort
  rule MaybeSortsToGetValue(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToGetValue(csorts?⟦ ( ##csort* ) ⟧)
  → SortsToGetValue(#csort*, 1)

func SortsToGetValue(List<Core_csort_sort>, Numeric) -> Text4_text_sort
  rule SortsToGetValue(csort*⟦ ⟧, #index)
  → text⟦⟧

  rule SortsToGetValue(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦†⟨SortToGetValue(SortToTypes(#csort), #index, 1)⟩†⟨SortsToGetValue(#csort*, Plus(#index, 1))⟩⟧

func SortToGetValue(List<Text4_text_sort>, Numeric, Numeric) -> Text4_text_sort

  rule SortToGetValue((#type,), #index, #subindex)
  → text⟦public †⟨#type⟩ getField†⟨FieldSuffix(#index)⟩(Context ctx, boolean force) {
            if (force)
               field†⟨FieldSuffix(#index)⟩ = force(ctx, field†⟨FieldSuffix(#index)⟩);
            return field†⟨FieldSuffix(#index)⟩;
         }⟧

  rule SortToGetValue(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex)
  → text⟦public †⟨#type⟩ getVar†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩() {
           return var†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩;
        }
        †⟨SortToGetValue(#types, #index, Plus(#subindex, 1))⟩⟧

//--- Helpers

func FieldSuffix(Numeric) -> Text4_text_sort
  rule FieldSuffix(#index)
  → NumberToText(#index)

func MaybeSortsCount(List<Core_csorts_sort>) -> Numeric
  rule MaybeSortsCount(csorts?⟦⟧)             → 0
  rule MaybeSortsCount(csorts?⟦ (##csort*) ⟧) → ListLength(#csort*)

/** whether list of sorts has at least one binders */
func HasBinders(List<Core_csort_sort>) -> Bool
  rule HasBinders(csort*⟦⟧) → FALSE
  rule HasBinders(csort*⟦ ##csort ##csort* ⟧)
  → Or(HasBindersSort(#csort), HasBinders(#csort*))


/** Generate classname corresponding to an enumeration value */
func EValueClassName(String) -> Text4_text_sort
rule EValueClassName(#name) → text⟦_⟨STRING:Mangle(#name)⟩⟧

//--- Rename builtin types to avoid conflict with Java types

func FixupPrimitiveType(String) -> String
rule FixupPrimitiveType(#typename)
→ If(    StringEqual(#typename, "String"), ()->"StringTerm",
  ()->If(StringEqual(#typename, "Numeric"), ()->"DoubleTerm",
  ()->If(StringEqual(#typename, "Appendable"), ()->"AppendableTerm",
  ()->#typename)))


//---- Sort tranlation

func SortParamToTypeParam(List<Core_csortvars_sort>, Bool /* parameterize or parameterization? */) -> Text4_text_sort
  rule SortParamToTypeParam(csortvars?⟦ ⟧, #parameterize)
  → text⟦⟧

  rule SortParamToTypeParam(csortvars?⟦ ∀ ##VARIABLE+ . ⟧, #parameterize)
  → text⟦<†⟨TextFold(Map((x) -> text⟦⟨STRING: Mangle(x)⟩†⟨If(#parameterize, ()->text⟦ extends Term⟧, ()->text⟦⟧)⟩⟧, #VARIABLE+), text⟦, ⟧)⟩>⟧

func MaybeSortsToTypeParams(List<Core_csorts_sort>) -> Text4_text_sort
  rule MaybeSortsToTypeParams(csorts?⟦ ⟧)
  → text⟦⟧

  rule MaybeSortsToTypeParams(csorts?⟦ ( ##csort* )⟧)
  → text⟦<†⟨TextFold(Flatten(Map((x) -> SortToTypes(x), #csort*)), text⟦, ⟧)⟩>⟧

/** Convert sort annotation to equivalent Java type */
func MaybeSortAnnoToType(List<Core_csortanno_sort>) -> Text4_text_sort
  rule MaybeSortAnnoToType(csortanno?⟦ ⟧)
  → text⟦⟧

  rule MaybeSortAnnoToType(csortanno?⟦ : ##csort ⟧)
  → SortToType(#csort)

/* Translate Tosca sort to equivalent list of Java types:
 * a list of types corresponding to syntactic variable sorts and a type for the last sort
 * Eliminate aliases
 */
func SortToTypes(Core_csort_sort) -> List<Text4_text_sort>
rule SortToTypes(#csort) → SortToTypes2(#csort, ())

func SortToTypes2(Core_csort_sort, List<Text4_text_sort> /* formal params */) -> List<Text4_text_sort>

  rule SortToTypes2(csort⟦ ##CONSTRUCTOR ##csorts? ⟧, ())
  → Cons(text⟦⟨STRING: Mangle(FixupPrimitiveType(#CONSTRUCTOR))⟩†⟨MaybeSortsToTypeParams(#csorts?)⟩⟧, Nil)

  rule SortToTypes2(csort⟦ ##CONSTRUCTOR ##csorts? ⟧, Cons(#formal:Text4_text_sort, #formals:List<Text4_text_sort>))
  → Cons(text⟦Closure†⟨NumberToText(Plus(ListLength<Text4_text_sort>(#formals), 1))⟩<⟨STRING:
       Mangle(FixupPrimitiveType(#CONSTRUCTOR))⟩†⟨MaybeSortsToTypeParams(#csorts?) /* Return type */⟩, †⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* JFormal params */⟩>⟧, Nil)

  rule SortToTypes2(csort⟦ ##VARIABLE ⟧, ())
  → Cons(text⟦⟨STRING: Mangle(#VARIABLE)⟩⟧, Nil)

  rule SortToTypes2(csort⟦ ##VARIABLE ⟧, Cons(#formal:Text4_text_sort, #formals:List<Text4_text_sort>))
  → Cons(text⟦Closure†⟨NumberToText(Plus(ListLength(#formals), 1))⟩<⟨STRING: #VARIABLE /* Return type */⟩, †⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* JFormal params */⟩>⟧, Nil)

  rule SortToTypes2(csort⟦ [ ##csort ] ##csort2 ⟧, #formals)
  → Cons(text⟦Var†⟨SortToType(#csort)⟩⟧, SortToTypes2(#csort2, #formals))

  rule SortToTypes2(csort⟦ ( ##csort ) ##csort2 ⟧, #formals)
  → SortToTypes2(#csort2, Concat<Text4_text_sort>(#formals, SortToTypes(#csort)))

  rule SortToTypes2(csort⟦ { ##csort1 : ##csort2 } ⟧, ())
  → Cons(text⟦MapTerm<†⟨SortToType(#csort1)⟩,†⟨SortToType(#csort2)⟩>⟧, Nil)

  rule SortToTypes2(csort⟦ { ##cmapsort } ⟧, Cons(#formal:Text4_text_sort, #formals:List<Text4_text_sort>))
  → Cons(text⟦Closure†⟨NumberToText(Plus(ListLength(#formals), 1))⟩<MapTerm, †⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* JFormal params */⟩>⟧, Nil)

  rule SortToTypes2(csort⟦ data ##csort ⟧, #formals)
  → SortToTypes2(#csort, #formals)

  rule SortToTypes2(csort⟦ thunk ##csort ⟧, #formals)
  → Cons(text⟦Closure0<†⟨SortToType(#csort)⟩>⟧, Nil)

/* Same as above, expect ignore syntactic variables */
func SortToType(Core_csort_sort) -> Text4_text_sort
rule SortToType(#csort) → Last(SortToTypes(#csort)) // TODO: could optimize

/* Same as above, expect maybe get a sort */
func MaybeSortToType(Option<Core_csort_sort>) -> Text4_text_sort
rule MaybeSortToType(NONE)         → text⟦⟧
rule MaybeSortToType(SOME(#csort)) → Last(SortToTypes(#csort)) // TODO: could optimize

/* Same as above, expect with default value */
func MaybeSortToTypeD(Option<Core_csort_sort>, Text4_text_sort) -> Text4_text_sort
rule MaybeSortToTypeD(NONE        , #default) → #default
rule MaybeSortToTypeD(SOME(#csort), #default) → Last(SortToTypes(#csort)) // TODO: could optimize

/* Sort qualifier to type */
func SortQualifierToType(Core_csortqualifier_sort) -> Text4_text_sort
rule SortQualifierToType(csortqualifier⟦ ##csort :: ⟧) → SortToType(#csort)

//-------------- Translate functions and rules

/* Generate method for function. Start with method signature */
func JavaMethod(#constructor: String, #classname: Text4_text_sort, #rules: {String:List<Core_cdecl_sort>},
                  #datasorts: {String:Core_cdecl_sort}, #funcsorts:{String:Core_cdecl_sort}) -> Text4_text_sort
→ text⟦final public static †⟨
          JavaMethodSig(JSetDataSorts(JSetFuncSorts(JSetClassname(JNewEnv, #classname), #funcsorts), #datasorts),
                        UnSOME(MapGet(#funcsorts, #constructor)),
                        MapGet(#rules, #constructor))⟩⟧

func JavaMethodSig({String : JEnvEntry}, Core_cdecl_sort, Option<List<Core_cdecl_sort>>) -> Text4_text_sort
rule JavaMethodSig(#env, cdecl⟦ ##canno* ##EXTERN? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧, #rules)
→ text⟦†⟨ReturnType(#csortvars?, #csort)⟩⟨STRING:Mangle(#CONSTRUCTOR)⟩(Context context†⟨ThunkMakerSig(#csortvars?)⟩†⟨
      JavaSigMaybeArgs(
         JSetMethodName(
           JJSetThunkMaker(
             JAddThunk(
               SetContext(SetFnAnno(#env, #canno*), text⟦context⟧, 1),
               ThunkMakerArg(#csortvars?)),
             ThunkMaker(#csort)),
           text⟦⟨STRING: Mangle(#CONSTRUCTOR)⟩⟧), #csorts?, #rules)⟩⟧   // )

// --- Generate return type

func ReturnType(#csortvars?: List<Core_csortvars_sort>, #csort:Core_csort_sort) -> Text4_text_sort
→ text⟦†⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ †⟨TextFoldES(SortToTypes(#csort))⟩ ⟧

/* Since Java erases sort parameters at runtime, need to pass them along */
func ThunkMakerSig(List<Core_csortvars_sort>) -> Text4_text_sort
rule ThunkMakerSig(csortvars?⟦             ⟧)     → text⟦⟧
rule ThunkMakerSig(csortvars?⟦ ∀ ##VARIABLE+ . ⟧) → TextFold(Map((x)->ThunkMakerSigHelper(x), #VARIABLE+), text⟦⟧)

func ThunkMakerSigHelper(String) -> Text4_text_sort
rule ThunkMakerSigHelper(#) → text⟦, ThunkMaker<⟨STRING: #⟩> tm⟨STRING: #⟩⟧

/* Associated function generating thunk maker argument */
func ThunkMakerArg(List<Core_csortvars_sort>) -> Text4_text_sort
rule ThunkMakerArg(csortvars?⟦             ⟧) → text⟦⟧
rule ThunkMakerArg(csortvars?⟦ ∀ ##VARIABLE+ . ⟧) → TextFold(Map((x)->ThunkMakerArgHelper(x), #VARIABLE+), text⟦⟧)

func ThunkMakerArgHelper(String) -> Text4_text_sort
rule ThunkMakerArgHelper(#) → text⟦, tm⟨STRING: #⟩⟧

// --- Generate thunk type

func ThunkMaker(Core_csort_sort) -> Text4_text_sort

  rule ThunkMaker(csort⟦ ##CONSTRUCTOR ##csorts? ⟧)
  → text⟦lazy⟨STRING: Mangle(FixupPrimitiveType(#CONSTRUCTOR))⟩⟧

  rule ThunkMaker(csort⟦ ##VARIABLE ⟧) // polymorphic return type.
  → text⟦tm⟨STRING: #VARIABLE⟩.apply⟧

  rule ThunkMaker(csort⟦ [ ##csort ] ##csort2 ⟧)
  → Error<Text4_text_sort>("Internal error: a function cannot return scoped values")

  rule ThunkMaker(csort⟦ ( ##csort ) ##csort2 ⟧)
  → Error<Text4_text_sort>("Internal error: a function cannot return another function")

  // Java infers map types.
  rule ThunkMaker(csort⟦ { ##cmapsort } ⟧)
  → text⟦lazyMapTerm⟧

  rule ThunkMaker(csort⟦ data ##csort ⟧)
  → ThunkMaker(#csort)

  rule ThunkMaker(csort⟦ thunk ##csort ⟧)
  → ThunkMaker(#csort)

// --- Generate method signature

func JavaSigMaybeArgs({String : JEnvEntry}, List<Core_csorts_sort>, Option<List<Core_cdecl_sort>>) -> Text4_text_sort
  rule JavaSigMaybeArgs(#env, csorts?⟦⟧, #rules)
  → JavaBody(#env, #rules)

  rule JavaSigMaybeArgs(#env, csorts?⟦ ( ##csort* ) ⟧, #rules)
  → JavaSigArgs(#env, #csort*, #rules)

// Generate method signature and record the argument names in the environment, keeping them in order
func JavaSigArgs({String : JEnvEntry}, List<Core_csort_sort>, Option<List<Core_cdecl_sort>>) -> Text4_text_sort

  rule JavaSigArgs(#env, csort*⟦ ⟧, #rules)
  → JavaBody(#env, #rules)

  rule JavaSigArgs(#env, csort*⟦ ##csort ##csort* ⟧, #rules)
  → JavaSigArg(#env, #csort, FALSE, SortToTypes(#csort), #csort*, #rules)

func JavaSigArg({String : JEnvEntry}, Core_csort_sort, Bool /* data? */,
                List<Text4_text_sort> /* formal parameters */, List<Core_csort_sort>, Option<List<Core_cdecl_sort>>) -> Text4_text_sort

 // Monomorphic sort
   rule JavaSigArg(#env, csort⟦ ##CONSTRUCTOR ##csorts? ⟧, #data, (#type,), #csort*, #rules)
   → text⟦, †⟨#type⟩ ⟨STRING: value:String⟩†⟨
       JavaSigArgs(JAddThunk(JAddParam(#env, text⟦⟨STRING: value⟩⟧, csort⟦ ##CONSTRUCTOR ##csorts? ⟧), text⟦⟨STRING: value⟩⟧), #csort*, #rules)⟩⟧

   // Sort variable
   rule JavaSigArg(#env, csort⟦ ##VARIABLE ⟧, #data, (#type,), #csort*, #rules)
   → text⟦, †⟨#type⟩ ⟨STRING: value:String⟩†⟨
       JavaSigArgs(JAddThunk(JAddParam(#env, text⟦⟨STRING: value⟩⟧, csort⟦ ##VARIABLE ⟧), text⟦⟨STRING: value⟩⟧), #csort*, #rules)⟩⟧

   // Syntactic variable sort
   rule JavaSigArg(#env, csort⟦ [ ##csort ] ##csort2 ⟧, #data, (#type, #types...), #csort*, #rules)
   → text⟦, †⟨#type⟩ ⟨STRING: var:String⟩†⟨
       JavaSigArg(JAddThunk(JAddParam(#env, text⟦⟨STRING: var⟩⟧, #csort), text⟦⟨STRING: var⟩⟧), #csort2, #data, #types, #csort*, #rules)⟩⟧

   // Formal parameter sort
   rule JavaSigArg(#env, csort⟦ ( ##csort ) ##csort2 ⟧, #data, #types, #csort*, #rules)
   → JavaSigArg(#env, #csort2, #data, #types, #csort*, #rules)

   rule JavaSigArg(#env, csort⟦ { ##cmapsort* } ⟧, #data, (#type,), #csort*, #rules)
   → text⟦, †⟨#type⟩ ⟨STRING: map:String⟩†⟨
       JavaSigArgs(JAddThunk(JAddParam(#env, text⟦⟨STRING: map⟩⟧, csort⟦ { ##cmapsort* } ⟧), text⟦⟨STRING: map⟩⟧), #csort*, #rules)⟩⟧

   rule JavaSigArg(#env, csort⟦ data ##csort ⟧, #data, #types, #csort*, #rules)
   → JavaSigArg(#env, #csort, TRUE, #types, #csort*, #rules)

   rule JavaSigArg(#env, csort⟦ thunk ##csort ⟧, #data, #types, #csort*, #rules)
   → JavaSigArg(#env, #csort, #data, #types, #csort*, #rules)

// --- Generate method body

func JavaBody({String : JEnvEntry}, Option<List<Core_cdecl_sort>>) -> Text4_text_sort

  // No rules: it must be an external function (not yet checked but should)
  rule JavaBody(#env, NONE)
  → text⟦) {
        return †⟨JGetClassname(#env)⟩Extern.†⟨JGetMethodName(#env)⟩(context†⟨TextFold(JGetThunk(#env), text⟦, ⟧)⟩);
      }⟧

  // At least one rule: not external
  rule JavaBody(#env, SOME(#rules))
  → text⟦
    ) {
        †⟨TextMapFoldES((rule) -> /* Debug(PrintTerm("", rule), ()-> */ JavaBodyRule(JSetDiscard(#env, ()), rule) /* ) */, #rules)⟩
        †⟨FallbackThunk(#env, HasAnnotation("Fallback", GetFnAnno(#env)))⟩
      }⟧

/* Generate fallback thunk (or error) if function is not complete */
func FallbackThunk({String : JEnvEntry}, Bool) -> Text4_text_sort
rule FallbackThunk(#env, TRUE)  → text⟦⟧
rule FallbackThunk(#env, FALSE) → text⟦throw new RuntimeException("Missing case");⟧ // TODO: better error message.

// --- Start method body

func JavaBodyRule({String : JEnvEntry}, Core_cdecl_sort) -> Text4_text_sort

  rule JavaBodyRule(#env, cdecl⟦ ##canno* rule ##canno*2 ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##csortanno? → ##cterm ⟧)
  → JavaContractum(#env, #canno*, #cterm)

  rule JavaBodyRule(#env, cdecl⟦ ##canno* rule ##canno*2 ##csortqualifier* ##CONSTRUCTOR ##csortargs? ( ##cterm* ) ##csortanno? → ##cterm ⟧)
  → JavaPattern(#env, #cterm*, #canno*, #cterm)

// --- Pattern matching

func JavaPattern({String : JEnvEntry}, List<Core_cterm_sort>, List<Core_canno_sort>, Core_cterm_sort) -> Text4_text_sort

// TODO: case where there is only one rule.
rule JavaPattern(#env, #cterms, #ruleanno*, #contractum)
→ text⟦⟨STRING: label:String⟩:{†⟨JavaCasePattern(JSetLabel(#env, text⟦⟨STRING: label⟩⟧), #cterms, #ruleanno*, #contractum)⟩
}⟧

// Data sort helper indicating whether the current term is a method parameter, or an argument (local variable).
enum Storage | PARAMETER | ARGUMENT

// Iterate over top-level pattern arguments
func JavaCasePattern({String : JEnvEntry}, List<Core_cterm_sort>, List<Core_canno_sort>, Core_cterm_sort) -> Text4_text_sort

rule JavaCasePattern(#env, cterm*⟦ ⟧, #ruleanno*, #contractum)
→ JavaContractum(#env, #ruleanno*, #contractum)

rule JavaCasePattern(#env, cterm*⟦ ##cterm ##cterm* ⟧, #ruleanno*, #contractum)
→ JavaPatternTerm(JavaNextParam(JavaMayDiscard(#env, #cterm, #ruleanno*)), #cterm, JavaCurrentParam(#env), SOME(JavaCurrentParamSort(#env)), PARAMETER, (env) -> JavaCasePattern(env, #cterm*, #ruleanno*, #contractum))

// --- Term pattern matching

func JavaPatternTerm({String : JEnvEntry}, Core_cterm_sort, Text4_text_sort /* Current term */,
                     Option<Core_csort_sort> /* Sort when known */, Storage, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaPatternTerm(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #term, #csort, #storage, #cont)
  → text⟦
      †⟨EValueClassName(#CONSTRUCTOR)⟩†⟨ResolveTypeParamCons(#csort)⟩ ⟨STRING: value:String⟩ = †⟨#term⟩.†⟨MethodNameAs(#CONSTRUCTOR)⟩(context);
      if (⟨STRING: value⟩ == null)
        break †⟨JGetLabel(#env)⟩;
      †⟨
      JavaPatternMaybeSubs(#env, #cterms?, text⟦⟨STRING: value⟩⟧, MaybeFindFormI(JGetDataSorts(#env), #csort, #CONSTRUCTOR), #cont)⟩⟧

  // TODO: check literal
  rule JavaPatternTerm(#env, cterm⟦ ##canno* ##cliteral ⟧, #term, #csort, #storage, #cont)
  → #cont(#env)

  // REVISIT: bound variable reordering, ie. (x)(y)#(y, x)
  // For now only accepts patterns of the form (x)...(y)#(x, ... y)
  rule JavaPatternTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #term, #csort, #storage, #cont)
  → text⟦†⟨JavaPatternMaybeMetaArgs(#env, #canno*, #METAVAR, #csubst?, #term, #csort, #storage, #cont)⟩⟧

  rule JavaPatternTerm(#env, cterm⟦ ##canno* ##VARIABLE ##csortanno? ⟧, #term, #csort, #storage, #cont)
  → JavaPatternVariable(JGetVarO(#env, #VARIABLE), #env, #VARIABLE, MaybeSortAnnoToSort(#csortanno?), #term, #cont)

  rule JavaPatternTerm(#env, cterm⟦ ##canno* [ v ##csortanno? ] ##cterm[v] ⟧, #term, #csort, PARAMETER, #cont)
  → JavaPatternTerm(JavaNextParam(JAddVar(#env, var:String, JBound(#term, MaybeSortAnnoToSort(#csortanno?)))), #cterm[var], JavaCurrentParam(#env), SOME(JavaCurrentParamSort(#env)), PARAMETER, #cont)

  rule JavaPatternTerm(#env, cterm⟦ ##canno* [ v ##csortanno? ] ##cterm[v] ⟧, #term, #csort, ARGUMENT, #cont)
  → text⟦
      Variable ⟨STRING: boundvar:String⟩ = †⟨GetParent(#env)⟩.getVar†⟨NumberToText(GetSubIndex(#env))⟩_†⟨NumberToText(GetSubBinderIndex(#env))⟩();†⟨
      JavaPatternTerm(IncSubBinderIndex(JAddVar(#env, var:String, JBound(text⟦⟨STRING: boundvar⟩⟧, MaybeSortAnnoToSort(#csortanno?)))), #cterm[var], #term, #csort, ARGUMENT, #cont)⟩⟧

  rule JavaPatternTerm(#env, cterm⟦ ##canno* ( f ##csortanno? ) ##cterm[f] ⟧, #term, #csort, #storage, #cont)
  → JavaPatternTerm(#env, #cterm[var:String], #term, #csort, #storage, #cont)

  rule JavaPatternTerm(#env, cterm⟦ ##canno* { ##cmapentries? } : { ##cmapsort } ⟧, #term, #csort, #storage, #cont)
  → JavaPatternMap(#env, #cmapentries?, #term, #cmapsort, #cont)

  rule JavaPatternTerm(#env, cterm⟦ ##canno* ##METAVAR ##csortanno? = ##cterm ⟧, #term, #csort, #storage, #cont)
  → JavaPatternNamedTerm(#env, #canno*, #METAVAR, #cterm, #term, #csort, #storage, #cont)

  rule JavaPatternTerm(#env, #cterm, #term, #csort, #storage, #cont)
  → Error(ConcatString("Internal Error: could not handle pattern ", PrintTerm("", #cterm)))

// Pattern matching on construction arguments.
func JavaPatternMaybeSubs({String : JEnvEntry}, List<Core_cterms_sort>, Text4_text_sort, Option<PPair<Core_cdecl_sort Core_cform_sort>>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaPatternMaybeSubs(#env, cterms?⟦⟧, #term, #cform, #cont)
  → #cont(#env)

  rule JavaPatternMaybeSubs(#env, cterms?⟦()⟧, #term, #cform, #cont)
  → #cont(#env)

  rule JavaPatternMaybeSubs(#env, cterms?⟦ ( ##cterm* ) ⟧, #term, SOME(PairCons(#cdecl, cform⟦ ##CONSTRUCTOR ##csortsdefault? ⟧)), #cont)
  → JavaPatternSubs(#env, #cterm*, #term, 1, SOME(MaybeSortsDefaultToSorts(#csortsdefault?)), #cont)

  rule JavaPatternMaybeSubs(#env, cterms?⟦ ( ##cterm* ) ⟧, #term, NONE, #cont)
  → JavaPatternSubs(#env, #cterm*, #term, 1, NONE, #cont)

func JavaPatternSubs({String : JEnvEntry}, List<Core_cterm_sort>,
                     Text4_text_sort /* parent term */, Numeric /* Current subindex */, Option<List<Core_csort_sort>>, /* sub sorts, if known */
                     ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaPatternSubs(#env, cterm*⟦⟧,  #term, #index, #csort*, #cont)
  → #cont(#env)

  rule JavaPatternSubs(#env, cterm*⟦ ##cterm ##cterm* ⟧, #term, #index, #csort*, #cont)
  → text⟦
      †⟨MaybeSortToType(SubSort(#env, #cterm, #csort*))⟩ ⟨STRING: sub:String⟩ = †⟨#term⟩.getField†⟨FieldSuffix(#index)⟩(†⟨GetContext(#env)⟩, true);†⟨
      JavaPatternTerm(SetSubBinderIndex(SetParent(SetSubIndex(#env, #index), #term), 1),
                  #cterm, text⟦⟨STRING: sub⟩⟧, SubSort(#env, #cterm, #csort*), ARGUMENT,
                  (x) -> JavaPatternSubs(x, #cterm*, #term, NumberPlus(#index, 1), Maybe((x)->Tail(x), #csort*), #cont))⟩⟧


// --- Variable pattern matching outside of meta

func JavaPatternVariable(Option<JVarEntry>, {String : JEnvEntry}, String, Option<Core_csort_sort>, Text4_text_sort /* Current term */, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // First variable occurrence: free variable.
  rule JavaPatternVariable(NONE, #env, #variable, #csort, #term, #cont)
  → text⟦
      Var†⟨MaybeSortToTypeD(#csort, text⟦iable⟧)⟩ ⟨STRING: var:String⟩ = †⟨#term⟩.variable();
      if (⟨STRING: var⟩ == null)
        break †⟨JGetLabel(#env)⟩;
      †⟨JApplyDelayEntries(JAddVar(#env, #variable, JFree(text⟦⟨STRING: var⟩⟧, #csort)), #variable, #cont)⟩⟧

  // JBound variable
  // TODO: update term's parent with evaluated term.
  // TODO: release acquired references.
  rule JavaPatternVariable(SOME(JBound(#javavar, #sort)), #env, #variable, #csort, #term, #cont)
  → text⟦
      if (!isVariableUse(†⟨#term⟩) || †⟨#javavar⟩ != †⟨#term⟩.variable()) {
        break †⟨JGetLabel(#env)⟩;
      }†⟨#cont(#env)⟩⟧

// --- pattern matching inside meta

// Iterate over meta arguments and find corresponding bound variables, and update environment
func JavaPatternMaybeMetaArgs({String : JEnvEntry}, List<Core_canno_sort>, String, List<Core_csubst_sort>,
                              Text4_text_sort /* Current term */, Option<Core_csort_sort>, Storage,
                              ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // No arg meta-variable. This might unlock delayed properties
  rule JavaPatternMaybeMetaArgs(#env, #canno*, #metavar, csubst?⟦⟧, #term, #csort, #storage, #cont)
  → JApplyDelayEntries(JAddMeta(#env, #metavar, #term, (), #storage), #metavar, #cont)

  // meta substitution
  rule JavaPatternMaybeMetaArgs(#env, #canno*, #metavar, csubst?⟦ [ ##cterm* ] ⟧, #term, #csort, #storage, #cont)
  → #cont(JAddMeta(#env, #metavar, #term, Map((x) -> JavaFindJBoundVar(#env, x), #cterm*), #storage))

func JavaFindJBoundVar({String : JEnvEntry}, Core_cterm_sort) -> Text4_text_sort

  rule JavaFindJBoundVar(#env, cterm⟦ ##VARIABLE ⟧)
  → JGetVar(#env, #VARIABLE)

// --- Map pattern matching

func JavaPatternMap({String : JEnvEntry}, List<Core_cmapentries_sort>, Text4_text_sort, Core_cmapsort_sort, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort
  rule JavaPatternMap(#env, cmapentries?⟦⟧, #term, #cmapsort, #cont)
  → text⟦
      if (!†⟨#term⟩.isEmpty())
        break †⟨JGetLabel(#env)⟩;
      †⟨#cont(#env)⟩⟧

  rule JavaPatternMap(#env, cmapentries?⟦ ##cmapentry* ⟧, #term, #cmapsort, #cont)
  → JavaPatternMapEntries(#env, #cmapentry*, #term, #cmapsort, #cont)

func JavaPatternMapEntries({String : JEnvEntry}, List<Core_cmapentry_sort>, Text4_text_sort, Core_cmapsort_sort, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaPatternMapEntries(#env, cmapentry*⟦ ##cmapentry ##cmapentry* ⟧, #term, #cmapsort, #cont)
  → JavaPatternMapEntry(#env, #cmapentry, #term, #cmapsort, (env)->JavaPatternMapEntries(env, #cmapentry*, #term, #cmapsort, #cont))

  rule JavaPatternMapEntries(#env, cmapentry*⟦  ⟧, #term, #cmapsort, #cont)
  → #cont(#env)

func JavaPatternMapEntry({String : JEnvEntry}, Core_cmapentry_sort, Text4_text_sort, Core_cmapsort_sort, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaPatternMapEntry(#env, cmapentry⟦ : ##METAVAR ⟧, #term, #cmapsort, #cont)
  → #cont(JAddMeta(#env, #METAVAR, #term, (), ARGUMENT)) // TODO: ARGUMENT should be safe but no sure.

  rule JavaPatternMapEntry(#env, cmapentry⟦  ¬ ##METAVAR ⟧, #term, #cmapsort, #cont)
  → IfPresent(JGetMetaVarO(#env, #METAVAR),
      (key)->text⟦
        if (†⟨#term⟩.contains(†⟨key⟩))
          break †⟨JGetLabel(#env)⟩;
        †⟨#cont(#env)⟩⟧,
      ()->#cont(JDelayMapEntry(#env, #METAVAR, JMapEntry(cmapentry⟦ ¬ ##METAVAR ⟧, #term, #cmapsort))))

  rule JavaPatternMapEntry(#env, cmapentry⟦ ##METAVAR : ##cterm ⟧, #term, #cmapsort, #cont)
  → IfPresent(JGetMetaVarO(#env, #METAVAR),
      (key)->text⟦
        Option<†⟨SortToType(GetMapValueSort(#cmapsort))⟩> ⟨STRING: mval⟩ = †⟨#term⟩.getValue(†⟨GetContext(#env)⟩, †⟨key⟩).asSOME(†⟨GetContext(#env)⟩);
        if (⟨STRING: mval⟩ == null)
          break †⟨JGetLabel(#env)⟩;
        †⟨SortToType(GetMapValueSort(#cmapsort))⟩ ⟨STRING: value⟩ = ⟨STRING: mval⟩.asSOME(†⟨GetContext(#env)⟩).getField1(†⟨GetContext(#env)⟩, false);
        †⟨JavaPatternTerm(#env, #cterm, text⟦⟨STRING: value⟩⟧, SOME(GetMapValueSort(#cmapsort)), ARGUMENT, #cont)⟩⟧,
      ()->#cont(JDelayMapEntry(#env, #METAVAR, JMapEntry(cmapentry⟦ ##METAVAR : ##cterm ⟧, #term, #cmapsort))))

  rule JavaPatternMapEntry(#env, cmapentry⟦ ##VARIABLE ⟧, #term, #cmapsort, #cont)
  → IfPresent(JGetVarO(#env, #VARIABLE),
      (key)->text⟦
        if (!†⟨#term⟩.containsVar(†⟨UnJVarVar(key)⟩.variable()))
          break †⟨JGetLabel(#env)⟩;
        †⟨#cont(#env)⟩⟧,
      ()->#cont(JDelayMapEntry(#env, #VARIABLE, JMapEntry(cmapentry⟦ ##VARIABLE ⟧, #term, #cmapsort))))

  rule JavaPatternMapEntry(#env, cmapentry⟦ ¬ ##VARIABLE ⟧, #term, #cmapsort, #cont)
  → IfPresent(JGetVarO(#env, #VARIABLE),
      (key)->text⟦
        if (†⟨#term⟩.containsVar(†⟨UnJVarVar(key)⟩.variable()))
          break †⟨JGetLabel(#env)⟩;
        †⟨#cont(#env)⟩⟧,
      ()->#cont(JDelayMapEntry(#env, #VARIABLE, JMapEntry(cmapentry⟦ ¬ ##VARIABLE ⟧, #term, #cmapsort))))

  rule JavaPatternMapEntry(#env, cmapentry⟦ ##VARIABLE : ##cterm ⟧, #term, #cmapsort, #cont)
  → IfPresent(JGetVarO(#env, #VARIABLE),
      (key)->text⟦
        Option<†⟨SortToType(GetMapValueSort(#cmapsort))⟩> ⟨STRING: mval⟩ = †⟨#term⟩.getValue(†⟨GetContext(#env)⟩, †⟨UnJVarVar(key)⟩.use()).asSOME(†⟨GetContext(#env)⟩);
        if (⟨STRING: mval⟩ == null)
          break †⟨JGetLabel(#env)⟩;
        †⟨SortToType(GetMapValueSort(#cmapsort))⟩ ⟨STRING: value⟩ = ⟨STRING: mval⟩.asSOME(†⟨GetContext(#env)⟩).getField1(†⟨GetContext(#env)⟩, false);
        †⟨JavaPatternTerm(#env, #cterm, text⟦⟨STRING: value⟩⟧, SOME(GetMapValueSort(#cmapsort)), ARGUMENT, #cont)⟩⟧,
      ()->#cont(JDelayMapEntry(#env, #VARIABLE, JMapEntry(cmapentry⟦ ##VARIABLE : ##cterm ⟧, #term, #cmapsort))))

  rule JavaPatternMapEntry(#env, cmapentry⟦ ##STRING ⟧, #term, #cmapsort, #cont)
  → text⟦
      if (!†⟨#term⟩.contains(†⟨Literal(cliteral⟦ ##STRING ⟧)⟩))
        break †⟨JGetLabel(#env)⟩;
      †⟨#cont(#env)⟩⟧

  rule JavaPatternMapEntry(#env, cmapentry⟦ ¬ ##STRING ⟧, #term, #cmapsort, #cont)
  → text⟦
      if (†⟨#term⟩.contains(†⟨Literal(cliteral⟦ ##STRING ⟧)⟩))
        break †⟨JGetLabel(#env)⟩;
      †⟨#cont(#env)⟩⟧

  rule JavaPatternMapEntry(#env, cmapentry⟦ ##STRING  : ##cterm ⟧, #term, #cmapsort, #cont)
 → text⟦
      Option<†⟨SortToType(GetMapValueSort(#cmapsort))⟩> ⟨STRING: mval⟩ = †⟨#term⟩.getValue(†⟨GetContext(#env)⟩, †⟨Literal(cliteral⟦ ##STRING ⟧)⟩).asSOME(†⟨GetContext(#env)⟩);
      if (⟨STRING: mval⟩ == null)
        break †⟨JGetLabel(#env)⟩;
      †⟨SortToType(GetMapValueSort(#cmapsort))⟩ ⟨STRING: value⟩ = ⟨STRING: mval⟩.asSOME(†⟨GetContext(#env)⟩).getField1(†⟨GetContext(#env)⟩, false);
      †⟨JavaPatternTerm(#env, #cterm, text⟦⟨STRING: value⟩⟧, SOME(GetMapValueSort(#cmapsort)), ARGUMENT, #cont)⟩⟧


/* Apply delayed map entries waiting for the given `#var` (meta or not) to be initialized */
func JApplyDelayEntries(#env: {String : JEnvEntry}, #var: String, #cont:({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort
→ JApplyDelayEntriesAux(#env, JGetDelayEntriesForVar(#env, #var), #cont)

func JApplyDelayEntriesAux({String : JEnvEntry}, List<JMapEntry>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort
rule JApplyDelayEntriesAux(#env, Cons(JMapEntry(#cmapentry, #term, #cmapsort), #entries), #cont) → JavaPatternMapEntry(#env, #cmapentry, #term, #cmapsort, (env)->JApplyDelayEntriesAux(env, #entries, #cont))
rule JApplyDelayEntriesAux(#env, Nil                                                    , #cont) → #cont(#env)

// --- Named term

func JavaPatternNamedTerm(#env: {String : JEnvEntry}, #canno*: List<Core_canno_sort>, #metavar: String, #cterm: Core_cterm_sort, #term: Text4_text_sort,
                         #csort: Option<Core_csort_sort>, #storage: Storage, #cont: ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort
→ JavaPatternMaybeMetaArgs(#env, #canno*, #metavar, csubst?⟦⟧, #term, #csort, #storage, (env)->
  JavaPatternTerm(env, #cterm, #term, #csort, #storage, #cont))

//  --------- Helper function for pattern matching

/* Generate force call if term is a parameter */
func ForceParameter({String : JEnvEntry}, Text4_text_sort, Storage) -> Text4_text_sort
  rule ForceParameter(#env, #term, PARAMETER) →  text⟦†⟨#term⟩ = force(†⟨GetContext(#env)⟩, †⟨#term⟩);⟧
  rule ForceParameter(#env, #term, #storage)  →  text⟦⟧

/* Extract type parameter from constructor sort */
func ResolveTypeParamCons(Option<Core_csort_sort>) -> Text4_text_sort
  rule ResolveTypeParamCons(NONE)
  → text⟦⟧

  rule ResolveTypeParamCons(SOME(csort⟦ ##CONSTRUCTOR ##csorts? ⟧))
  → MaybeSortsToTypeParams(#csorts?)

  rule ResolveTypeParamCons(SOME(#))
  → text⟦⟧

/* Get sub sort. Get it from term and if not available on sort */
func SubSort({String : JEnvEntry}, Core_cterm_sort, Option<List<Core_csort_sort>>) -> Option<Core_csort_sort>
rule SubSort(#env, #cterm, #csorts?)
→ SubSort2(SubSortFromTerm(#env, #cterm), #csorts?)

func SubSort2(Option<Core_csort_sort>, Option<List<Core_csort_sort>>) -> Option<Core_csort_sort>
rule SubSort2(SOME(#csort), #)                       → SOME(#csort)
rule SubSort2(NONE, NONE)                            → NONE
rule SubSort2(NONE, SOME(csort*⟦ ##csort ##csort* ⟧)) → SOME(#csort)
rule SubSort2(NONE, SOME(csort*⟦ ⟧))                  → Error("Error: could not find type for sub term.")

func SubSortFromTerm({String : JEnvEntry}, Core_cterm_sort) -> Option<Core_csort_sort>

  // TODO: support for multiple sort qualifiers
  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##csort :: ##csortqualifier* ##CONSTRUCTOR ##csortargs?  ##cterms? ##csortanno? ⟧)
  → SOME(#csort)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##CONSTRUCTOR ##csortargs?  ##cterms? ##csortanno? ⟧)
  → NONE

  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##STRING ⟧)
  → SOME(csort⟦ String ⟧)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##NUMBER ⟧)
  → SOME(csort⟦ Numeric⟧)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##VARIABLE : ##csort ⟧)
  → SOME(#csort)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##VARIABLE ##csortanno? ⟧)
  → JSubSortFromVar(JGetVarO(#env, #VARIABLE), #VARIABLE)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧)
  → MaybeSortAnnoToSort(#csortanno?)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* { ##cmapentries? } ##csortanno? ⟧)
  → MaybeSortAnnoToSort(#csortanno?)

  // TODO: maybe error?
  rule SubSortFromTerm(#env, cterm⟦ ##canno* [ x ##csortanno?[] ] ##cterm[x] ⟧)
  → SubSortFromTerm(#env, #cterm[var:String])

  // TODO: maybe error?
  rule SubSortFromTerm(#env, cterm⟦ ##canno* ( f ##csortanno?[] ) ##cterm[f] ⟧)
  → SubSortFromTerm(#env, #cterm[var:String])

func JSubSortFromVar(Option<JVarEntry>, String) -> Option<Core_csort_sort>

  rule JSubSortFromVar(NONE, #var)
  → NONE

  rule JSubSortFromVar(SOME(#varEntry), #var)
  → UnJVarSort(#varEntry)

// ---- Reference counting

/* Determine whether the current parameter must be kept or not. */
func JavaMayDiscard({String : JEnvEntry}, Core_cterm_sort, List<Core_canno_sort>) -> {String : JEnvEntry}

  rule JavaMayDiscard(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #canno*)
  → JavaMayDiscardMeta(#env, #METAVAR,  IfPresent(GetAnnotation("KeepAll", #canno*), (anno)->GetAnnotationArgs(anno), ()->()))

  rule JavaMayDiscard(#env, #cterm, #canno*)
  → JAddDiscard(#env, JavaCurrentParam(#env))

func JavaMayDiscardMeta(#env: {String : JEnvEntry}, #meta: String, #keep: List<Core_cterm_sort>) -> {String : JEnvEntry}
→ If(JavaMustKeep(#keep, #meta), ()->#env, ()->JAddDiscard(#env, JavaCurrentParam(#env)))

/* Discard term parameters not used in the contraction */
func JavaDiscard(#env: {String : JEnvEntry}) -> Text4_text_sort
→ TextMapFoldES((param)->text⟦¶†⟨param⟩.release();⟧, JGetDiscard(#env))

// Tell whether the given `#meta` variable must be kept
func JavaMustKeep(#keep: List<Core_cterm_sort>, #meta:String) -> Bool
→ HasOption(PickFirst(#keep, (term)->IsNamedMeta(term, #meta)))

/* Keep subterm used in contraction */
func JavaKeepSub(#env: {String : JEnvEntry}, #canno*: List<Core_canno_sort>) -> Text4_text_sort
→ JavaKeepSub2(#env, IfPresent(GetAnnotation("KeepAll", #canno*), (anno)->GetAnnotationArgs(anno), ()->()))

func JavaKeepSub2(#env: {String : JEnvEntry}, #keep: List<Core_cterm_sort>) -> Text4_text_sort
→ TextMapFoldES((annometa)->
                  If(JavaIsArgument(JGetMetaStorage(#env, Snd(annometa))),
                    ()->text⟦¶†⟨JGetMetaVar(#env, Snd(annometa))⟩.ref();⟧,
                    ()->text⟦⟧),
                GetMetaVariables(#keep))

func JavaIsArgument(Storage) -> Bool
rule JavaIsArgument(ARGUMENT) → TRUE
rule JavaIsArgument(PARAMETER) → FALSE

// ----- Contraction

func JavaContractum(#env: {String : JEnvEntry}, #ruleanno*: List<Core_canno_sort>, #term: Core_cterm_sort) -> Text4_text_sort
→ text⟦†⟨JavaKeepSub(#env, #ruleanno*)⟩†⟨JavaDiscard(#env)⟩†⟨JavaStatementTerm(#env, #term)⟩⟧

func JavaStatementTerm(#env: {String : JEnvEntry}, #cterm:Core_cterm_sort) -> Text4_text_sort
→ text⟦†⟨JavaJFreshesTerm(JSetCounter(JSetFreshCounter(#env, 0), 0), #cterm, (env) ->
     text⟦return †⟨JavaExprTerm(JSetCounter(JSetParamCounter(env, 0), 0), #cterm, (env) -> text⟦⟧)⟩;⟧)⟩⟧

// ---- Generate fresh variable - Only in Java statement mode

func JavaJFreshesTerm({String : JEnvEntry}, Core_cterm_sort, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaJFreshesTerm(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #cont)
  → JavaJFreshesMaybeTerms(#env, #cterms?, #cont)

  rule JavaJFreshesTerm(#env, cterm⟦ ##canno* ##cliteral ⟧, #cont)
  → #cont(#env)

  rule JavaJFreshesTerm(#env, cterm⟦ ##canno* ##VARIABLE ##csortanno? ⟧, #cont)
  → JavaJFreshesVariable(#env, JGetVarO(#env, #VARIABLE), #VARIABLE, #csortanno?, TRUE, #cont)

  rule JavaJFreshesTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #cont)
  → JavaJFreshesMaybeTerms(#env, #cterms?, (env) -> JavaJFreshesMaybeSubst(env, #csubst?, #cont))

  rule JavaJFreshesTerm(#env, cterm⟦ ##canno* [ x ##csortanno? ] ##cterm[x] ⟧, #cont)
  → JavaJFreshesVariable(#env, NONE, var, #csortanno?, FALSE, (env) -> JavaJFreshesTerm(env, #cterm[var], #cont))

  rule JavaJFreshesTerm(#env, cterm⟦ ##canno* ( f ##csortanno?[] ) ##cterm[f] ⟧, #cont)
  → JavaJFreshesTerm(JAddVar(#env, var, JFormal(text⟦ dummy ⟧, NONE)), #cterm[var], #cont)

  rule JavaJFreshesTerm(#env, cterm⟦ ##canno* { ##cmapentries? } ##csortanno? ⟧, #cont)
  → Error("Internal Error: map expression must no occur in the contraction.")

  rule JavaJFreshesTerm(#env, cterm⟦ ##canno* thunk ##cterm ⟧, #cont)
  → JavaJFreshesTerm(#env, #cterm, #cont)

func JavaJFreshesMaybeTerms({String : JEnvEntry}, List<Core_cterms_sort>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaJFreshesMaybeTerms(#env, cterms?⟦⟧, #cont)
  → #cont(#env)

  rule JavaJFreshesMaybeTerms(#env, cterms?⟦ () ⟧, #cont)
  → #cont(#env)

  rule JavaJFreshesMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧, #cont)
  → JavaJFreshesTerms(#env, #cterm*, #cont)

func JavaJFreshesTerms({String : JEnvEntry}, List<Core_cterm_sort>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaJFreshesTerms(#env, cterm*⟦⟧, #cont)
  → #cont(#env)

  rule JavaJFreshesTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, #cont)
  → JavaJFreshesTerm(#env, #cterm, (env) -> JavaJFreshesTerms(env, #cterm*, #cont))

func JavaJFreshesMaybeSubst({String : JEnvEntry}, List<Core_csubst_sort>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort
  rule JavaJFreshesMaybeSubst(#env, csubst?⟦⟧, #cont)
  → #cont(#env)

  rule JavaJFreshesMaybeSubst(#env, csubst?⟦ [ ##cterm* ] ⟧, #cont)
  → JavaJFreshesTerms(#env, #cterm*, #cont)

func JavaJFreshesVariable({String : JEnvEntry}, Option<JVarEntry>, String, List<Core_csortanno_sort>, Bool, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaJFreshesVariable(#env, NONE, #var, csortanno?⟦ : ##csort ⟧, TRUE, #cont)
  → text⟦
      Var†⟨SortToType(#csort)⟩ fresh†⟨NumberToText(JGetFreshCounter(#env))⟩ = var†⟨SortToType(#csort)⟩(†⟨GetContext(#env)⟩, †⟨Text-QuoteEscape(Show(#var))⟩);⟨
        #cont(JIncFreshCounter(JAddVar(#env, #var, JFresh(text⟦fresh†⟨NumberToText(JGetFreshCounter(#env))⟩⟧, SOME(#csort)))))⟩⟧

  rule JavaJFreshesVariable(#env, NONE, #var, csortanno?⟦ : ##csort ⟧, FALSE, #cont)
  → text⟦
      Var†⟨SortToType(#csort)⟩ bound†⟨NumberToText(JGetCounter(#env))⟩ = var†⟨SortToType(#csort)⟩(†⟨GetContext(#env)⟩, †⟨Text-QuoteEscape(Show(#var))⟩);⟨
        #cont(JIncCounter(JAddVar(#env, #var, JFresh(text⟦fresh†⟨NumberToText(JGetCounter(#env))⟩⟧, SOME(#csort)))))⟩⟧

  // Variable already exists
  rule JavaJFreshesVariable(#env, SOME(#), #var, #csortanno?, #fresh, #cont)
  → #cont(#env)

// ---- Generate term code - Java expression mode

func JavaExprTerm({String : JEnvEntry}, Core_cterm_sort, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaExprTerm(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #cont)
  → JavaExprConstruction(#env, #canno*, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #cont)

  rule JavaExprTerm(#env, cterm⟦ ##canno* ##cliteral ⟧, #cont)
  → text⟦
      †⟨Literal(#cliteral)⟩†⟨#cont(#env)⟩⟧

  rule JavaExprTerm(#env, cterm⟦ ##canno* ##VARIABLE ##csortanno? ⟧, #cont)
  → JavaExprMaybeVar(#env, JGetVarO(#env, #VARIABLE), #VARIABLE, #cont)

  rule JavaExprTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #cont)
  → JavaExprMeta(#env, #canno*, #METAVAR, #cterms?, #csubst?, #cont)

  rule JavaExprTerm(#env, cterm⟦ ##canno* [ x ##csortanno?[] ] ##cterm[x] ⟧, #cont)
  → text⟦
      bound†⟨NumberToText(JGetCounter(#env))⟩, †⟨JavaExprTerm(JAddVar(JIncCounter(#env), var, JBound(text⟦bound†⟨NumberToText(JGetCounter(#env))⟩⟧, MaybeSortAnnoToSort(#csortanno?))), #cterm[var], #cont)⟩⟧

  rule JavaExprTerm(#env, cterm⟦ ##canno* ( f ##csortanno?[] ) ##cterm[f] ⟧, #cont)
  → text⟦newClosure((†⟨GetContext(NewContext(#env))⟩†⟨JavaExprLambda(NewContext(#env), cterm⟦ ( f ##csortanno?[] ) ##cterm[f] ⟧, #cont)⟩⟧

  rule JavaExprTerm(#env, cterm⟦ ##canno* thunk ##cterm ⟧, #cont)
  → text⟦newClosure(†⟨GetContext(NewContext(#env))⟩ -> ⟨JavaExprTerm(NewContext(#env), #cterm, (env) -> text⟦†⟨JavaLambdaCaptures(#env, #canno*)⟩)⟨#cont(env)⟩⟧)⟩⟧

// ---- construction expression

func JavaExprConstruction({String : JEnvEntry}, List<Core_canno_sort>, String, List<Core_csortargs_sort>, List<Core_cterms_sort>, List<Core_csortanno_sort>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // TODO: renable If optimization when reference counting is stable.
  rule JavaExprConstruction(#env, #canno*, #constructor, #csortargs?, #cterms?, #csortanno?, #cont)
  → //If(Equal(#constructor, "If"),
    //  ()->JavaIfExpr(#env, #cterms?, #cont),
    //  ()->
    text⟦⟨STRING: Mangle(#constructor)⟩(context†⟨JavaExprThunkArgs(HasAnnotation("Data", #canno*), #csortargs?)⟩†⟨JavaExprMaybeTerms(#env, #cterms?, #cont)⟩⟧
    //)

func JavaExprMaybeTerms({String : JEnvEntry}, List<Core_cterms_sort>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaExprMaybeTerms(#env, cterms?⟦⟧, #cont)
  → text⟦)†⟨#cont(#env)⟩⟧

  rule JavaExprMaybeTerms(#env, cterms?⟦()⟧, #cont)
  → text⟦)†⟨#cont(#env)⟩⟧

  rule JavaExprMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧, #cont)
  → JavaExprTerms(#env, #cterm*, #cont)

func JavaExprTerms({String : JEnvEntry}, List<Core_cterm_sort>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort
  rule JavaExprTerms(#env, cterm*⟦⟧, #cont)
  → text⟦)†⟨#cont(#env)⟩⟧

  rule JavaExprTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, #cont)
  → text⟦, †⟨JavaExprTerm(#env, #cterm, (env) -> JavaExprTerms(env, #cterm*, #cont))⟩⟧

func JavaExprThunkArgs(Bool, List<Core_csortargs_sort>) -> Text4_text_sort
rule JavaExprThunkArgs(FALSE, csortargs?⟦ < ##csort* > ⟧) → TextFoldES(Map((csort)->JavaExprThunkArg(csort), #csort*))
rule JavaExprThunkArgs(#data, #csortargs?)               → text⟦⟧

func JavaExprThunkArg(Core_csort_sort) -> Text4_text_sort
rule JavaExprThunkArg(csort⟦ ##VARIABLE ⟧) → text⟦, tm⟨STRING: #VARIABLE⟩⟧
rule JavaExprThunkArg(csort⟦ ##csort    ⟧) → text⟦, †⟨ThunkMaker(#csort)⟩Maker()⟧

// --- If

func JavaIfExpr({String : JEnvEntry}, List<Core_cterms_sort>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort
rule JavaIfExpr(#env, cterms?⟦ ( ##cterm1, ##cterm2, ##cterm3 ) ⟧, #cont)
→ text⟦ (unbox(context, †⟨JavaExprTerm(#env, #cterm1, (env)->text⟦)) ?
          (†⟨JavaExprTerm(env, JavaIfBranch(#cterm2), (env)->text⟦)
        : (†⟨JavaExprTerm(env, JavaIfBranch(#cterm3), (env)->text⟦)†⟨#cont(env)⟩⟧)⟩⟧)⟩⟧)⟩⟧

func JavaIfBranch(Core_cterm_sort) -> Core_cterm_sort
rule JavaIfBranch(cterm⟦ ##canno* ##METAVAR ##csortanno? ⟧) → cterm⟦ ##METAVAR () ⟧ // metavariable must be a closure (checked by infer)
rule JavaIfBranch(#cterm                                  ) → StripThunk(#cterm)

// --- Variable

func JavaExprMaybeVar({String : JEnvEntry}, Option<JVarEntry>, String, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaExprMaybeVar(#env, SOME(JFormal(#var, #type)), #svar, #cont)
  → text⟦†⟨#var⟩†⟨#cont(#env)⟩⟧

  // fallback
  rule JavaExprMaybeVar(#env, SOME(#varEntry), #svar, #cont)
  → text⟦†⟨UnJVarVar(#varEntry)⟩.use()†⟨#cont(#env)⟩⟧

// ----  metavar expression

func JavaExprMeta({String : JEnvEntry}, List<Core_canno_sort>, String, List<Core_cterms_sort>, List<Core_csubst_sort>, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // No arguments -> just return the metavariable.
  rule JavaExprMeta(#env, #canno*, #metavar, cterms?⟦⟧, csubst?⟦⟧, #cont)
  → text⟦†⟨JavaExprRefMeta(#env, #canno*, #metavar)⟩†⟨#cont(#env)⟩⟧

  // No arguments in parenthesis -> call lambda with no param.
  rule JavaExprMeta(#env, #canno*, #metavar, cterms?⟦ () ⟧, csubst?⟦⟧, #cont)
  → text⟦†⟨JavaExprRefMeta(#env, #canno*, #metavar)⟩.eval(context)†⟨#cont(#env)⟩⟧

  // Apply arguments -> call lambda
  rule JavaExprMeta(#env, #canno*, #metavar, cterms?⟦ ( ##cterm* ) ⟧, csubst?⟦⟧, #cont)
  → text⟦†⟨JavaExprRefMeta(#env, #canno*, #metavar)⟩.eval(context†⟨JavaExprTerms(#env, #cterm*, #cont)⟩⟧

  // Substitution
  rule JavaExprMeta(#env, #canno*, #metavar, #cterms?, csubst?⟦ [ ##cterm* ] ⟧, #cont)
  → text⟦subst(context, †⟨JavaExprRefMeta(#env, #canno*, #metavar)⟩†⟨JavaExprMetaArgs(#env, JGetMetaArgs(#env, #metavar), #cterm*, #cont)⟩⟧

  // TODO: call and substitution

func JavaExprRefMeta(#env: {String : JEnvEntry}, #canno*: List<Core_canno_sort>, #metavar: String) -> Text4_text_sort
→ If(HasAnnotation("Keep", #canno*), ()->text⟦ref(†⟨JGetMetaVar(#env, #metavar)⟩)⟧, ()->text⟦†⟨JGetMetaVar(#env, #metavar)⟩⟧)

func JavaExprMetaArgs({String : JEnvEntry}, List<Text4_text_sort> /* pattern args */, List<Core_cterm_sort> /* contraction args */,
                     ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaExprMetaArgs(#env, (), #args,  #cont)
  → text⟦)†⟨#cont(#env)⟩⟧

  rule JavaExprMetaArgs(#env, (#binder,  #binders...), (#arg, #args...), #cont)
  → text⟦,†⟨#binder⟩,†⟨JavaExprTerm(#env, #arg, (env) -> JavaExprMetaArgs(env, #binders, #args, #cont))⟩⟧

// ---- lambda expression

func JavaExprLambda({String : JEnvEntry}, Core_cterm_sort, ({String : JEnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule JavaExprLambda(#env, cterm⟦ ##canno* ( f ##csortanno?[] ) ##cterm[f] ⟧, #cont)
  → text⟦, p†⟨NumberToText(JGetParamCounter(#env))⟩†⟨JavaExprLambda(JAddVar(JIncParamCounter(#env), var, JFormal(text⟦p†⟨NumberToText(JGetParamCounter(#env))⟩⟧, MaybeSortAnnoToSort(#csortanno?))), #cterm[var], #cont)⟩⟧

  // Done with formal parameters.
  rule JavaExprLambda(#env, #cterm, #cont)
  → text⟦) -> †⟨JavaExprTerm(#env, #cterm, (env) -> text⟦†⟨JavaLambdaCaptures(#env, GetAnnotations(#cterm))⟩)†⟨#cont(env)⟩⟧)⟩⟧

func JavaLambdaCaptures(#env: {String : JEnvEntry}, #anno*: List<Core_canno_sort>) -> Text4_text_sort
→ IfPresent(GetAnnotation("KeepAll", #anno*),
    (anno)->TextMapFoldES((annometa)->text⟦, †⟨JavaExprRefMeta(#env, Fst(annometa), Snd(annometa))⟩⟧,
                           GetMetaVariables(GetAnnotationArgs(anno))),
    ()->text⟦⟧)

// ----- initModule

/* Generate code initializing a module. */
func InitModule(String, { String : Core_cdecl_sort }, { String : Core_cdecl_sort }, List<Core_cqidentifier_sort>, Bool) -> Text4_text_sort

rule InitModule(#classname, #data, #func, #imports, #bootstrap)
→ text⟦
    private static boolean initialized = false;
    public static void init(Context context) {
      if (!initialized) {
        initialized = true;
        †⟨TextFold(Map((sort )->RegisterDataSort(#classname, sort), MapValues(#data)), text⟦⟧)⟩
        †⟨TextFold(Map((qcons)->RegisterImport(qcons, #bootstrap),  #imports), text⟦⟧)⟩
      }
}⟧

func RegisterImport(#name: Core_cqidentifier_sort, #bootstrap: Bool) -> Text4_text_sort
→ text⟦
    †⟨PathToImport(JoinQIdentifier(#name, "::", TRUE), #bootstrap)⟩.init(context);⟧ // TODO: maybe use '.' sep

func RegisterDataSort(String, Core_cdecl_sort) -> Text4_text_sort
rule RegisterDataSort(#classname, cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧)
→ TextFoldES(Map((x) -> RegisterDataForm(#classname, #CONSTRUCTOR, x), #cform*))

func RegisterDataForm(String, String, Core_cform_sort) -> Text4_text_sort

  rule RegisterDataForm(#classname, #sortname, cform⟦ ##CONSTRUCTOR ##csortsdefault? ⟧)
  → text⟦
       context.register(†⟨Text-QuoteEscape(#CONSTRUCTOR)⟩, †⟨EValueClassName(#CONSTRUCTOR)⟩::new);⟧

  rule RegisterDataForm(#classname, #sortname, cform⟦ allows-variable ⟧)
  → text⟦
       context.registerVarMaker(†⟨Text-QuoteEscape(#sortname)⟩, ⟨STRING:#classname⟩::var⟨STRING: Mangle(#sortname)⟩);⟧

/* Print package declaration */
func PackageDeclaration(#url: String, #mainurl: String, #package: String) -> Text4_text_sort
→ PackageDeclaration2(#package, Replace(RelativePath(#url, #mainurl), "/", "."))

func PackageDeclaration2(#base: String, #sub: String) -> Text4_text_sort
→ PackageDeclaration3(#base, If(StringEqual(Trim(#base), ""), ()->"", ()->"."), #sub)

func PackageDeclaration3(#base:String, #sep: String, #sub:String) -> Text4_text_sort
→ PackageDeclaration4(ConcatString(#base, If(StringEqual(Trim(#sub), ""), ()->"", ()->ConcatString(#sep, #sub))))

func PackageDeclaration4(#pkg:String) -> Text4_text_sort
→ If(StringEqual(#pkg, ""), ()->text⟦⟧, ()->text⟦package ⟨STRING:#pkg⟩;⟧)

// --- Print java import. Treat Std:: as special (unless bootstrapping) All other prefixes are relative to javapackage

func PathToImport(#name: String, #bootstrap: Bool) -> Text4_text_sort
→ PathToImport2(If(And(Not(#bootstrap), Or(StartsWith(#name, "Std::"), StartsWith(#name, "std::"))), ()->"org.transscript.compiler", ()->GetEnv("javabasepackage", "")),
                Split(#name, "::"))

func PathToImport2(#basepkg: String , #path: List<String>) -> Text4_text_sort
→ If(StringEqual(#basepkg, ""),
    ()->JoinPath(#path),
    ()->text⟦†⟨StringToText(#basepkg)⟩.†⟨JoinPath(#path)⟩⟧)

/* Join path component together, making sure the last one starts with an upper case character */
func JoinPath(List<String>) -> Text4_text_sort
rule JoinPath((                               )) → text⟦⟧
rule JoinPath(Cons(#, Nil)) → text⟦⟨STRING: UpCaseFirst(Mangle(#))⟩⟧
rule JoinPath(Cons(#, #s))  → text⟦⟨STRING: Mangle(#)⟩.†⟨JoinPath(#s)⟩⟧

// Print class name
func ClassName(#name: String) -> String
→ Mangle(UpCaseFirst(AfterLast(BeforeLast(#name, "."), "/")))

/* Get the absolute name of the target java file */
@Extern func TargetJavaFilename(#input: String, #dest: String, #mainurl:String, #package: String) -> String

/* Get sub directory of `#module` relative to `#mainmodule` */
@Extern func RelativePath(#input: String, #mainurl:String) -> String

// --- Java printing helpers

// Print literal as a java string
func Literal(Core_cliteral_sort) -> Text4_text_sort
rule Literal(cliteral⟦ ##STRING ⟧) → text⟦stringTerm(†⟨Text-QuoteEscape(#STRING)⟩)⟧
rule Literal(cliteral⟦ ##NUMBER ⟧) → text⟦doubleTerm(⟨STRING: #NUMBER⟩)⟧

// Convert constructor to legal Java ID
func ToJavaId(String) -> Text4_text_sort
rule ToJavaId(#constructor) → Text-Mangle(UpCaseFirst(#constructor))

// Convert constructor to legal Java ID
func ToJavaIdString(String) -> Text4_text_sort
rule ToJavaIdString(#name) → Text-Mangle(#name)

// -- Java Code generation environment

// To change when upgrade to TS.

enum JVarEntry
  | JFree(Text4_text_sort /* Java var */, Option<Core_csort_sort>)
  | JBound(Text4_text_sort /* Java var */, Option<Core_csort_sort>)
  | JFresh(Text4_text_sort /* Java var */, Option<Core_csort_sort>)
  | JFormal(Text4_text_sort /* Java var */, Option<Core_csort_sort>)

enum JMetaEntry | JMetaVar(Text4_text_sort,       /* Java variable associated with the meta variable*/
                           List<Text4_text_sort>, /* Java variables associated to the meta variable bound variables */
                           Storage)               /* How the metavar is represented (function parameter or local variable) */

enum JMapEntry | JMapEntry(Core_cmapentry_sort, Text4_text_sort, Core_cmapsort_sort)


enum JEnvEntry | JNum(Numeric) |  JText(Text4_text_sort) | JTexts(List<Text4_text_sort>) | JBool(Bool)
                  | JMapMeta({String : JMetaEntry})
                  | JMapVar({ String : JVarEntry }) | JMapDecl({ String : Core_cdecl_sort })
                  | JParams(List<PPair<Text4_text_sort Core_csort_sort>>)
                  | JContext(Text4_text_sort /* context java variable */, Numeric /* Counter */)
                  | JFnAnno(List<Core_canno_sort>)
                  | JMapEntries({String /* (meta)var */: List<JMapEntry>}) /* Delayed map entries */

// Nested MapPut increases Java compilation exponentially.
func JNewEnv -> {String : JEnvEntry}
→   MapPut<String JEnvEntry>(
    MapPut<String JEnvEntry>(
    MapPut<String JEnvEntry>(
    MapPut<String JEnvEntry>(
    MapPut<String JEnvEntry>(
    MapPut<String JEnvEntry>(MapNew<String JEnvEntry>,
      "params"      , JParams(())),                /* Java method arguments. */
      "thunk"       , JTexts(())),                 /* thunk arguments */
      "meta"        , JMapMeta(MapNew<String JMetaEntry>)),  /* Map meta variable to java variables */
      "vars"        , JMapVar(MapNew<String JVarEntry>)),   /* Map variable to JVarEntry */
      "parent"      , JText(text⟦⟧)),    /* Sub parent (if any) */
      "delay"       , JMapEntries(MapNew))

// --- Helpers.


func JGetValue<a>({String : JEnvEntry}, String, (JEnvEntry) -> a) -> a
rule JGetValue(#env, #key, #unwrap)
→ #unwrap(UnSOME(MapGet(#env, #key)))

func JSetValue({String : JEnvEntry}, String, JEnvEntry) -> {String : JEnvEntry}
rule JSetValue(#env, #key, #value)
→ MapPut<String JEnvEntry>(#env, #key, #value)

func UnJNum(JEnvEntry) -> Numeric
rule UnJNum(JNum(#)) → #

func UnJText(JEnvEntry) -> Text4_text_sort
rule UnJText(JText(#)) → #

func UnJTexts(JEnvEntry) -> List<Text4_text_sort>
rule UnJTexts(JTexts(#)) → #

func UnJParams(JEnvEntry) -> List<PPair<Text4_text_sort Core_csort_sort>>
rule UnJParams(JParams(#)) → #

func UnJBool(JEnvEntry) -> Bool
rule UnJBool(JBool(#)) → #

func UnJMapMeta(JEnvEntry) -> {String : JMetaEntry}
rule UnJMapMeta(JMapMeta(#)) → #

func UnJMapVar(JEnvEntry) -> { String : JVarEntry }
rule UnJMapVar(JMapVar(#)) → #

func UnJMapDecl(JEnvEntry) -> { String : Core_cdecl_sort }
rule UnJMapDecl(JMapDecl(#)) → #

func UnJVarVar(JVarEntry) -> Text4_text_sort
rule UnJVarVar(JBound(#1, #2)) → #1
rule UnJVarVar(JFree(#1, #2)) → #1
rule UnJVarVar(JFresh(#1, #2)) → #1
rule UnJVarVar(JFormal(#1, #2)) → #1

func UnJVarSort(JVarEntry) -> Option<Core_csort_sort>
rule UnJVarSort(JBound(#1, #2)) → #2
rule UnJVarSort(JFree(#1, #2)) → #2
rule UnJVarSort(JFresh(#1, #2)) → #2
rule UnJVarSort(JFormal(#1, #2)) → #2

func UnJMetaVar(JMetaEntry) -> Text4_text_sort
rule UnJMetaVar(JMetaVar(#1, #2, #3)) → #1

func UnJMetaArgs(JMetaEntry) -> List<Text4_text_sort>
rule UnJMetaArgs(JMetaVar(#1, #2, #3)) → #2

func UnJMetaStorage(JMetaEntry) -> Storage
rule UnJMetaStorage(JMetaVar(#1, #2, #3)) → #3

func UnJContext(JEnvEntry) -> Text4_text_sort
rule UnJContext(JContext(#1, #2)) → #1

func UnJContextCount(JEnvEntry) -> Numeric
rule UnJContextCount(JContext(#1, #2)) → #2

func UnJFnAnno(JEnvEntry) -> List<Core_canno_sort>
rule UnJFnAnno(JFnAnno(#1)) → #1

func UnJMapEntries(JEnvEntry) -> {String /* metavar */: List<JMapEntry>}
rule UnJMapEntries(JMapEntries(#1)) → #1


// --- Data sorts

func JGetDataSorts({String : JEnvEntry}) -> { String : Core_cdecl_sort }
rule JGetDataSorts(#env) → JGetValue<{ String : Core_cdecl_sort }>(#env, "datasorts", (x) -> UnJMapDecl(x))

func JSetDataSorts({String : JEnvEntry}, { String : Core_cdecl_sort }) -> {String : JEnvEntry}
rule JSetDataSorts(#env, #sorts) → JSetValue(#env, "datasorts", JMapDecl(#sorts))

func JIsDataSort({String : JEnvEntry}, String) -> Bool
rule JIsDataSort(#env, #cons) → HasOption<Core_cdecl_sort>(MapGet<String Core_cdecl_sort>(JGetDataSorts(#env), #cons))

// --- Function sorts

func JGetFuncSorts({String : JEnvEntry}) -> { String : Core_cdecl_sort }
rule JGetFuncSorts(#env) → JGetValue<{ String : Core_cdecl_sort }>(#env, "funcsorts", (x) -> UnJMapDecl(x))

func JSetFuncSorts({String : JEnvEntry}, { String : Core_cdecl_sort }) -> {String : JEnvEntry}
rule JSetFuncSorts(#env, #sorts) → JSetValue(#env, "funcsorts", JMapDecl(#sorts))

func JIsFuncSort({String : JEnvEntry}, String) -> Bool
rule JIsFuncSort(#env, #cons) → HasOption<Core_cdecl_sort>(MapGet<String Core_cdecl_sort>(JGetFuncSorts(#env), #cons))

// --- Top-level classname

func JGetClassname({String : JEnvEntry}) -> Text4_text_sort
rule JGetClassname(#env) → JGetValue<Text4_text_sort>(#env, "classname", (x) -> UnJText(x))

func JSetClassname({String : JEnvEntry}, Text4_text_sort) -> {String : JEnvEntry}
rule JSetClassname(#env, #classname) → JSetValue(#env, "classname", JText(#classname))

// --- Step method arguments

func JGetParams({String : JEnvEntry}) -> List<PPair<Text4_text_sort Core_csort_sort>>
rule JGetParams(#env) → JGetValue<List>(#env, "params", (x) -> UnJParams(x))

func JSetParams({String : JEnvEntry}, List<PPair<Text4_text_sort Core_csort_sort>>) -> {String : JEnvEntry}
rule JSetParams(#env, #params) → JSetValue(#env, "params",  JParams(#params))

func JAddParam({String : JEnvEntry}, Text4_text_sort, Core_csort_sort) -> {String : JEnvEntry}
rule JAddParam(#env, #param, #csort) → JSetValue(#env, "params", JParams(Append(PairCons(#param, #csort), JGetParams(#env))))

// Move to the next parameter
func JavaNextParam({String : JEnvEntry}) -> {String : JEnvEntry}
rule JavaNextParam(#env) → JSetParams(#env, Tail(JGetParams(#env)))

// Get the current parameter text
func JavaCurrentParam({String : JEnvEntry}) -> Text4_text_sort
rule JavaCurrentParam(#env) → Fst<Text4_text_sort Core_csort_sort>(Head(JGetParams(#env)))

// Get the current parameter text
func JavaCurrentParamSort({String : JEnvEntry}) -> Core_csort_sort
rule JavaCurrentParamSort(#env) → Snd<Text4_text_sort Core_csort_sort>(Head(JGetParams(#env)))

// --- Current method name

func JGetMethodName({String : JEnvEntry}) -> Text4_text_sort
rule JGetMethodName(#env) → JGetValue<Text4_text_sort>(#env, "methodname", (x) -> UnJText(x))

func JSetMethodName({String : JEnvEntry}, Text4_text_sort) -> {String : JEnvEntry}
rule JSetMethodName(#env, #name) → JSetValue(#env, "methodname", JText(#name))

// --- Thunk type

func JJGetThunkMaker({String : JEnvEntry}) -> Text4_text_sort
rule JJGetThunkMaker(#env) → JGetValue<Text4_text_sort>(#env, "thunkmaker", (x) -> UnJText(x))

func JJSetThunkMaker({String : JEnvEntry}, Text4_text_sort) -> {String : JEnvEntry}
rule JJSetThunkMaker(#env, #type) → JSetValue(#env, "thunkmaker", JText(#type))

// --- Thunk arguments

func JGetThunk({String : JEnvEntry}) -> List<Text4_text_sort>
rule JGetThunk(#env) → JGetValue<List>(#env, "thunk", (x) -> UnJTexts(x))

func JSetThunk({String : JEnvEntry}, List<Text4_text_sort>) -> {String : JEnvEntry}
rule JSetThunk(#env, #thunk) → JSetValue(#env, "thunk", JTexts(#thunk))

func JAddThunk({String : JEnvEntry}, Text4_text_sort) -> {String : JEnvEntry}
rule JAddThunk(#env, #thunk) → JSetValue(#env, "thunk", JTexts(Append<Text4_text_sort>(#thunk, JGetThunk(#env))))

// --- Rule case label

func JGetLabel({String : JEnvEntry}) -> Text4_text_sort
rule JGetLabel(#env) → JGetValue<Text4_text_sort>(#env, "label", (x) -> UnJText(x))

func JSetLabel({String : JEnvEntry}, Text4_text_sort) -> {String : JEnvEntry}
rule JSetLabel(#env, #label) → JSetValue(#env, "label", JText(#label))

// --- Meta

func JGetMetas({String : JEnvEntry}) -> {String : JMetaEntry}
rule JGetMetas(#env) → JGetValue(#env, "meta", (x) -> UnJMapMeta(x))

func JGetMetaVar({String : JEnvEntry}, String) -> Text4_text_sort
rule JGetMetaVar(#env, #metavar) → UnJMetaVar(UnSOME(MapGet(JGetMetas(#env), #metavar)))

/* @return the Java variable associated to the given `#metavar`, or `NONE` when no such association exists */
func JGetMetaVarO(#env: {String : JEnvEntry}, #metavar: String) -> Option<Text4_text_sort>
→ Maybe((entry)->UnJMetaVar(entry), MapGet(JGetMetas(#env), #metavar))

func JGetMetaArgs({String : JEnvEntry}, String) -> List<Text4_text_sort>
rule JGetMetaArgs(#env, #metavar) → UnJMetaArgs(UnSOME(MapGet(JGetMetas(#env), #metavar)))

func JGetMetaStorage({String : JEnvEntry}, String) -> Storage
rule JGetMetaStorage(#env, #metavar) → UnJMetaStorage(UnSOME(MapGet(JGetMetas(#env), #metavar)))

func JAddMeta(#env: {String : JEnvEntry}, #metavar:String, #term: Text4_text_sort, #boundvars: List<Text4_text_sort>,
                #storage: Storage) -> {String : JEnvEntry}
→ JSetValue(#env,  "meta", JMapMeta(MapPut(JGetMetas(#env), #metavar, JMetaVar(#term, #boundvars, #storage))))

// --- Variable

func JGetVars({String : JEnvEntry}) -> {String : JVarEntry}
rule JGetVars(#env) → JGetValue(#env, "vars", (x) -> UnJMapVar(x))

func JGetVar({String : JEnvEntry}, String) -> Text4_text_sort
rule JGetVar(#env, #var) → UnJVarVar(UnSOME(MapGetVar(JGetVars(#env), #var)))

func JGetVarO({String : JEnvEntry}, String) -> Option<JVarEntry>
rule JGetVarO(#env, #var) → MapGetVar(JGetVars(#env), #var)

func JAddVar(#env: {String : JEnvEntry}, #var:String /* TODO: Core_cterm_sort */, #entry:JVarEntry) -> {String : JEnvEntry}
→ JSetValue(#env, "vars", JMapVar(MapPutVar(JGetVars(#env), #var, #entry)))

// --- Parent term

func GetParent({String : JEnvEntry}) -> Text4_text_sort
rule GetParent(#env) → JGetValue<Text4_text_sort>(#env, "parent", (x) -> UnJText(x))

func SetParent({String : JEnvEntry}, Text4_text_sort) -> {String : JEnvEntry}
rule SetParent(#env, #parent)
→ JSetValue(#env, "parent",  JText(#parent))

// --- sub index

func GetSubIndex({String : JEnvEntry}) -> Numeric
rule GetSubIndex(#env) → JGetValue<Numeric>(#env, "subindex", (x) -> UnJNum(x))

func SetSubIndex({String : JEnvEntry}, Numeric) -> {String : JEnvEntry}
rule SetSubIndex(#env, #index)
→ JSetValue(#env, "subindex", JNum(#index))

// --- sub binder index

func GetSubBinderIndex({String : JEnvEntry}) -> Numeric
rule GetSubBinderIndex(#env) → JGetValue<Numeric>(#env, "binderindex", (x) -> UnJNum(x))

func SetSubBinderIndex({String : JEnvEntry}, Numeric) -> {String : JEnvEntry}
rule SetSubBinderIndex(#env, #index)
→ JSetValue(#env, "binderindex", JNum(#index))

func IncSubBinderIndex({String : JEnvEntry}) -> {String : JEnvEntry}
rule IncSubBinderIndex(#env)
→ JSetValue(#env, "binderindex", JNum(Plus(GetSubBinderIndex(#env), 1)))

// --- Bound variable counter

func JGetCounter(#env:{String : JEnvEntry}) -> Numeric
→ JGetValue(#env, "counter", (x) -> UnJNum(x))

func JSetCounter(#env:{String : JEnvEntry}, #index:Numeric) -> {String : JEnvEntry}
→ JSetValue(#env, "counter", JNum(#index))

func JIncCounter(#env:{String : JEnvEntry}) -> {String : JEnvEntry}
→ JSetValue(#env, "counter", JNum(Plus(JGetCounter(#env), 1)))

// --- Fresh variable counter

func JGetFreshCounter(#env: {String : JEnvEntry}) -> Numeric
→ JGetValue(#env, "fcounter", (x) -> UnJNum(x))

func JSetFreshCounter(#env: {String : JEnvEntry}, #index:Numeric) -> {String : JEnvEntry}
→ JSetValue(#env, "fcounter", JNum(#index))

func JIncFreshCounter(#env: {String : JEnvEntry}) -> {String : JEnvEntry}
→ JSetValue(#env, "fcounter", JNum(Plus(JGetFreshCounter(#env), 1)))

// --- Lambda parameter counter

func JGetParamCounter(#env: {String : JEnvEntry}) -> Numeric
→ JGetValue(#env, "pcounter", (x) -> UnJNum(x))

func JSetParamCounter(#env: {String : JEnvEntry}, #index:Numeric) -> {String : JEnvEntry}
→ JSetValue(#env, "pcounter", JNum(#index))

func JIncParamCounter(#env: {String : JEnvEntry}) -> {String : JEnvEntry}
→ JSetValue(#env, "pcounter", JNum(Plus(JGetParamCounter(#env), 1)))

// --- Context

func GetContext({String : JEnvEntry}) -> Text4_text_sort
rule GetContext(#env) → JGetValue<Text4_text_sort>(#env, "context", (x) -> UnJContext(x))

func GetContextCount({String : JEnvEntry}) -> Numeric
rule GetContextCount(#env) → JGetValue<Numeric>(#env, "context", (x) -> UnJContextCount(x))

func SetContext({String : JEnvEntry}, Text4_text_sort, Numeric) -> {String : JEnvEntry}
rule SetContext(#env, #context, #count) → JSetValue(#env, "context", JContext(#context, #count))

func NewContext({String : JEnvEntry}) -> {String : JEnvEntry}
rule NewContext(#env)
→ SetContext(#env, text⟦c†⟨NumberToText(GetContextCount(#env))⟩⟧, Plus(GetContextCount(#env), 1))

// --- function annotation

func GetFnAnno({String : JEnvEntry}) -> List<Core_canno_sort>
rule GetFnAnno(#env) → JGetValue(#env, "fnanno", (x) -> UnJFnAnno(x))

func SetFnAnno({String : JEnvEntry}, List<Core_canno_sort>) -> {String : JEnvEntry}
rule SetFnAnno(#env, #anno*) → JSetValue(#env, "fnanno", JFnAnno(#anno*))

// --- List of top-level terms to release before contraction

func JGetDiscard(#env: {String : JEnvEntry}) -> List<Text4_text_sort>
→ JGetValue(#env, "discard", (x) -> UnJTexts(x))

func JSetDiscard(#env: {String : JEnvEntry}, #terms: List<Text4_text_sort>) -> {String : JEnvEntry}
→ JSetValue(#env, "discard", JTexts(#terms))

func JAddDiscard(#env: {String : JEnvEntry}, #term:Text4_text_sort) -> {String : JEnvEntry}
→ JSetDiscard(#env, (#term, JGetDiscard(#env)...))

// --- Delayed map entries

func JGetDelayEntries(#env: {String : JEnvEntry}) -> {String:List<JMapEntry>}
→ JGetValue(#env, "delay", (x) -> UnJMapEntries(x))

func JSetDelayEntries(#env: {String : JEnvEntry}, #entries: {String:List<JMapEntry>}) -> {String : JEnvEntry}
→ JSetValue(#env, "delay", JMapEntries(#entries))

func JGetDelayEntriesForVar(#env: {String : JEnvEntry}, #var: String) -> List<JMapEntry>
→ IfPresent(MapGet(JGetDelayEntries(#env), #var), (entries)->entries, ()->())

func JDelayMapEntry(#env: {String : JEnvEntry}, #var: String, #entry: JMapEntry) -> {String : JEnvEntry}
→ JSetDelayEntries(#env, MapPut(JGetDelayEntries(#env), #var, Cons(#entry, JGetDelayEntriesForVar(#env, #var))))
