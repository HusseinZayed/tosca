// Copyright (c) 2016 IBM Corporation.

import std::core
import std::string
import std::num
import std::listdef
import std::pairdef
import std::text
import std::language
import std::text::Text4

import core::Core
import core::utils
import cg::cpp::cppenv
import systemdef

/* Enumerate the kinds of class corresponding to a form */
enum CppFormClassKind
  | CFC_CONS    /* Non variable class  */
  | CFC_VAR     /* Variable class */
  | CFC_VARUSE  /* Variable use class */

// --- Forward declarations

/* Generate data sort, data form and parameterized function forward declarations */
func CppForwardDecls(#decls: List<Core_cdecl_sort>) -> Text4_text_sort
→ TextFoldES(Map((decl) -> CppForwardDecl(decl), #decls))

func CppForwardDecl(Core_cdecl_sort) -> Text4_text_sort

  rule CppForwardDecl(cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧)
  → text⟦
    †⟨CppTemplatePrefix(#csortvars?)⟩
    class †⟨SortNameToCppClassName(#CONSTRUCTOR)⟩;
    †⟨TextFoldES(Map((cform) -> CppForwardForm(#CONSTRUCTOR, #csortvars?, cform), #cform*))⟩⟧

  rule CppForwardDecl(cdecl⟦ ##canno* ##EXTERN? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧)
  → CppFunctionDeclD({}, cdecl⟦ ##canno* ##EXTERN? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧, TRUE, TRUE)

  rule CppForwardDecl(#cdecl)
  → text⟦⟧

func CppForwardForm(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text4_text_sort

  rule CppForwardForm(#sortname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
  → text⟦
      †⟨CppTemplatePrefix(#csortvars?)⟩
      class †⟨ParamFormCppClassName(#CONSTRUCTOR, (), CFC_CONS)⟩;⟧

  rule CppForwardForm(#sortname, #csortvars?, cform⟦ allows-variable ⟧)
  → text⟦
      †⟨CppTemplatePrefix(#csortvars?)⟩
      class †⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩;

      †⟨CppTemplatePrefix(#csortvars?)⟩
      class †⟨ParamFormCppClassName(#sortname, (), CFC_VARUSE)⟩;⟧

// --- Data translation functions

/* Generate a method making new instances of the given form.
   @param `#sortname`
   @param `#csortvars?`
   @param `#cform`
   @param `#def` whether to generate the method definition in additition to its declaration.
*/
func CppMethodNew(String, List<Core_csortvars_sort>, Core_cform_sort, Bool) -> Text4_text_sort

  rule CppMethodNew(#sortname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧, #def)
  → text⟦
      †⟨CppTemplatePrefix(#csortvars?)⟩
      †⟨CppTypeRefName(#csortvars?, #sortname)⟩ †⟨CppNewMethodName(#CONSTRUCTOR)⟩(Context& ctx†⟨MaybeCppFormalParams(#csorts?, text⟦, ⟧, FALSE)⟩)†⟨
      If(#def, ()->text⟦{
       return (*new †⟨ParamFormCppClassName(#CONSTRUCTOR, #csortvars?, CFC_CONS)⟩(†⟨MaybeCppFormalParams(#csorts?, text⟦⟧, TRUE)⟩));
      }⟧, ()->text⟦;⟧)⟩
    ⟧

  rule CppMethodNew(#sortname, #csortvars?, cform⟦ allows-variable ⟧, #def)
  → text⟦
      †⟨CppTemplatePrefix(#csortvars?)⟩
      †⟨ParamFormCppClassName(#sortname, #csortvars?, CFC_VAR)⟩& †⟨CppFnName(ConcatString("var", #sortname))⟩(std::string&& hint)†⟨
      If(#def, ()->text⟦{
        return *(new †⟨ParamFormCppClassName(#sortname, #csortvars?, CFC_VAR)⟩(std::move(hint)));
      }⟧, ()->text⟦;⟧)⟩
    ⟧

/* Generate base lookup method (the 'as' method) for the given form.
   @param `#sortname`
   @param `#csortvars?`
   @param `#cform`
   @param `#def` whether to generate the method definition in additition to its declaration. */
func CppMethodAs(String, List<Core_csortvars_sort>, Core_cform_sort, Bool) -> Text4_text_sort

  rule CppMethodAs(#sortname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧, #def)
  → text⟦
    †⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
    †⟨TextIf(Not(#def), ()->text⟦virtual⟧)⟩ Optional<†⟨ParamFormCppClassName(#CONSTRUCTOR, #csortvars?, CFC_CONS)⟩> †⟨CppQualifier(#sortname, #csortvars?, #def)⟩†⟨CppAsMethodName(#CONSTRUCTOR)⟩(Context& ctx)†⟨
    If(#def, ()->text⟦{
       return Optional<†⟨ParamFormCppClassName(#CONSTRUCTOR, #csortvars?, CFC_CONS)⟩>::nullopt;
    }⟧, ()->text⟦;⟧)⟩⟧


  rule CppMethodAs(#sortname, #csortvars?, cform⟦ allows-variable ⟧, #def)
  → text⟦⟧

/* Generate typed use method. */
func CppVarMethodUse(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦
    †⟨CppTemplatePrefix(#csortvars?)⟩
    †⟨SortNameToCppClassName(#sortname)⟩†⟨MaybeCppTypeArguments(#csortvars?)⟩& †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩Use()†⟨
      If(#def, ()->text⟦{
       return (*new †⟨ParamFormCppClassName(#sortname, #csortvars?, CFC_VARUSE)⟩(*this));
      }⟧, ()->text⟦;⟧)⟩
  ⟧

/* Generate untyped use method. */
func CppVarMethodGUse(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦
    †⟨CppTemplatePrefix(#csortvars?)⟩
    tosca::Term& †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩GUse()†⟨
      If(#def, ()->text⟦{
       return Use();
      }⟧, ()->text⟦;⟧)⟩
  ⟧
/* Generate class constructor corresponding to the given `#formname`. */
func CppFormConstructor(#sortname: String, #csortvars?: List<Core_csortvars_sort>, #formname: String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ text⟦
    †⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
    †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩†⟨FormCppClassName(#formname)⟩(†⟨MaybeCppFormalParams(#csorts?, text⟦⟧, FALSE)⟩)†⟨
    If(#def,
      ()->text⟦†⟨TextIf(HasSorts(#csorts?),
        ()->text⟦: †⟨MaybeCppClassFields(#csorts?, (isvar type index subindex)->CppInitField(isvar, type, index, subindex))⟩⟧)⟩{}⟧,
      ()->text⟦;⟧)⟩⟧

/* Generate method Use corresponding to the given `#sortname`. */
func CppVarConstructorUse(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦
   †⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
   †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VARUSE, #def)⟩†⟨FormCppClassName(#sortname)⟩Use(†⟨ParamFormCppClassName(#sortname, #csortvars?, CFC_VAR)⟩& v)†⟨
   If(#def,
     ()->text⟦: tosca::VariableUse::VariableUse(v) {}⟧,
     ()->text⟦;⟧)⟩
  ⟧

/* Generate base method GetVariable corresponding to the given `#sortname`. */
func CppMethodGetVariable(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦
   †⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
   †⟨TextIf(Not(#def), ()->text⟦virtual⟧)⟩ Optional<†⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩> †⟨CppQualifier(#sortname, #csortvars?, #def)⟩GetVariable() const†⟨
   If(#def,
     ()->text⟦{
         return Optional<†⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩>::nullopt;
       }⟧,
     ()->text⟦;⟧)⟩
  ⟧

/* Generate method GetVariable corresponding to the given `#sortname`. */
func CppVarMethodGetVariable(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦
   †⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
   Optional<†⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩> †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VARUSE, #def)⟩GetVariable() const†⟨
   If(#def,
     ()->text⟦{
         return make_optional<†⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩>(*dynamic_cast<†⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩*>(&VariableUse::GetGVariable().value()));
       }⟧,
     ()->text⟦;⟧)⟩
  ⟧

/* Generate the variable class constructor for the given `#sortname`. */
func CppVarConstructorVar(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦
   †⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
   †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩(std::string&& name)†⟨
   If(#def,
     ()->text⟦: tosca::Variable(std::move(name)) {}⟧,
     ()->text⟦;⟧)⟩
  ⟧

/* Generate overridden lookup method (the 'as' method) for the given `formname`. */
func CppFormMethodAs(String, List<Core_csortvars_sort>, String, Bool) -> Text4_text_sort
rule CppFormMethodAs(#sortname, #csortvars?, #formname, #def)
→ text⟦
  †⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
  Optional<†⟨ParamFormCppClassName(#formname, #csortvars?, CFC_CONS)⟩> †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩†⟨CppAsMethodName(#formname)⟩(Context& ctx)†⟨
  If(#def, ()->text⟦{
     return make_optional<†⟨ParamFormCppClassName(#formname, #csortvars?, CFC_CONS)⟩>(*this);
  }⟧, ()->text⟦;⟧)⟩⟧

/* Generate overridden copy method for the given form.   */
func CppFormMethodCopy(String, List<Core_csortvars_sort>, String, Bool) -> Text4_text_sort
  rule CppFormMethodCopy(#sortname, #csortvars?, #formname, #def)
  → text⟦
    tosca::Term †⟨CppQualifier(#formname, #csortvars?, #def)⟩Copy(Context& ctx)†⟨
    If(#def, ()->text⟦{
       return (*new †⟨ParamFormCppClassName(#formname, #csortvars?, CFC_CONS)⟩());
    }⟧, ()->text⟦;⟧)⟩⟧

/* Generate getValue method for the given `formname`. */
func CppFormGetValue(String, List<Core_csortvars_sort>, String,  List<Core_csorts_sort>, Bool) -> Text4_text_sort

  rule CppFormGetValue(#sortname, #csortvars?, #formname, #csorts?, #def)
  → MaybeCppClassFields(#csorts?, (isvar type index subindex)->
       CppGetValue(isvar, type, index, subindex, #def, TextIf(#def, ()->CppTemplatePrefix(#csortvars?)), CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)))

/* GetValue generator */
func CppGetValue(Bool, Text4_text_sort, Numeric, Numeric, Bool, Text4_text_sort, Text4_text_sort) -> Text4_text_sort

  rule CppGetValue(FALSE, #type, #index, #subindex, #def, #prefix, #qualifier)
  → text⟦†⟨#prefix⟩†⟨#type⟩& †⟨#qualifier⟩getValue†⟨NumberToText(#index)⟩(Context& ctx, bool mustforce)†⟨
      If(#def, ()->text⟦{
        if (mustforce)
         †⟨FieldName(#index)⟩ = force(ctx, †⟨FieldName(#index)⟩);
        return †⟨FieldName(#index)⟩;
      }⟧, ()->text⟦;⟧)⟩⟧

  rule CppGetValue(TRUE, #type, #index, #subindex, #def, #prefix, #qualifier)
  → text⟦†⟨#prefix⟩†⟨#type⟩& †⟨#qualifier⟩getVar†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩()†⟨
      If(#def, ()->text⟦{
        return †⟨VarFieldName(#index, #subindex)⟩;
      }⟧, ()->text⟦;⟧)⟩⟧

// --- Generate code for class field declarations, initialization, lookup, and update

/* Generic form sorts traversal */
func MaybeCppClassFields(List<Core_csorts_sort>, (Bool Text4_text_sort Numeric Numeric)->Text4_text_sort) -> Text4_text_sort

  rule MaybeCppClassFields(csorts?⟦⟧, #print)
  → text⟦⟧

  rule MaybeCppClassFields(csorts?⟦ ( ##csort* ) ⟧, #print)
  → CppClassFields(#csort*, 1, #print)

func CppClassFields(List<Core_csort_sort>, Numeric, (Bool Text4_text_sort Numeric Numeric)->Text4_text_sort) -> Text4_text_sort
  rule CppClassFields(csort*⟦⟧, #index, #print)
  → text⟦⟧

  rule CppClassFields(csort*⟦ ##csort ##csort* ⟧, #index, #print)
  → text⟦†⟨CppClassField(CppTypes(#csort), #index, 1, #print)⟩†⟨CppClassFields(#csort*, Plus(#index, 1), #print)⟩⟧

func CppClassField(List<Text4_text_sort>, Numeric, Numeric, (Bool Text4_text_sort Numeric Numeric)->Text4_text_sort) -> Text4_text_sort
  rule CppClassField(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex, #print)
  → #print(FALSE, #type, #index, #subindex)

  rule CppClassField(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex, #print)
  → text⟦†⟨#print(TRUE, #type, #index, #subindex)⟩†⟨CppClassField(#types, #index, Plus(#subindex, 1), #print)⟩⟧

func FieldName(#index: Numeric) -> Text4_text_sort
→ text⟦field†⟨NumberToText(#index)⟩⟧

func VarFieldName(#index: Numeric, #subindex: Numeric) -> Text4_text_sort
→ text⟦field†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩⟧

/* Print separator when not first field */
func FieldSep(#sep: Text4_text_sort, #index: Numeric, #subindex: Numeric) -> Text4_text_sort
→ TextIf(Not(And(NumberEqual(#index, 1), NumberEqual(#subindex, 1))), ()->#sep)

/* Field initialization helper */
func CppInitField(Bool, Text4_text_sort, Numeric, Numeric) -> Text4_text_sort
rule CppInitField(FALSE, #type, #index, #subindex) → text⟦†⟨FieldSep(text⟦, ⟧, #index, #subindex)⟩†⟨FieldName(#index)⟩(†⟨ParamName(#index)⟩)⟧
rule CppInitField(TRUE, #type, #index, #subindex)  → text⟦†⟨FieldSep(text⟦, ⟧, #index, #subindex)⟩†⟨VarFieldName(#index, #subindex)⟩(†⟨VarParamName(#index, #subindex)⟩)⟧

// --- Function translation functions

func CppFunctionDecl(#env: {String : EnvEntry}, #key: String, #header: Bool) -> Text4_text_sort
→ CppFunctionDeclD(#env, UnSOME(GetFuncSort(GetContent(#env), #key)), #header, FALSE)

func CppFunctionDeclD({String : EnvEntry}, Core_cdecl_sort, Bool, Bool) -> Text4_text_sort
rule CppFunctionDeclD(#env, cdecl⟦ ##canno* ##EXTERN? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧, #header, #forward)
→ TextIf(And(Not(HasAnnotation("Extern", #canno*)), Or(#forward, Or(And(#header, Not(IsEmpty(#csortvars?))), And(Not(#header), IsEmpty(#csortvars?))))), ()->
  text⟦
   †⟨CppTemplatePrefix(#csortvars?)⟩
   †⟨CppTypeRef(#csort)⟩ †⟨CppFnName(#CONSTRUCTOR)⟩(tosca::Context& ctx†⟨CppMaybeFunctionParams(SetContext(SetFnAnno(#env, #canno*), text⟦ctx⟧, 1), #csorts?, (env) ->
      CppMaybeBody(env, #CONSTRUCTOR, GenBody(#csortvars?, #header, #forward)))⟩⟧) // missing )

func CppMaybeFunctionParams({String : EnvEntry}, List<Core_csorts_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
   rule CppMaybeFunctionParams(#env, csorts?⟦⟧, #cont)
   → #cont(#env)

   rule CppMaybeFunctionParams(#env, csorts?⟦ ( ##csort* ) ⟧, #cont)
   → CppFunctionParams(NewParams(#env), #csort*, #cont)

/* Generate method signature and record the argument names in the environment, keeping them in order */
func CppFunctionParams({String : EnvEntry}, List<Core_csort_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppFunctionParams(#env, csort*⟦ ⟧, #cont)
   → #cont(#env)

  rule CppFunctionParams(#env, csort*⟦ ##csort ##csort* ⟧, #cont)
  → CppFunctionParam(#env, CppTypes(#csort), #csort, (env) -> CppFunctionParams(env, #csort*, #cont))

func CppFunctionParam({String : EnvEntry}, List<Text4_text_sort>, Core_csort_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // Monomorphic sort
  rule CppFunctionParam(#env, Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), csort⟦ ##CONSTRUCTOR ##csorts? ⟧, #cont)
  → text⟦, †⟨#type⟩& ⟨STRING: value:String⟩†⟨#cont(AddParam(#env, text⟦⟨STRING: value⟩⟧, csort⟦ ##CONSTRUCTOR ##csorts? ⟧))⟩⟧

  // Sort variable
  rule CppFunctionParam(#env, Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), csort⟦ ##VARIABLE ⟧, #cont)
  → text⟦, †⟨#type⟩& ⟨STRING: value:String⟩†⟨#cont(AddParam(#env, text⟦⟨STRING: value⟩⟧, csort⟦ ##VARIABLE ⟧))⟩⟧

  // Syntactic variable sort
 rule CppFunctionParam(#env, Cons(#type:Text4_text_sort, #types: List<Text4_text_sort>), csort⟦ [ ##csort ] ##csort2 ⟧, #cont)
 → text⟦, †⟨#type⟩& ⟨STRING: var:String⟩†⟨
     CppFunctionParam(AddParam(#env, text⟦⟨STRING: var⟩⟧, #csort), #types, #csort2, #cont)⟩⟧

 // Formal parameter sort
 rule CppFunctionParam(#env, #types, csort⟦ ( ##csort ) ##csort2 ⟧, #cont)
 → CppFunctionParam(#env, #types, #csort2, #cont)

 rule CppFunctionParam(#env, (#type, ), csort⟦ { ##cmapsort* } ⟧, #cont)
 → text⟦, †⟨#type⟩& ⟨STRING: map:String⟩†⟨
     #cont(AddParam(#env, text⟦⟨STRING: map⟩⟧, csort⟦ { ##cmapsort* } ⟧))⟩⟧

 rule CppFunctionParam(#env, #types, csort⟦ data ##csort ⟧, #cont)
 → CppFunctionParam(#env, #types, #csort, #cont)

 rule CppFunctionParam(#env, #types, csort⟦ thunk ##csort ⟧, #cont)
 → CppFunctionParam(#env, #types, #csort, #cont)

/* Generate function body. See GenBody for the exact condition. */
func CppMaybeBody({String : EnvEntry}, String, Bool /* generate body? */) -> Text4_text_sort
rule CppMaybeBody(#env, #key, FALSE) → text⟦);⟧
rule CppMaybeBody(#env, #key, TRUE)  → text⟦) †⟨CppBody(#env, GetRulesForKeyC(GetContent(#env), #key))⟩⟧

func CppBody({String : EnvEntry}, Option<List<Core_cdecl_sort>>) -> Text4_text_sort

// No rules: it must be an external function (not yet checked but should)
  rule CppBody(#env, NONE)
  → text⟦;⟧

  // At least one rule: not external
  rule CppBody(#env, SOME(#rules))
  → text⟦{
      †⟨TextMapFoldES((r) -> CppBodyRule(NewMetas(NewVars(#env)), r), #rules)⟩
      †⟨TextIf(Not(HasAnnotation("Fallback", GetFnAnno(#env))), ()->text⟦throw std::runtime_error("Missing case");⟧)⟩}⟧

// --- Start method body

func CppBodyRule({String : EnvEntry}, Core_cdecl_sort) -> Text4_text_sort

  rule CppBodyRule(#env, cdecl⟦ rule ##CONSTRUCTOR → ##cterm ⟧)
  → CppContractum(#env, #cterm)

  rule CppBodyRule(#env, cdecl⟦ rule ##CONSTRUCTOR ( ##cterm* ) → ##cterm2 ⟧)
  → CppPattern(#env, #cterm*, #cterm2)

// --- Pattern matching

func CppPattern({String : EnvEntry}, List<Core_cterm_sort>, Core_cterm_sort) -> Text4_text_sort
rule CppPattern(#env, #cterms, #contractum) → CppCasePattern(SetDelayEntries(#env, {}), #cterms, #contractum)

// Data sort helper indicating whether the current term is a method parameter, or an argument (local variable).
enum Storage | PARAMETER | ARGUMENT

// Iterate over top-level pattern arguments
func CppCasePattern({String : EnvEntry}, List<Core_cterm_sort>, Core_cterm_sort) -> Text4_text_sort

  rule CppCasePattern(#env, cterm*⟦ ⟧, #contractum)
  → CppContractum(#env, #contractum)

  rule CppCasePattern(#env, cterm*⟦ ##cterm ##cterm* ⟧, #contractum)
  → CppPatternTerm(NextParam(#env), #cterm, CurrentParam(#env), SOME(CurrentParamSort(#env)), PARAMETER,
    (env) -> CppCasePattern(env, #cterm*, #contractum))

// --- Term pattern matching

func CppPatternTerm({String : EnvEntry}, Core_cterm_sort, Text4_text_sort /* Current term */,
                       Option<Core_csort_sort> /* Sort when known */, Storage, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternTerm(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #term, #csort, #storage, #cont)
  → text⟦
      †⟨ForceParameter(#env, #term, #storage)⟩
      auto ⟨STRING: value:String⟩ = †⟨#term⟩.†⟨CppAsMethodName(#CONSTRUCTOR)⟩(†⟨GetContext(#env)⟩);
      if (⟨STRING: value⟩) {
        †⟨CppPatternMaybeSubs(#env, #cterms?, text⟦⟨STRING: value⟩⟧, MaybeFindFormC(GetContent(#env), #csort, #CONSTRUCTOR), #cont)⟩
      }⟧

  // TODO: check literal
  rule CppPatternTerm(#env, cterm⟦ ##cliteral ⟧, #term, #csort, #storage, #cont)
  → #cont(#env)

  // REVISIT: bound variable reordering, ie. (x)(y)#(y, x)
  // For now only accepts patterns of the form (x)...(y)#(x, ... y)
  rule CppPatternTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #term, #csort, #storage, #cont)
  → text⟦†⟨CppPatternMaybeMetaArgs(#env, #METAVAR, #csubst?, #term, #csort, #cont)⟩⟧

  rule CppPatternTerm(#env, cterm⟦ ##canno* ##VARIABLE  ##csortanno? ⟧, #term, #csort, #storage, #cont)
  → CppPatternVariable(MaybeGetVar(#env, #VARIABLE), #env, #VARIABLE, MaybeSortAnnoToSort(#csortanno?), #term, #cont)

  rule CppPatternTerm(#env, cterm⟦ { ##cmapentries? } : { ##cmapsort } ⟧, #term, #csort, #storage, #cont)
  → CppPatternMap(#env, #cmapentries?, #term, #cmapsort, #cont)

  rule CppPatternTerm(#env, cterm⟦ [ v ##csortanno?[] ] ##cterm[v] ⟧, #term, #csort, PARAMETER, #cont)
  → CppPatternTerm(NextParam(AddVar(#env, var, Bound(#term, MaybeSortAnnoToSort(#csortanno?)))), #cterm[var], CurrentParam(#env), SOME(CurrentParamSort(#env)), PARAMETER, #cont)

  rule CppPatternTerm(#env, cterm⟦ [ v : ##csort ] ##cterm[v] ⟧, #term, #sort, ARGUMENT, #cont)
  → text⟦
      C†⟨CppType(#csort)⟩Var& ⟨STRING: boundvar:String⟩ = †⟨GetParent(#env)⟩.value().getVar†⟨NumberToText(GetSubIndex(#env))⟩_†⟨NumberToText(GetSubBinderIndex(#env))⟩();†⟨
      CppPatternTerm(IncSubBinderIndex(AddVar(#env, var, Bound(text⟦⟨STRING: boundvar⟩⟧, SOME(#csort)))), #cterm[var], #term, #sort, ARGUMENT, #cont)⟩⟧

  rule CppPatternTerm(#env, cterm⟦ ( f  ##csortanno? ) ##cterm[f] ⟧, #term, #csort, #storage, #cont)
  → CppPatternTerm(#env, #cterm[var:String], #term, #csort, #storage, #cont)

// Pattern matching on construction arguments.
func CppPatternMaybeSubs( {String : EnvEntry}, List<Core_cterms_sort>, Text4_text_sort, Option<PPair<Core_cdecl_sort Core_cform_sort>>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMaybeSubs(#env, cterms?⟦⟧, #term, #cform, #cont)
  → #cont(#env)

  rule CppPatternMaybeSubs(#env, cterms?⟦()⟧, #term, #cform, #cont)
  → #cont(#env)

  rule CppPatternMaybeSubs(#env, cterms?⟦ ( ##cterm* ) ⟧, #term, SOME(PPair<Core_cdecl_sort Core_cform_sort>::PairCons(#cdecl:Core_cdecl_sort, cform⟦ ##CONSTRUCTOR ( ##csort* ) ⟧)), #cont)
  → CppPatternSubs(#env, #cterm*, #term, 1, SOME(#csort*), #cont)

  rule CppPatternMaybeSubs(#env, cterms?⟦ ( ##cterm* ) ⟧, #term, NONE, #cont)
  → CppPatternSubs(#env, #cterm*, #term, 1, NONE, #cont)

  func CppPatternSubs( {String : EnvEntry}, List<Core_cterm_sort>,
                     Text4_text_sort /* parent term */, Numeric /* Current subindex */, Option<List<Core_csort_sort>>, /* sub sorts, if known */
                     ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternSubs(#env, cterm*⟦⟧,  #term, #index, #csort*, #cont)
  → #cont(#env)

  rule CppPatternSubs(#env, cterm*⟦ ##cterm ##cterm* ⟧, #term, #index, #csort*, #cont)
  → text⟦
      auto& ⟨STRING: sub:String⟩ = †⟨#term⟩.value().getValue†⟨NumberToText(#index)⟩(†⟨GetContext(#env)⟩, true);†⟨
      CppPatternTerm(SetSubBinderIndex(SetParent(SetSubIndex(#env, #index), #term), 1),
                  #cterm, text⟦⟨STRING: sub⟩⟧, SubSort(#env, #cterm, #csort*), ARGUMENT,
                  (x) -> CppPatternSubs(x, #cterm*, #term, NumberPlus(#index, 1), Maybe<List List>((x)->Tail<Core_csort_sort>(x), #csort*), #cont))⟩⟧


  // --- Variable pattern matching outside of meta

func CppPatternVariable(Option<VarEntry>, {String : EnvEntry}, String, Option<Core_csort_sort>, Text4_text_sort /* Current term */, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // First variable occurrence: the term is a free variable.
  rule CppPatternVariable(NONE, #env, #variable, #csort, #term, #cont)
  → text⟦
      Optional<C†⟨MaybeCppTypeD(#csort, text⟦⟧)⟩Var> ⟨STRING: ovar⟩ = †⟨#term⟩.GetVariable();
      if (⟨STRING: ovar⟩)
      {
        C†⟨MaybeCppTypeD(#csort, text⟦⟧)⟩Var& ⟨STRING: var⟩ = ⟨STRING: ovar⟩.value();
        †⟨CppApplyDelayEntries(AddVar(#env, #variable, Free(text⟦⟨STRING: var⟩⟧, #csort)), #variable, #cont)⟩
      }⟧

  rule CppPatternVariable(SOME(Bound(#var, #sort)), #env, #variable, #csort, #term, #cont)
  → text⟦
      Optional<C†⟨MaybeCppTypeD(#csort, text⟦⟧)⟩Var> ⟨STRING: ovar⟩ = †⟨#term⟩.GetVariable();
      if (⟨STRING: ovar⟩ && †⟨#var⟩ == ⟨STRING: ovar⟩.value()) {
        †⟨#cont(#env)⟩
      }⟧

  // --- pattern matching inside meta

// Iterate over meta arguments and find corresponding bound variables, and update environment
func CppPatternMaybeMetaArgs({String : EnvEntry}, String, List<Core_csubst_sort>, Text4_text_sort /* Current term */, Option<Core_csort_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMaybeMetaArgs(#env, #metavar, csubst?⟦⟧, #term, #csort, #cont)
  → CppApplyDelayEntries(AddMeta(#env, #metavar, #term, ()), #metavar, #cont)

  // meta substitution
  rule CppPatternMaybeMetaArgs(#env, #metavar, csubst?⟦ [ ##cterm* ] ⟧, #term, #csort, #cont)
  → #cont(AddMeta(#env, #metavar, #term, Map((x) -> CppFindBoundVar(#env, x), #cterm*)))

  func CppFindBoundVar( {String : EnvEntry},Core_cterm_sort) -> Text4_text_sort

  rule CppFindBoundVar(#env, cterm⟦ ##VARIABLE ⟧)
  → GetVar(#env, #VARIABLE)

  rule CppFindBoundVar(#env, #cterm)
  → Error(ConcatString("Invalid argument in metavariable: ", PrintTerm("", #cterm)))

  // --- Map pattern matching

func CppPatternMap({String : EnvEntry}, List<Core_cmapentries_sort>, Text4_text_sort, Core_cmapsort_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMap(#env, cmapentries?⟦⟧, #term, #cmapsort, #cont)
  → text⟦
      †⟨#term⟩ = force(ctx, †⟨#term⟩);
      if (†⟨#term⟩.isEmpty())
      {
        †⟨#cont(#env)⟩
      }
    ⟧

  rule CppPatternMap(#env, cmapentries?⟦ ##cmapentry* ⟧, #term, #cmapsort, #cont)
  → CppPatternMapEntries(#env, #cmapentry*, #term, #cmapsort, #cont)

func CppPatternMapEntries({String : EnvEntry}, List<Core_cmapentry_sort>, Text4_text_sort, Core_cmapsort_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMapEntries(#env, cmapentry*⟦ ##cmapentry ##cmapentry* ⟧, #term, #cmapsort, #cont)
  → CppPatternMapEntry(#env, #cmapentry, #term, #cmapsort, (env)->CppPatternMapEntries(env, #cmapentry*, #term, #cmapsort, #cont))

  rule CppPatternMapEntries(#env, cmapentry*⟦  ⟧, #term, #cmapsort, #cont)
  → #cont(#env)

func CppPatternMapEntry({String : EnvEntry}, Core_cmapentry_sort, Text4_text_sort, Core_cmapsort_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMapEntry(#env, cmapentry⟦ : ##METAVAR ⟧, #term, #cmapsort, #cont)
  → #cont(AddMeta(#env, #METAVAR, #term, ()))

  rule CppPatternMapEntry(#env, cmapentry⟦  ¬ ##METAVAR ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetMetaVarO(#env, #METAVAR),
      (key)->text⟦
        †⟨key⟩ = force(ctx, †⟨key⟩);
        if (!†⟨#term⟩.contains(†⟨key⟩))
        {
          †⟨#cont(#env)⟩
        }⟧,
      ()->#cont(DelayMapEntry(#env, #METAVAR, MapEntry(cmapentry⟦ ¬ ##METAVAR ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ##METAVAR : ##cterm ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetMetaVarO(#env, #METAVAR),
      (key)->text⟦
        †⟨key⟩ = force(ctx, †⟨key⟩);
        auto ⟨STRING: mval⟩ = †⟨#term⟩.getValue(†⟨GetContext(#env)⟩, †⟨key⟩).asSOME(†⟨GetContext(#env)⟩);
        if (⟨STRING: mval⟩)
        {
          †⟨CppType(GetMapValueSort(#cmapsort))⟩& ⟨STRING: value⟩ = ⟨STRING: mval⟩.value().getValue1(ctx, true);
          †⟨CppPatternTerm(#env, #cterm, text⟦⟨STRING: value⟩⟧, SOME(GetMapValueSort(#cmapsort)), ARGUMENT, #cont)⟩
        }
      ⟧,
      ()->#cont(DelayMapEntry(#env, #METAVAR, MapEntry(cmapentry⟦ ##METAVAR : ##cterm ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ##VARIABLE ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetVarO(#env, #VARIABLE),
      (key)->text⟦
        if (!†⟨#term⟩.containsVar(†⟨UnVarVar(key)⟩.GetVariable()))
        {
           †⟨#cont(#env)⟩
        }
      ⟧,
      ()->#cont(DelayMapEntry(#env, #VARIABLE, MapEntry(cmapentry⟦ ##VARIABLE ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ¬ ##VARIABLE ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetVarO(#env, #VARIABLE),
      (key)->text⟦
        if (†⟨#term⟩.containsVar(†⟨UnVarVar(key)⟩.GetVariable()))
        {
          †⟨#cont(#env)⟩
        }
      ⟧,
      ()->#cont(DelayMapEntry(#env, #VARIABLE, MapEntry(cmapentry⟦ ¬ ##VARIABLE ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ##VARIABLE : ##cterm ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetVarO(#env, #VARIABLE),
      (key)->text⟦
        auto ⟨STRING: mval⟩ = †⟨#term⟩.getValue(†⟨GetContext(#env)⟩, †⟨UnVarVar(key)⟩.Use()).asSOME(†⟨GetContext(#env)⟩);
        if (⟨STRING: mval⟩)
        {
          †⟨CppType(GetMapValueSort(#cmapsort))⟩& ⟨STRING: value⟩ = ⟨STRING: mval⟩.value().getValue1(ctx, true);
          †⟨CppPatternTerm(#env, #cterm, text⟦⟨STRING: value⟩⟧, SOME(GetMapValueSort(#cmapsort)), ARGUMENT, #cont)⟩
        }⟧,
      ()->#cont(DelayMapEntry(#env, #VARIABLE, MapEntry(cmapentry⟦ ##VARIABLE : ##cterm ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ##STRING ⟧, #term, #cmapsort, #cont)
  → text⟦
      if (†⟨#term⟩.contains(†⟨CppExprLiteral(cliteral⟦ ##STRING ⟧)⟩))
      {
        †⟨#cont(#env)⟩
      }⟧

  rule CppPatternMapEntry(#env, cmapentry⟦ ¬ ##STRING ⟧, #term, #cmapsort, #cont)
  → text⟦
      if (!†⟨#term⟩.contains(†⟨CppExprLiteral(cliteral⟦ ##STRING ⟧)⟩))
      {
        †⟨#cont(#env)⟩
      }⟧

  rule CppPatternMapEntry(#env, cmapentry⟦ ##STRING  : ##cterm ⟧, #term, #cmapsort, #cont)
 → text⟦
      auto ⟨STRING: mval⟩ = †⟨#term⟩.getValue(†⟨GetContext(#env)⟩, †⟨CppExprLiteral(cliteral⟦ ##STRING ⟧)⟩).asSOME(†⟨GetContext(#env)⟩);
      if (⟨STRING: mval⟩)
      {
        †⟨CppType(GetMapValueSort(#cmapsort))⟩& ⟨STRING: value⟩ = ⟨STRING: mval⟩.value().getValue1(ctx, true);;
        †⟨CppPatternTerm(#env, #cterm, text⟦⟨STRING: value⟩⟧, SOME(GetMapValueSort(#cmapsort)), ARGUMENT, #cont)⟩
      }⟧


/* Apply delayed map entries waiting for the given `#var` (meta or not) to be initialized */
func CppApplyDelayEntries(#env: {String : EnvEntry}, #var: String, #cont:({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
→ CppApplyDelayEntriesAux(#env, GetDelayEntriesForVar(#env, #var), #cont)

func CppApplyDelayEntriesAux({String : EnvEntry}, List<MapEntry>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
rule CppApplyDelayEntriesAux(#env, Cons(MapEntry(#cmapentry, #term, #cmapsort), #entries), #cont) → CppPatternMapEntry(#env, #cmapentry, #term, #cmapsort, (env)->CppApplyDelayEntriesAux(env, #entries, #cont))
rule CppApplyDelayEntriesAux(#env, Nil                                                    , #cont) → #cont(#env)

//  --------- Helper function for pattern matching

/* Generate force call if term is a parameter */
func ForceParameter({String : EnvEntry}, Text4_text_sort, Storage) -> Text4_text_sort
  rule ForceParameter(#env, #term, PARAMETER) →  text⟦†⟨#term⟩ = force(†⟨GetContext(#env)⟩, †⟨#term⟩);⟧
  rule ForceParameter(#env, #term, #storage)  →  text⟦⟧

/* Get sub sort. Get it from term and if not available on sort */
func SubSort(#env: {String : EnvEntry}, #cterm: Core_cterm_sort, #csorts?: Option<List<Core_csort_sort>>) -> Option<Core_csort_sort>
→ SubSort2(SubSortFromTerm(#env, #cterm), #csorts?)

func SubSort2(Option<Core_csort_sort>, Option<List<Core_csort_sort>>) -> Option<Core_csort_sort>
  rule SubSort2(SOME(#csort:Core_csort_sort), #)       → SOME(#csort)
  rule SubSort2(NONE, NONE)                            → NONE
  rule SubSort2(NONE, SOME(csort*⟦ ##csort ##csort* ⟧)) → SOME(#csort)

func SubSortFromTerm({String : EnvEntry}, Core_cterm_sort) -> Option<Core_csort_sort>

  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##cqconstructor ##csortargs? ##cterms? : ##csort ⟧)
  → SOME(#csort)

  rule SubSortFromTerm(#env, cterm⟦ ##STRING ⟧)
  → SOME(csort⟦ String ⟧)

  rule SubSortFromTerm(#env, cterm⟦ ##NUMBER ⟧)
  → SOME(csort⟦ Numeric⟧)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##VARIABLE ##csortanno? ⟧)
  → SubSortFromVar(MaybeGetVar(#env, #VARIABLE), #VARIABLE)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧)
  → MaybeSortAnnoToSort(#csortanno?)

  rule SubSortFromTerm(#env, cterm⟦ { ##cmapentries? } ##csortanno? ⟧)
  → MaybeSortAnnoToSort(#csortanno?)

  // TODO: maybe error?
  rule SubSortFromTerm(#env, cterm⟦ [ x ##csortanno?[] ] ##cterm[x] ⟧)
  → SubSortFromTerm(#env, #cterm[var:String])

  // TODO: maybe error?
  rule SubSortFromTerm(#env, cterm⟦ ( f ##csortanno?[] ) ##cterm[f] ⟧)
  → SubSortFromTerm(#env, #cterm[var:String])

func SubSortFromVar(Option<VarEntry>, String) -> Option<Core_csort_sort>
rule SubSortFromVar(NONE, #var)             → NONE
rule SubSortFromVar(SOME(#varEntry), #var)  → UnVarSort(#varEntry)

// ----- Contraction

func CppContractum(#env: {String : EnvEntry}, #term: Core_cterm_sort) -> Text4_text_sort
→ CppStatementTerm(SetTail(#env, TRUE), #term)

/* Generate the contraction code. Two passes are performed:
   - the first pass generates statements initializing fresh and bound variables. Variable names are deterministic using an internal counter
   - the second pass generates a single expression. Bound variables names are determinically recomputed
    */

func CppStatementTerm(#env: {String : EnvEntry}, #cterm: Core_cterm_sort) -> Text4_text_sort
→ text⟦†⟨CppFreshesTerm(SetCounter(SetFreshCounter(#env, 0), 0), #cterm, (env) ->
     text⟦†⟨TextIf(GetTail(env), ()->text⟦return ⟧)⟩†⟨CppExprTerm(SetCounter(env, 0), #cterm, (env) -> text⟦⟧)⟩;⟧)⟩⟧

// ---- Generate fresh variable - Only in Cpp statement mode

func CppFreshesTerm({String : EnvEntry}, Core_cterm_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppFreshesTerm(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #cont)
  → CppFreshesMaybeTerms(#env, #cterms?, #cont)

  rule CppFreshesTerm(#env, cterm⟦ ##canno* ##VARIABLE ##csortanno? ⟧, #cont)
  → CppFreshesVariable(#env, MaybeGetVar(#env, #VARIABLE), #VARIABLE, #csortanno?, TRUE, #cont)

  rule CppFreshesTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #cont)
  → CppFreshesMaybeTerms(#env, #cterms?, (env) -> CppFreshesMaybeSubst(env, #csubst?, #cont))

  rule CppFreshesTerm(#env, cterm⟦ [ x ##csortanno?[] ] ##cterm[x] ⟧, #cont)
  → CppFreshesVariable(#env, NONE, var, #csortanno?, FALSE, (env) -> CppFreshesTerm(env, #cterm[var], #cont))

  rule CppFreshesTerm(#env, cterm⟦ ( f ##csortanno?[] ) ##cterm[f] ⟧, #cont)
  → CppFreshesTerm(AddVar(#env, var, Formal(text⟦ dummy ⟧, NONE)), #cterm[var], #cont)

  rule CppFreshesTerm(#env, cterm⟦ { ##cmapentries? } ##csortanno? ⟧, #cont)
  → Error("Internal Error: map expression must no occur in the contraction.")

  rule CppFreshesTerm(#env, cterm⟦ thunk ##cterm ⟧, #cont)
  → CppFreshesTerm(#env, #cterm, #cont)

  rule CppFreshesTerm(#env, cterm⟦ ##cliteral ⟧, #cont)
  → #cont(#env)

func CppFreshesMaybeTerms({String : EnvEntry}, List<Core_cterms_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
rule CppFreshesMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧, #cont) → CppFreshesTerms(#env, #cterm*, #cont)
rule CppFreshesMaybeTerms(#env, #cterms?              , #cont) → #cont(#env)

func CppFreshesTerms({String : EnvEntry}, List<Core_cterm_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
rule CppFreshesTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, #cont) → CppFreshesTerm(#env, #cterm, (env) -> CppFreshesTerms(env, #cterm*, #cont))
rule CppFreshesTerms(#env, cterm*⟦                  ⟧, #cont) → #cont(#env)

func CppFreshesMaybeSubst({String : EnvEntry}, List<Core_csubst_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
rule CppFreshesMaybeSubst(#env, csubst?⟦              ⟧, #cont) → #cont(#env)
rule CppFreshesMaybeSubst(#env, csubst?⟦ [ ##cterm* ] ⟧, #cont) → CppFreshesTerms(#env, #cterm*, #cont)

func CppFreshesVariable({String : EnvEntry}, Option<VarEntry>, String, List<Core_csortanno_sort>, Bool /*Fresh or Bound?*/, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // New typed fresh or bound variable
  rule CppFreshesVariable(#env, NONE, #var, csortanno?⟦ : ##csort ⟧, #fresh, #cont)
  → CppMakeFreshVariable(#env, #var, #csort, #fresh, #cont)

  // Existing fresh or bound variable. Skip.
  rule CppFreshesVariable(#env, SOME(#), #var, #csortanno?, #fresh, #cont)
  → #cont(#env)

func CppMakeFreshVariable({String : EnvEntry}, String, Core_csort_sort, Bool, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

rule CppMakeFreshVariable(#env, #var, #csort, TRUE, #cont)
→ text⟦
   C†⟨CppType(#csort)⟩Var& fresh†⟨NumberToText(GetFreshCounter(#env))⟩ = var†⟨CppType(#csort)⟩(†⟨Text-QuoteEscape(Show(#var))⟩);⟨
   #cont(IncFreshCounter(AddVar(#env, #var, Fresh(text⟦fresh†⟨NumberToText(GetFreshCounter(#env))⟩⟧, SOME(#csort)))))⟩⟧

rule CppMakeFreshVariable(#env, #var, #csort, FALSE, #cont)
→ text⟦
    C†⟨CppType(#csort)⟩Var& bound†⟨NumberToText(GetCounter(#env))⟩ = var†⟨CppType(#csort)⟩(†⟨Text-QuoteEscape(Show(#var))⟩);⟨
    #cont(IncCounter(AddVar(#env, #var, Bound(text⟦bound†⟨NumberToText(GetCounter(#env))⟩⟧, SOME(#csort)))))⟩⟧

// ---- Generate term code - C++ expression mode

func CppExprTerm({String : EnvEntry}, Core_cterm_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 rule CppExprTerm(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #cont)
 → CppExprConstruction(#env, #canno*, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #cont)

 rule CppExprTerm(#env, cterm⟦ ##cliteral ⟧, #cont)
 → text⟦
     †⟨CppExprLiteral(#cliteral)⟩†⟨#cont(#env)⟩⟧

 rule CppExprTerm(#env, cterm⟦ ##canno* ##VARIABLE ##csortanno? ⟧, #cont)
 → CppExprMaybeVar(#env, MaybeGetVar(#env, #VARIABLE), #VARIABLE, #cont)

 rule CppExprTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #cont)
 → CppExprMeta(#env, #METAVAR, #cterms?, #csubst?, #cont)

 rule CppExprTerm(#env, cterm⟦ [ x ##csortanno?[] ] ##cterm[x] ⟧, #cont)
 → text⟦
     bound†⟨NumberToText(GetCounter(#env))⟩, †⟨CppExprTerm(AddVar(IncCounter(#env), var, Bound(text⟦bound†⟨NumberToText(GetCounter(#env))⟩⟧, MaybeSortAnnoToSort(#csortanno?))), #cterm[var], #cont)⟩⟧

 rule CppExprTerm(#env, cterm⟦ ( f ##csortanno?[] ) ##cterm[f] ⟧, #cont)
 → text⟦closure†⟨CppLambdaTypeArgs(#cterm[dummy])⟩(†⟨CppExprLambda(#env, cterm⟦ ( f ##csortanno?[] ) ##cterm[f] ⟧, 0, #cont)⟩⟧

 rule CppExprTerm(#env, cterm⟦ thunk ##cterm ⟧, #cont)
 → text⟦thunk†⟨CppLambdaTypeArgs(#cterm)⟩(†⟨CppExprLambda(#env, #cterm, 0, #cont)⟩⟧

// ---- construction expression

func CppExprConstruction({String : EnvEntry}, List<Core_canno_sort>, String,  List<Core_csortargs_sort>, List<Core_cterms_sort>, List<Core_csortanno_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

// TODO: type arguments are only needed when the return type is a type variable. The rest should be deducable.
 rule CppExprConstruction(#env, #canno*, #constructor, #csortargs?, #cterms?, #csortanno?, #cont)
 → text⟦†⟨CppConsMethodName(#constructor, HasAnnotation("Data", #canno*))⟩†⟨CppMaybeTypeArgs(#csortargs?)⟩(†⟨GetContext(#env)⟩†⟨CppExprMaybeTerms(#env, #cterms?, #cont)⟩⟧

func CppExprMaybeTerms({String : EnvEntry}, List<Core_cterms_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 rule CppExprMaybeTerms(#env, cterms?⟦⟧, #cont)
 → text⟦)†⟨#cont(#env)⟩⟧

 rule CppExprMaybeTerms(#env, cterms?⟦()⟧, #cont)
 → text⟦)†⟨#cont(#env)⟩⟧

 rule CppExprMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧, #cont)
 → CppExprTerms(#env, #cterm*, #cont)

func CppExprTerms({String : EnvEntry}, List<Core_cterm_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 rule CppExprTerms(#env, cterm*⟦⟧, #cont)
 → text⟦)†⟨#cont(#env)⟩⟧

 rule CppExprTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, #cont)
 → text⟦, †⟨CppExprTerm(#env, #cterm, (env) -> CppExprTerms(env, #cterm*, #cont))⟩⟧

// --- Variable

func CppExprMaybeVar({String : EnvEntry}, Option<VarEntry>, String, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 /*rule CppExprMaybeVar(#env, NONE, #svar, #cont) // Fresh variable must have been declared. Just increment counter
 → #cont(#env)*/

 rule CppExprMaybeVar(#env, SOME(Formal(#var, #type)), #svar, #cont)
 → text⟦†⟨#var⟩†⟨#cont(#env)⟩⟧

 // fallback
 rule CppExprMaybeVar(#env, SOME(#varEntry), #svar, #cont)
 → text⟦†⟨UnVarVar(#varEntry)⟩.Use()†⟨#cont(#env)⟩⟧

// ----  metavar expression

func CppExprMeta({String : EnvEntry}, String, List<Core_cterms_sort>, List<Core_csubst_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 // No arguments -> just return the metavariable.
 rule CppExprMeta(#env, #metavar, cterms?⟦⟧, csubst?⟦⟧, #cont)
 → text⟦†⟨GetMetaVar(#env, #metavar)⟩†⟨#cont(#env)⟩⟧

 // No arguments in parenthesis -> call lambda with no param.
 rule CppExprMeta(#env, #metavar, cterms?⟦ () ⟧, csubst?⟦⟧, #cont)
 → text⟦†⟨GetMetaVar(#env, #metavar)⟩.Eval(ctx)†⟨#cont(#env)⟩⟧

 // Apply arguments -> call lambda
 rule CppExprMeta(#env, #metavar, cterms?⟦ ( ##cterm* ) ⟧, csubst?⟦⟧, #cont)
 → text⟦†⟨GetMetaVar(#env, #metavar)⟩.Eval(†⟨GetContext(#env)⟩†⟨CppExprTerms(#env, #cterm*, #cont)⟩⟧

 // Substitution
 rule CppExprMeta(#env, #metavar, cterms?⟦⟧, csubst?⟦ [ ##cterm* ] ⟧, #cont)
 → text⟦Subst(†⟨GetContext(#env)⟩, †⟨GetMetaVar(#env, #metavar)⟩, { †⟨TextMapFold((b)->text⟦&†⟨b⟩⟧, GetMetaArgs(#env, #metavar), text⟦, ⟧)⟩ }, { †⟨CppExprMetaArgs(#env, #cterm*, text⟦⟧, #cont)⟩⟧


func CppExprMetaArgs({String : EnvEntry}, List<Core_cterm_sort> /* contraction args */, Text4_text_sort,
                    ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 rule CppExprMetaArgs(#env, (#arg, #args...), #sep, #cont)
 → text⟦†⟨#sep⟩&†⟨CppExprTerm(#env, #arg, (env) -> CppExprMetaArgs(env, #args, text⟦, ⟧, #cont))⟩⟧

  rule CppExprMetaArgs(#env, (), #sep, #cont)
  → text⟦})†⟨#cont(#env)⟩⟧

// ---- lambda expression

func CppExprLambda({String : EnvEntry}, Core_cterm_sort, Numeric, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 rule CppExprLambda(#env, cterm⟦ ( f ##csortanno? ) ##cterm[f] ⟧, #arity, #cont)
 → CppExprLambda(AddVar(#env, var, Formal(text⟦⟨STRING: var⟩⟧, MaybeSortAnnoToSort(#csortanno?))), #cterm[var], Plus(#arity, 1), #cont)

 rule CppExprLambda(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #arity, #cont)
 → text⟦&†⟨CppConsMethodName(#CONSTRUCTOR, HasAnnotation("Data", #canno*))⟩†⟨CppExprTerms(#env, SubList(MaybeTermsToTerms(#cterms?), #arity), #cont)⟩⟧

  rule CppExprLambda(#env, #cterm, #arity, #cont)
  → Error("Internal Error: Invalid lambda expression. Lambda must be of the form (x .. y) -> C(x .. y, #1 .. #n)")

// Generate closure function type arguments. Not needed if the called function is not parameterized, C++ is callable of deducing types.
func CppLambdaTypeArgs(Core_cterm_sort) -> Text4_text_sort

  rule CppLambdaTypeArgs(cterm⟦ ( f ##csortanno?[] ) ##cterm[f] ⟧)
  → CppLambdaTypeArgs(#cterm[dummy])

  rule CppLambdaTypeArgs(cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs ##cterms? : ##csort ⟧)
  → text⟦<†⟨TextFold((CppType(#csort), CppGetSortsMaybeTerms(#cterms?)...), text⟦, ⟧)⟩>⟧

  rule CppLambdaTypeArgs(cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##cterms? ##csortanno? ⟧)
  → text⟦⟧

  rule CppLambdaTypeArgs(#cterm)
  → Error("Internal Error: Invalid lambda expression. Lambda must be of the form (x .. y) -> C(x .. y, #1 .. #n)")

// --- Literal

func CppExprLiteral(Core_cliteral_sort) -> Text4_text_sort
  rule CppExprLiteral(cliteral⟦ ##STRING ⟧) → text⟦newStringTerm(†⟨Text-QuoteEscape(#STRING)⟩)⟧
  rule CppExprLiteral(cliteral⟦ ##NUMBER ⟧) → text⟦newDoubleTerm(⟨STRING: #NUMBER⟩)⟧

// --- Sort translation functions

/* Generate template prefix for given sort variables */
func CppTemplatePrefix(List<Core_csortvars_sort>) -> Text4_text_sort

  rule CppTemplatePrefix(csortvars?⟦⟧) → text⟦⟧

  rule CppTemplatePrefix(csortvars?⟦ ∀ ##VARIABLE+ . ⟧)
  → text⟦template <†⟨CppTypeParameters(#VARIABLE+)⟩>⟧

/* Generate comma-seperated list of type parameters */
func CppTypeParameters(#vars: List<String>) -> Text4_text_sort
→ TextFold(Map((var) -> text⟦typename ⟨STRING: var⟩⟧, #vars), text⟦, ⟧)

/* Generate comma-separated list of type arguments from sort variables, if any*/
func MaybeCppTypeArguments(List<Core_csortvars_sort>) -> Text4_text_sort
rule MaybeCppTypeArguments(csortvars?⟦⟧) → text⟦⟧
rule MaybeCppTypeArguments(csortvars?⟦ ∀ ##VARIABLE+ . ⟧) → text⟦<†⟨CppTypeArguments(#VARIABLE+)⟩>⟧

/* Generate comma-separated list of type arguments from sort variables */
func CppTypeArguments(#vars: List<String>) -> Text4_text_sort
→ TextFold(Map<String Text4_text_sort>((var) -> text⟦⟨STRING: var⟩⟧, #vars), text⟦, ⟧)

/* Generate (possibility dependent) type name corresponding to the given data sort type */
func CppTypeName(List<Core_csortvars_sort>, String) -> Text4_text_sort

  rule CppTypeName(csortvars?⟦⟧, #sortname)
  → SortNameToCppClassName(#sortname)

  //TODO: might need typename when occurs within a template class.
  rule CppTypeName(csortvars?⟦ ∀ ##VARIABLE+ . ⟧, #sortname)
  → text⟦†⟨SortNameToCppClassName(#sortname)⟩<†⟨CppTypeArguments(#VARIABLE+)⟩>⟧

/* Generate (possibility dependent) type name corresponding to the given data sort type */
func CppTypeRefName(#csortvars?: List<Core_csortvars_sort>, #sortname:String) -> Text4_text_sort
→ text⟦†⟨CppTypeName(#csortvars?, #sortname)⟩&⟧

/* Generate arguments for template instantiation */
func MaybeCppTemplateArgs(List<Core_csorts_sort>) -> Text4_text_sort

    rule MaybeCppTemplateArgs(csorts?⟦ ⟧)
    → text⟦⟧

    rule MaybeCppTemplateArgs(csorts?⟦ ( ##csort* )⟧)
    → text⟦<†⟨TextFold(Map((csort) -> CppType(csort), #csort*), text⟦, ⟧)⟩>⟧

/* Convert list of sorts to a list of formal parameters or arguments. */
func MaybeCppFormalParams(List<Core_csorts_sort>, Text4_text_sort, Bool /* omit types */) -> Text4_text_sort

  rule MaybeCppFormalParams(csorts?⟦⟧, #sep, #isarg)
  → text⟦⟧

  rule MaybeCppFormalParams(csorts?⟦ ( ##csort*) ⟧, #sep, #isarg)
  → CppFormalParams(#csort*, 1, #sep, #isarg)

func CppFormalParams(List<Core_csort_sort>, Numeric, Text4_text_sort, Bool) -> Text4_text_sort

  rule CppFormalParams(csort*⟦⟧, #index, #sep, #isarg)
  → text⟦⟧

  rule CppFormalParams(csort*⟦ ##csort ##csort* ⟧, #index, #sep, #isarg)
  → text⟦†⟨#sep⟩†⟨CppFormalParam(CppTypes(#csort), #index, 1, #isarg)⟩†⟨CppFormalParams(#csort*, Plus(#index, 1), text⟦, ⟧, #isarg)⟩⟧

func CppFormalParam(List<Text4_text_sort>, Numeric, Numeric, Bool) -> Text4_text_sort

  rule CppFormalParam(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex, #isarg)
  → text⟦†⟨If(#isarg, ()->text⟦⟧, ()->text⟦†⟨#type⟩& ⟧)⟩†⟨ParamName(#index)⟩⟧

  rule CppFormalParam(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex, #isarg)
  → text⟦†⟨If(#isarg, ()->text⟦⟧, ()->text⟦†⟨#type⟩& ⟧)⟩†⟨VarParamName(#index, #subindex)⟩, †⟨CppFormalParam(#types, #index, Plus(#subindex, 1), #isarg)⟩⟧

func ParamName(#index: Numeric) -> Text4_text_sort
→ text⟦param†⟨NumberToText(#index)⟩⟧

func VarParamName(#index: Numeric, #subindex: Numeric) -> Text4_text_sort
→ text⟦param†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩⟧

/* Translate TS sort to equivalent list of C++ types:
 * A list of types corresponding to syntactic variable sorts and a type for the last sort
 * Note: return a type, not a type reference
 */
func CppTypes(#csort: Core_csort_sort) -> List<Text4_text_sort>
→ CppTypes2(#csort, ())

func CppTypes2(Core_csort_sort, List<Text4_text_sort> /* formal params */) -> List<Text4_text_sort>

  rule CppTypes2(csort⟦ ##CONSTRUCTOR ##csorts? ⟧, ())
  → Cons(text⟦†⟨SortNameToCppClassName(CppFixupPrimitiveType(#CONSTRUCTOR))⟩†⟨MaybeCppTemplateArgs(#csorts?)⟩⟧, Nil)

  rule CppTypes2(csort⟦ ##CONSTRUCTOR ##csorts? ⟧, Cons(#formal:Text4_text_sort, #formals:List<Text4_text_sort>))
  → Cons(text⟦Closure†⟨NumberToText(Plus(ListLength<Text4_text_sort>(#formals), 1))⟩<†⟨
       SortNameToCppClassName(CppFixupPrimitiveType(#CONSTRUCTOR))⟩†⟨MaybeCppTemplateArgs(#csorts?) /* Return type */⟩, †⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* Formal params */⟩>⟧, Nil)

  rule CppTypes2(csort⟦ ##VARIABLE ⟧, ())
  → Cons(text⟦⟨STRING: #VARIABLE⟩⟧, Nil)

  rule CppTypes2(csort⟦ ##VARIABLE ⟧, Cons(#formal:Text4_text_sort, #formals:List<Text4_text_sort>))
  → Cons(text⟦Closure†⟨NumberToText(Plus(ListLength(#formals), 1))⟩<⟨STRING: #VARIABLE /* Return type */⟩, †⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* Formal params */⟩>⟧, Nil)

  rule CppTypes2(csort⟦ [ ##csort ] ##csort2 ⟧, #formals)
  → Cons(text⟦C†⟨CppType(#csort)⟩Var⟧, CppTypes2(#csort2, #formals)) // TODO: Var must be printed before template args.

  rule CppTypes2(csort⟦ ( ##csort ) ##csort2 ⟧, #formals) // no higher-order csort for now.
  → CppTypes2(#csort2, Append(CppType(#csort), #formals))

  rule CppTypes2(csort⟦ { ##csort1 : ##csort2 } ⟧, ())
  → Cons(text⟦MapTerm<†⟨CppType(#csort1)⟩,†⟨CppType(#csort2)⟩>⟧, Nil)

  rule CppTypes2(csort⟦ { ##cmapsort } ⟧, Cons(#formal:Text4_text_sort, #formals:List<Text4_text_sort>))
  → Cons(text⟦Closure†⟨NumberToText(Plus(ListLength(#formals), 1))⟩<MapTerm, †⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* Formal params */⟩>⟧, Nil)

  rule CppTypes2(csort⟦ data ##csort ⟧, #formals)
  → CppTypes2(#csort, #formals)

  rule CppTypes2(csort⟦ thunk ##csort ⟧, #formals)
  → Cons(text⟦Closure0<†⟨CppType(#csort)⟩>⟧, Nil)

/* Same as above, expect ignore syntactic variables */
func CppType(#csort: Core_csort_sort) -> Text4_text_sort
→ Last(CppTypes(#csort)) // TODO: could optimize

/* Same as above, but return a reference type */
func CppTypeRef(#csort: Core_csort_sort) -> Text4_text_sort
→ text⟦†⟨CppType(#csort)⟩&⟧

/* Same as above, expect maybe get a sort. Generate auto& when no type. */
func MaybeCppType(#csort?: Option<Core_csort_sort>) -> Text4_text_sort
→ IfPresent(Maybe((csort)->CppType(csort), #csort?), (type) -> type, () -> text⟦auto&⟧)

/* Same as above, expect with default value */
func MaybeCppTypeD(Option<Core_csort_sort>, Text4_text_sort) -> Text4_text_sort
rule MaybeCppTypeD(NONE        , #default) → #default
rule MaybeCppTypeD(SOME(#csort), #default) → CppType(#csort) // TODO: could optimize

/* Rename builtin types to avoid conflict with C++ types */
func CppFixupPrimitiveType(#typename: String) -> String
→ If(StringEqual(#typename, "String"), ()->"StringTerm",
    ()->If(StringEqual(#typename, "Numeric"), ()->"DoubleTerm",
         ()->#typename))

func CppMaybeTypeArgs(List<Core_csortargs_sort>) -> Text4_text_sort
rule CppMaybeTypeArgs(csortargs?⟦              ⟧) → text⟦⟧
rule CppMaybeTypeArgs(csortargs?⟦ < ##csort* > ⟧) → text⟦<†⟨TextFold(Map((csort)->CppType(csort), #csort*), text⟦, ⟧)⟩>⟧

/* Extract sorts from the given optional list of arguments */
func CppGetSortsMaybeTerms(List<Core_cterms_sort>) -> List<Text4_text_sort>
rule CppGetSortsMaybeTerms(cterms?⟦ ( ##cterm* ) ⟧ ) → CppGetSortsTerms(#cterm*)
rule CppGetSortsMaybeTerms(#cterms?               ) → ()

func CppGetSortsTerms(#terms: List<Core_cterm_sort>) -> List<Text4_text_sort>
→ Map((term) -> IfPresent(TermSort(term), (sort)->CppType(sort), ()->Error("Internal Error: missing sort.")), #terms)


// --- Basic conversion functions

/* Convert data sort name to corresponding C++ class name */
func SortNameToCppClassName(#name: String) -> Text4_text_sort
→ If(Equal(#name, "STRING"), ()->text⟦ESTRING⟧, ()->text⟦⟨STRING: Mangle(#name)⟩⟧)

/* Convert data sort name to equivalent C++ class name reference */
func SortNameToCppClassNameRef(#name: String) -> Text4_text_sort
→ text⟦†⟨SortNameToCppClassName(#name)⟩&⟧

/* Convert the given contructor (function or data) to corresponding C++ method name */
func CppConsMethodName(#name: String, #isdata: Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#isdata, ()->text⟦new⟧)⟩⟨STRING: Mangle(#name)⟩⟧

/* Convert data form to corresponding C++ constructor method name */
func CppNewMethodName(#name: String) -> Text4_text_sort
→ text⟦new⟨STRING: Mangle(#name)⟩⟧

/* Convert data form to corresponding C++ 'as' method name */
func CppAsMethodName(#name: String) -> Text4_text_sort
→ text⟦as⟨STRING: Mangle(#name)⟩⟧

/* Convert parameterized data form to corresponding C++ class name */
func ParamFormCppClassName(#name: String, #csortvars?: List<Core_csortvars_sort>, #kind: CppFormClassKind) -> Text4_text_sort
→ text⟦†⟨FormCppClassName(#name)⟩†⟨CppFormClassSuffix(#kind)⟩†⟨MaybeCppTypeArguments(#csortvars?)⟩⟧

/* Convert data form to corresponding C++ class name */
func FormCppClassName(#name: String) -> Text4_text_sort
→ If(Equal(#name, "STRING"), ()->text⟦CSTRING⟧, ()->text⟦C⟨STRING: Mangle(#name)⟩⟧)

/* Convert data form to corresponding C++ class name reference */
func FormCppClassNameRef(#name: String) -> Text4_text_sort
→ text⟦†⟨FormCppClassName(#name)⟩&⟧

/* Convert TS function name to corresponding C++ function name  */
func CppFnName(#name: String) -> Text4_text_sort
→ text⟦⟨STRING: Mangle(#name)⟩⟧

/* Print form class suffix based of the given `#kind` */
func CppFormClassSuffix(CppFormClassKind) -> Text4_text_sort
rule CppFormClassSuffix(CFC_CONS)   → text⟦⟧
rule CppFormClassSuffix(CFC_VAR)    → text⟦Var⟧
rule CppFormClassSuffix(CFC_VARUSE) → text⟦Use⟧

// --- helper function

/* Whether to generate function body */
func GenBody(#csortvars? : List<Core_csortvars_sort>, #header : Bool, #forward: Bool) -> Bool
→ And(
    Not(#forward),
    Or(
      And(IsEmpty   (#csortvars?), Not(#header)),
      And(IsNotEmpty(#csortvars?), #header)))

/* Generate method qualifier, only for definitions */
func CppQualifier(#sortname: String, #csortvars? : List<Core_csortvars_sort>, #def : Bool) -> Text4_text_sort
→ TextIf(#def, ()->text⟦†⟨CppTypeName(#csortvars?, #sortname)⟩::⟧)

/* Generate form class qualifier, only for definitions */
func CppFormQualifier(#formname: String, #csortvars? : List<Core_csortvars_sort>, #kind: CppFormClassKind, #def : Bool) -> Text4_text_sort
→ TextIf(#def, ()->text⟦†⟨ParamFormCppClassName(#formname, #csortvars?, #kind)⟩::⟧)
