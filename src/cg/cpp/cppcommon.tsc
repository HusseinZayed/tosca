// Copyright (c) 2016 IBM Corporation.

import std::core
import std::string
import std::num
import std::listdef
import std::pairdef
import std::text
import std::language
import std::text::Text4

import core::Core
import core::utils
import cg::cpp::cppenv
import systemdef
import cg::lifetime
import cg::utils

/* Enumerate the kinds of class corresponding to a form */
enum CppFormClassKind
  | CFC_CONS    /* Non variable class  */
  | CFC_VAR     /* Variable class */
  | CFC_VARUSE  /* Variable use class */

// --- Forward declarations

/* Generate data sort, data form and parameterized function forward declarations */
func CppForwardDecls(#decls: List<Core_cdecl_sort>) -> Text4_text_sort
→ TextFoldES(Map((decl) -> CppForwardDecl(decl), #decls))

func CppForwardDecl(Core_cdecl_sort) -> Text4_text_sort

  rule CppForwardDecl(cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧)
  → text⟦†⟨CppTemplatePrefix(#csortvars?)⟩
class †⟨SortNameToCppClassName(#CONSTRUCTOR)⟩;†⟨TextFoldES(Map((cform) -> CppForwardForm(#CONSTRUCTOR, #csortvars?, cform), #cform*))⟩⟧

  rule CppForwardDecl(cdecl⟦ ##canno* ##EXTERN? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧)
  → CppFunctionDeclD({}, cdecl⟦ ##canno* ##EXTERN? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧, TRUE, TRUE)

  rule CppForwardDecl(#cdecl)
  → text⟦⟧

func CppForwardForm(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text4_text_sort

  rule CppForwardForm(#sortname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csortsdefault? ⟧)
  → text⟦†⟨CppTemplatePrefix(#csortvars?)⟩¶class †⟨ParamFormCppClassName(#CONSTRUCTOR, (), CFC_CONS)⟩;⟧

  rule CppForwardForm(#sortname, #csortvars?, cform⟦ allows-variable ⟧)
  → text⟦
†⟨CppTemplatePrefix(#csortvars?)⟩
class †⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩;

†⟨CppTemplatePrefix(#csortvars?)⟩
class †⟨ParamFormCppClassName(#sortname, (), CFC_VARUSE)⟩;⟧

// --- Data translation functions

/* Generate a method making new instances of the given form.
   @param `#sortname`
   @param `#csortvars?`
   @param `#cform`
   @param `#def` whether to generate the method definition in additition to its declaration.
*/
func CppMethodNew(String, List<Core_csortvars_sort>, Core_cform_sort, Bool) -> Text4_text_sort

  rule CppMethodNew(#sortname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csortsdefault? ⟧, #def)
  → text⟦†⟨CppTemplatePrefix(#csortvars?)⟩
†⟨CppTypeRefName(#csortvars?, #sortname)⟩ †⟨CppNewMethodName(#CONSTRUCTOR)⟩(tosca::Context& ctx†⟨MaybeCppFormalParams(MaybeSortsDefaultToMaybeSorts(#csortsdefault?), text⟦, ⟧, FALSE)⟩)†⟨
      If(#def, ()->text⟦
{→
return (*new †⟨ParamFormCppClassName(#CONSTRUCTOR, #csortvars?, CFC_CONS)⟩(†⟨MaybeCppFormalParams(MaybeSortsDefaultToMaybeSorts(#csortsdefault?), text⟦⟧, TRUE)⟩));←
}⟧, ()->text⟦;⟧)⟩⟧

  rule CppMethodNew(#sortname, #csortvars?, cform⟦ allows-variable ⟧, #def)
  → text⟦†⟨CppTemplatePrefix(#csortvars?)⟩
†⟨ParamFormCppClassName(#sortname, #csortvars?, CFC_VAR)⟩& †⟨CppFnName(ConcatString("var", #sortname))⟩(tosca::Context& ctx, const std::string& hint)†⟨
      If(#def, ()->text⟦
{→
return *(new †⟨ParamFormCppClassName(#sortname, #csortvars?, CFC_VAR)⟩(ctx.MakeGlobalName(hint)));←
}⟧, ()->text⟦;⟧)⟩⟧

/* Generate base lookup method (the 'as' method) for the given form.
   @param `#sortname`
   @param `#csortvars?`
   @param `#cform`
   @param `#def` whether to generate the method definition in additition to its declaration. */
func CppMethodAs(String, List<Core_csortvars_sort>, Core_cform_sort, Bool) -> Text4_text_sort

  rule CppMethodAs(#sortname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csortsdefault? ⟧, #def)
  → text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨TextIf(Not(#def), ()->text⟦virtual ⟧)⟩Optional<†⟨ParamFormCppClassName(#CONSTRUCTOR, #csortvars?, CFC_CONS)⟩> †⟨CppQualifier(#sortname, #csortvars?, #def)⟩†⟨CppAsMethodName(#CONSTRUCTOR)⟩(tosca::Context& ctx)†⟨
    If(#def, ()->text⟦
{→
return Optional<†⟨ParamFormCppClassName(#CONSTRUCTOR, #csortvars?, CFC_CONS)⟩>::nullopt;←
}⟧, ()->text⟦;⟧)⟩⟧


  rule CppMethodAs(#sortname, #csortvars?, cform⟦ allows-variable ⟧, #def)
  → text⟦⟧

/* Generate typed use method. */
func CppVarMethodUse(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦†⟨CppTemplatePrefix(#csortvars?)⟩
†⟨SortNameToCppClassName(#sortname)⟩†⟨MaybeCppTypeArguments(#csortvars?)⟩& †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩Use()†⟨
      If(#def, ()->text⟦
{→
return (*new †⟨ParamFormCppClassName(#sortname, #csortvars?, CFC_VARUSE)⟩(*this));←
}⟧, ()->text⟦;⟧)⟩⟧

/* Generate untyped use method. */
func CppVarMethodGUse(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦†⟨CppTemplatePrefix(#csortvars?)⟩
tosca::Term& †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩GUse()†⟨
      If(#def, ()->text⟦ { return Use(); }⟧, ()->text⟦;⟧)⟩⟧

/* Generate class constructor corresponding to the given `#formname`. */
func CppFormConstructor(#sortname: String, #csortvars?: List<Core_csortvars_sort>, #formname: String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩†⟨FormCppClassName(#formname)⟩(†⟨MaybeCppFormalParams(#csorts?, text⟦⟧, FALSE)⟩)†⟨
    If(#def,
      ()->text⟦†⟨TextIf(HasSorts(#csorts?),
        ()->text⟦: †⟨MaybeCppClassFields(#csorts?, (isvar type index subindex)->CppInitField(isvar, type, index, subindex))⟩⟧)⟩{}⟧,
      ()->text⟦;⟧)⟩⟧

/* Generate default class constructor corresponding to the given `#formname`. Only if not a constant, since otherwise it has already been generated. */
func CppFormDefaultConstructor(#sortname: String, #csortvars?: List<Core_csortvars_sort>, #formname: String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ TextIf(Not(IsEmpty(MaybeSortsToSorts(#csorts?))), ()->text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩†⟨FormCppClassName(#formname)⟩()†⟨
    If(#def,
      ()->text⟦†⟨TextIf(HasSorts(#csorts?),
        ()->text⟦: †⟨MaybeCppClassFields(#csorts?, (isvar type index subindex)->CppNullifyField(isvar, type, index, subindex))⟩⟧)⟩{}⟧,
      ()->text⟦;⟧)⟩⟧)

/* Generate static Make function corresponding to the given `#formname`.*/
func CppFormMethodMake(#sortname: String, #csortvars?: List<Core_csortvars_sort>, #formname: String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨TextIf(Not(#def), ()->text⟦static ⟧)⟩tosca::Term& †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩Make(tosca::Context& ctx)†⟨
    If(#def,
      ()->text⟦¶{ return *(new †⟨ParamFormCppClassName(#formname, #csortvars?, CFC_CONS)⟩()); }⟧,
      ()->text⟦;⟧)⟩⟧

/* Generate method Use corresponding to the given `#sortname`. */
func CppVarConstructorUse(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨CppFormQualifier(#sortname, #csortvars?, CFC_VARUSE, #def)⟩†⟨FormCppClassName(#sortname)⟩Use(†⟨ParamFormCppClassName(#sortname, #csortvars?, CFC_VAR)⟩& v)†⟨
   If(#def,
     ()->text⟦: tosca::VariableUse::VariableUse(v) {}⟧,
     ()->text⟦;⟧)⟩⟧

/* Generate base method GetVariable corresponding to the given `#sortname`. */
func CppMethodGetVariable(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨TextIf(Not(#def), ()->text⟦virtual ⟧)⟩Optional<†⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩> †⟨CppQualifier(#sortname, #csortvars?, #def)⟩GetVariable() const†⟨
   If(#def,
     ()->text⟦¶{→
return Optional<†⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩>::nullopt;←
}⟧, ()->text⟦;⟧)⟩⟧

/* Generate static method MakeVariable corresponding to the given `#sortname`. */
func CppMethodMakeVariable(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #allowvar: Bool, #def: Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨TextIf(Not(#def), ()->text⟦static ⟧)⟩tosca::Variable& †⟨CppQualifier(#sortname, #csortvars?, #def)⟩MakeVariable(tosca::Context ctx, std::string& name)†⟨
   If(#def,
     ()->If(#allowvar,
       ()->text⟦¶{→
return *(new †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩(name));←
}⟧,    ()->text⟦¶{ return Term::MakeVariable(ctx, name); }⟧),
     ()->text⟦;⟧)⟩⟧

/* Generate static method MakeTerm corresponding to the given `#sortname`. */
func CppMethodMakeTerm(#sortname: String, #csortvars?: List<Core_csortvars_sort>, #cform*: List<Core_cform_sort>, #def: Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨TextIf(Not(#def), ()->text⟦static ⟧)⟩tosca::Term& †⟨CppQualifier(#sortname, #csortvars?, #def)⟩MakeTerm(tosca::Context& ctx, std::string& symbol)†⟨
  If(#def,
    ()->text⟦¶{→†⟨TextMapFoldES((cform)->CppMakeForm(#csortvars?, cform), #cform*)⟩
throw std::invalid_argument(symbol);←¶}⟧,
    ()->text⟦;⟧)⟩⟧

func CppMakeForm(List<Core_csortvars_sort>, Core_cform_sort) -> Text4_text_sort

  rule CppMakeForm(#csortvars?, cform⟦ ##CONSTRUCTOR ##csortsdefault? ⟧)
  → text⟦¶if (symbol == †⟨Text-QuoteEscape(#CONSTRUCTOR)⟩)→
return †⟨ParamFormCppClassName(#CONSTRUCTOR, #csortvars?, CFC_CONS)⟩::Make(ctx);←⟧

    rule CppMakeForm(#csortvars?, #cform)
    → text⟦⟧

/* Generate method GetVariable corresponding to the given `#sortname`. */
func CppVarMethodGetVariable(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦
   †⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
   Optional<†⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩> †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VARUSE, #def)⟩GetVariable() const†⟨
   If(#def,
     ()->text⟦{
         return make_optional<†⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩>(dynamic_cast<†⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩&>(VariableUse::GetGVariable().value()));
       }⟧,
     ()->text⟦;⟧)⟩⟧

/* Generate method GetGVariable corresponding to the given `#sortname`. Needed to resolve multiple inheritance ambiguity. */
func CppVarMethodGetGVariable(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
   Optional<tosca::Variable> †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VARUSE, #def)⟩GetGVariable() const†⟨
   If(#def,
     ()->text⟦ { return VariableUse::GetGVariable(); }⟧,
     ()->text⟦;⟧)⟩⟧

/* Generate the variable class constructor for the given `#sortname`. */
func CppVarConstructorVar(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
   †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩†⟨ParamFormCppClassName(#sortname, (), CFC_VAR)⟩(std::string& name)†⟨
   If(#def,
     ()->text⟦: tosca::Variable(name) {}⟧,
     ()->text⟦;⟧)⟩⟧

/* Generate the Symbol method for the given `#formname`. */
func CppFormMethodSymbol(String, List<Core_csortvars_sort>, String, Bool) -> Text4_text_sort
rule CppFormMethodSymbol(#sortname, #csortvars?, #formname, #def)
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
†⟨TextIf(Not(#def), ()->text⟦virtual ⟧)⟩std::string& †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩Symbol() const†⟨
  If(#def, ()->text⟦ { return *(new std::string(†⟨Text-QuoteEscape(#formname)⟩)); }⟧, ()->text⟦;⟧)⟩⟧

  /* Generate the Symbol method for the given `#sortname`. */
  func CppVarMethodSymbol(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
  → text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
  †⟨TextIf(Not(#def), ()->text⟦virtual ⟧)⟩std::string& †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VARUSE, #def)⟩Symbol() const†⟨
    If(#def, ()->text⟦ { return VariableUse::Symbol(); }⟧, ()->text⟦;⟧)⟩⟧

/* Generate overridden lookup method (the 'as' method) for the given `formname`. */
func CppFormMethodAs(String, List<Core_csortvars_sort>, String, Bool) -> Text4_text_sort
rule CppFormMethodAs(#sortname, #csortvars?, #formname, #def)
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
Optional<†⟨ParamFormCppClassName(#formname, #csortvars?, CFC_CONS)⟩> †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩†⟨CppAsMethodName(#formname)⟩(tosca::Context& ctx)†⟨
  If(#def, ()->text⟦
{→
return make_optional<†⟨ParamFormCppClassName(#formname, #csortvars?, CFC_CONS)⟩>(*this);←
}⟧, ()->text⟦;⟧)⟩⟧

/* Generate overridden Copy method for the given form.*/
func CppFormMethodCopy(String, List<Core_csortvars_sort>, String, Bool) -> Text4_text_sort
rule CppFormMethodCopy(#sortname, #csortvars?, #formname, #def)
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
tosca::Term& †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩Copy(tosca::Context& ctx)†⟨
  If(#def, ()->text⟦¶{ return Make(ctx); }⟧, ()->text⟦;⟧)⟩⟧

/* Generate overridden variable Copy method for the given `#sortname`.  */
func CppVarMethodCopy(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #def:Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
tosca::Variable& †⟨CppFormQualifier(#sortname, #csortvars?, CFC_VAR, #def)⟩Copy(tosca::Context& ctx) const†⟨
  If(#def, ()->text⟦¶{ return †⟨CppFnName(ConcatString("var", #sortname))⟩(ctx, Symbol()); }⟧, ()->text⟦;⟧)⟩⟧

/* Generate getValue method for the given `formname`. */
func CppFormGetValue(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #formname:String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ MaybeCppClassFields(#csorts?, (isvar type index subindex)->
     CppGetValue(isvar, type, index, subindex, #def, TextIf(#def, ()->text⟦†⟨CppTemplatePrefix(#csortvars?)⟩¶⟧), CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)))

/* Generate GetValueXX for each form parameters */
func CppGetValue(Bool, Text4_text_sort, Numeric, Numeric, Bool, Text4_text_sort, Text4_text_sort) -> Text4_text_sort

  rule CppGetValue(FALSE, #type, #index, #subindex, #def, #prefix, #qualifier)
  → text⟦†⟨#prefix⟩†⟨#type⟩& †⟨#qualifier⟩getValue†⟨NumberToText(#index)⟩(tosca::Context& ctx, bool mustforce)†⟨
      If(#def, ()->text⟦
{→
return *†⟨FieldName(#index)⟩;←
}⟧, ()->text⟦;⟧)⟩⟧

  rule CppGetValue(TRUE, #type, #index, #subindex, #def, #prefix, #qualifier)
  → text⟦†⟨#prefix⟩†⟨#type⟩& †⟨#qualifier⟩getVar†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩()†⟨
      If(#def, ()->text⟦
{→
return *†⟨VarFieldName(#index, #subindex)⟩;←
}⟧, ()->text⟦;⟧)⟩⟧

/* Generate the generic Sub function for the given `#form` */
func CppFormGetSub(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #formname:String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ TextIf(Not(IsEmpty(MaybeSortsToSorts(#csorts?))), ()->text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
Optional<tosca::Term> †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩Sub(int subi) const†⟨
    If(#def, ()->text⟦
{→
switch (subi)
{→†⟨MaybeCppClassFields(#csorts?, (isvar type index subindex)->CppGetSub(isvar, index))⟩
default: return Optional<tosca::Term>::nullopt;←
}←
}⟧, ()->text⟦;⟧)⟩⟧)

func CppGetSub(Bool, Numeric) -> Text4_text_sort

  rule CppGetSub(FALSE, #index)
  → text⟦¶case ⟨STRING: FormatInteger(Minus(#index, 1))⟩: return make_optional<tosca::Term>(*†⟨FieldName(#index)⟩);⟧

  rule CppGetSub(TRUE, #index) // this is a scoped variable, not a sub. Skip.
  → text⟦⟧

/* Generate the generic SetSub function for the given `#form` */
func CppFormSetSub(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #formname:String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ TextIf(Not(IsEmpty(MaybeSortsToSorts(#csorts?))), ()->text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
void †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩SetSub(int subi, tosca::Term& sub)†⟨
     If(#def, ()->text⟦¶{→
assert(sub.refcount > 0);
switch (subi)
{→†⟨MaybeCppClassFields(#csorts?, (isvar type index subindex)->CppSetSub(isvar, type, index))⟩
default: assert(false);←
}←
}⟧, ()->text⟦;⟧)⟩⟧)

func CppSetSub(Bool, Text4_text_sort, Numeric) -> Text4_text_sort

  rule CppSetSub(FALSE, #type, #index)
  → text⟦
case †⟨NumberToText(Minus(#index, 1))⟩:→
if (†⟨FieldName(#index)⟩)→¶†⟨FieldName(#index)⟩->Release();←
†⟨FieldName(#index)⟩ = &dynamic_cast<†⟨#type⟩&>(sub);
break;←⟧

  rule CppSetSub(TRUE, #type, #index) // this is a scoped variable, not a sub. Skip.
  → text⟦⟧

/* Generate the generic Binder function for the given `#form` */
func CppFormGetBinder(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #formname:String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ TextIf(HasBindersSorts(MaybeSortsToSorts(#csorts?)), ()->text⟦
     †⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
Optional<tosca::Variable> †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩Binder(int subi, int binderi) const†⟨
If(#def, ()->text⟦
{→
switch (subi)
{→†⟨CppGetSubBinders(MaybeSortsToSorts(#csorts?), 1)⟩
default: return Optional<tosca::Variable>::nullopt;←
}←
}⟧, ()->text⟦;⟧)⟩⟧)

func CppGetSubBinders(List<Core_csort_sort>, Numeric) -> Text4_text_sort

  rule CppGetSubBinders(csort*⟦⟧, #index)
  → text⟦⟧

  rule CppGetSubBinders(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦†⟨If(HasBindersSort(#csort),
          ()->text⟦
case †⟨NumberToText(Minus(#index, 1))⟩:
{→
switch (binderi)
{→†⟨CppClassField(CppTypes(#csort), #index, 1, (isvar type index subindex)->CppGetBinder(isvar, index, subindex))⟩
default: return Optional<Variable>::nullopt;←
}←
}⟧,
           ()->text⟦⟧)⟩
      †⟨CppGetSubBinders(#csort*, Plus(#index, 1))⟩⟧

func CppGetBinder(Bool, Numeric, Numeric) -> Text4_text_sort

  rule CppGetBinder(FALSE, #index, #subindex)
  → text⟦⟧

  rule CppGetBinder(TRUE, #index, #subindex)
  → text⟦¶case †⟨NumberToText(Minus(#subindex, 1))⟩: return *†⟨VarFieldName(#index, #subindex)⟩;⟧

  /* Generate the generic SetBinder function for the given `#form` */
  func CppFormSetBinder(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #formname:String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
  → TextIf(HasBindersSorts(MaybeSortsToSorts(#csorts?)), ()->text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
void †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩SetBinder(int i, int j, tosca::Variable& var)†⟨
      If(#def, ()->text⟦
{→
switch (i)
{→†⟨CppSetSubBinders(MaybeSortsToSorts(#csorts?), 1)⟩
default: assert(false);←
}←
}⟧, ()->text⟦;⟧)⟩⟧)

  func CppSetSubBinders(List<Core_csort_sort>, Numeric) -> Text4_text_sort

    rule CppSetSubBinders(csort*⟦⟧, #index)
    → text⟦⟧

    rule CppSetSubBinders(csort*⟦ ##csort ##csort* ⟧, #index)
    → text⟦†⟨If(HasBindersSort(#csort),
            ()->text⟦
case †⟨NumberToText(Minus(#index, 1))⟩:
{→
switch (j)
{→†⟨CppClassField(CppTypes(#csort), #index, 1, (isvar type index subindex)->CppSetBinder(isvar, type, index, subindex))⟩
default: assert(false);←
}
break;←
}⟧,
             ()->text⟦⟧)⟩†⟨CppSetSubBinders(#csort*, Plus(#index, 1))⟩⟧

  func CppSetBinder(Bool, Text4_text_sort, Numeric, Numeric) -> Text4_text_sort

    rule CppSetBinder(FALSE, #type, #index, #subindex)
    → text⟦⟧

    rule CppSetBinder(TRUE, #type, #index, #subindex)
    → text⟦
case †⟨NumberToText(Minus(#subindex, 1))⟩:→
if (†⟨VarFieldName(#index, #subindex)⟩) †⟨VarFieldName(#index, #subindex)⟩->Release();
†⟨VarFieldName(#index, #subindex)⟩ = &dynamic_cast<†⟨#type⟩&>(var);
break;←⟧

/* Generate the MakeFree method for the given `#formname` */
func CppFormMakeFree(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #formname:String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ TextIf(Not(IsEmpty(MaybeSortsToSorts(#csorts?))), ()->text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
tosca::Variable& †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩MakeFree(tosca::Context& ctx, int subi, std::string& name)†⟨
If(#def, ()->text⟦¶{→
switch (subi)
{→†⟨MaybeCppClassFields(#csorts?, (isvar type index subindex)->CppMakeVariable(isvar, type, index))⟩
default: assert(false);←
}←
}⟧, ()->text⟦;⟧)⟩⟧)

/* Generate the MakeBound method for the given `#formname` */
func CppFormMakeBound(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #formname:String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ TextIf(Not(IsEmpty(MaybeSortsToSorts(#csorts?))), ()->text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
tosca::Variable& †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩MakeBound(tosca::Context& ctx, int subi, int binderi, std::string& name)†⟨
If(#def, ()->text⟦¶{→
switch (subi)
{→†⟨CppMakeBoundBinders(MaybeSortsToSorts(#csorts?), 1)⟩
default: assert(false);←
}←
}⟧, ()->text⟦;⟧)⟩⟧)

func CppMakeBoundBinders(List<Core_csort_sort>, Numeric) -> Text4_text_sort

  rule CppMakeBoundBinders(csort*⟦⟧, #index)
  → text⟦⟧

  rule CppMakeBoundBinders(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦†⟨If(HasBindersSort(#csort),
          ()->text⟦
case †⟨NumberToText(Minus(#index, 1))⟩:
{→
switch (binderi)
{→†⟨CppClassField(CppTypes(#csort), #index, 1, (isvar type index subindex)->CppMakeVariable(isvar, type, subindex))⟩
default: assert(false);←
}
break;←
}⟧,
           ()->text⟦⟧)⟩†⟨CppMakeBoundBinders(#csort*, Plus(#index, 1))⟩⟧


func CppMakeVariable(Bool, Text4_text_sort, Numeric) -> Text4_text_sort
rule CppMakeVariable(TRUE, #type, #index)  → text⟦⟧
rule CppMakeVariable(FALSE, #type, #index) → text⟦¶case †⟨NumberToText(Minus(#index, 1))⟩: return †⟨#type⟩::MakeVariable(ctx, name);⟧

/* Generate the MakeTerm method for the given `#formname` */
func CppFormMakeTerm(#sortname: String, #csortvars?:List<Core_csortvars_sort>, #formname:String, #csorts?: List<Core_csorts_sort>, #def: Bool) -> Text4_text_sort
→ TextIf(Not(IsEmpty(MaybeSortsToSorts(#csorts?))), ()->text⟦†⟨TextIf(#def, ()->CppTemplatePrefix(#csortvars?))⟩
tosca::Term& †⟨CppFormQualifier(#formname, #csortvars?, CFC_CONS, #def)⟩MakeTerm(tosca::Context& ctx, int subi, std::string& symbol)†⟨
If(#def, ()->text⟦¶{→
switch (subi)
{→†⟨MaybeCppClassFields(#csorts?, (isvar type index subindex)->CppMakeTerm(isvar, type, index))⟩
default: assert(false);←
}←
}⟧, ()->text⟦;⟧)⟩⟧)


func CppMakeTerm(Bool, Text4_text_sort, Numeric) -> Text4_text_sort
rule CppMakeTerm(TRUE, #type, #index)  → text⟦⟧
rule CppMakeTerm(FALSE, #type, #index) → text⟦¶case †⟨NumberToText(Minus(#index, 1))⟩: return †⟨#type⟩::MakeTerm(ctx, symbol);⟧

// --- Generate code for class field declarations, initialization, lookup, and update.

/* Generic form sorts traversal */
func MaybeCppClassFields(List<Core_csorts_sort>, (Bool Text4_text_sort Numeric Numeric)->Text4_text_sort) -> Text4_text_sort

  rule MaybeCppClassFields(csorts?⟦⟧, #print)
  → text⟦⟧

  rule MaybeCppClassFields(csorts?⟦ ( ##csort* ) ⟧, #print)
  → CppClassFields(#csort*, 1, #print)

func CppClassFields(List<Core_csort_sort>, Numeric, (Bool Text4_text_sort Numeric Numeric)->Text4_text_sort) -> Text4_text_sort

  rule CppClassFields(csort*⟦⟧, #index, #print)
  → text⟦⟧

  rule CppClassFields(csort*⟦ ##csort ##csort* ⟧, #index, #print)
  → text⟦†⟨CppClassField(CppTypes(#csort), #index, 1, #print)⟩†⟨CppClassFields(#csort*, Plus(#index, 1), #print)⟩⟧

func CppClassField(List<Text4_text_sort>, Numeric, Numeric, (Bool Text4_text_sort Numeric Numeric)->Text4_text_sort) -> Text4_text_sort

  rule CppClassField((#type,), #index, #subindex, #print)
  → #print(FALSE, #type, #index, #subindex)

  rule CppClassField((#type, #types...), #index, #subindex, #print)
  → text⟦†⟨#print(TRUE, #type, #index, #subindex)⟩†⟨CppClassField(#types, #index, Plus(#subindex, 1), #print)⟩⟧

func FieldName(#index: Numeric) -> Text4_text_sort
→ text⟦field†⟨NumberToText(#index)⟩⟧

func VarFieldName(#index: Numeric, #subindex: Numeric) -> Text4_text_sort
→ text⟦field†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩⟧

/* Print separator when not first field */
func FieldSep(#sep: Text4_text_sort, #index: Numeric, #subindex: Numeric) -> Text4_text_sort
→ TextIf(Not(And(NumberEqual(#index, 1), NumberEqual(#subindex, 1))), ()->#sep)

/* Field initialization helper */
func CppInitField(Bool, Text4_text_sort, Numeric, Numeric) -> Text4_text_sort
rule CppInitField(FALSE, #type, #index, #subindex) → text⟦†⟨FieldSep(text⟦, ⟧, #index, #subindex)⟩†⟨FieldName(#index)⟩(&†⟨ParamName(#index)⟩)⟧
rule CppInitField(TRUE, #type, #index, #subindex)  → text⟦†⟨FieldSep(text⟦, ⟧, #index, #subindex)⟩†⟨VarFieldName(#index, #subindex)⟩(&†⟨VarParamName(#index, #subindex)⟩)⟧

/* Field nullification  helper */
func CppNullifyField(Bool, Text4_text_sort, Numeric, Numeric) -> Text4_text_sort
rule CppNullifyField(FALSE, #type, #index, #subindex) → text⟦†⟨FieldSep(text⟦, ⟧, #index, #subindex)⟩†⟨FieldName(#index)⟩(0)⟧
rule CppNullifyField(TRUE, #type, #index, #subindex)  → text⟦†⟨FieldSep(text⟦, ⟧, #index, #subindex)⟩†⟨VarFieldName(#index, #subindex)⟩(0)⟧

// --- Function translation functions

func CppFunctionDecl(#env: {String : EnvEntry}, #key: String, #header: Bool) -> Text4_text_sort
→ CppFunctionDeclD(#env, UnSOME(GetFuncSort(GetContent(#env), #key)), #header, FALSE)

func CppFunctionDeclD({String : EnvEntry}, Core_cdecl_sort, Bool, Bool) -> Text4_text_sort
rule CppFunctionDeclD(#env, cdecl⟦ ##canno* ##EXTERN? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧, #header, #forward)
→ TextIf(And(Not(HasAnnotation("Extern", #canno*)), Or(#forward, Or(And(#header, Not(IsEmpty(#csortvars?))), And(Not(#header), IsEmpty(#csortvars?))))), ()->
  text⟦¶¶†⟨CppTemplatePrefix(#csortvars?)⟩
†⟨CppTypeRef(#csort)⟩ †⟨CppFnName(#CONSTRUCTOR)⟩(tosca::Context& ctx†⟨CppMaybeFunctionParams(SetContext(SetFnAnno(#env, #canno*), text⟦ctx⟧, 1), #csorts?, (env) ->
      CppMaybeBody(env, #CONSTRUCTOR, GenBody(#csortvars?, #header, #forward)))⟩⟧) // missing )

func CppMaybeFunctionParams({String : EnvEntry}, List<Core_csorts_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
   rule CppMaybeFunctionParams(#env, csorts?⟦⟧, #cont)
   → #cont(#env)

   rule CppMaybeFunctionParams(#env, csorts?⟦ ( ##csort* ) ⟧, #cont)
   → CppFunctionParams(NewParams(#env), #csort*, #cont)

/* Generate method signature and record the argument names in the environment, keeping them in order */
func CppFunctionParams({String : EnvEntry}, List<Core_csort_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppFunctionParams(#env, csort*⟦ ⟧, #cont)
   → #cont(#env)

  rule CppFunctionParams(#env, csort*⟦ ##csort ##csort* ⟧, #cont)
  → CppFunctionParam(#env, CppTypes(#csort), #csort, (env) -> CppFunctionParams(env, #csort*, #cont))

func CppFunctionParam({String : EnvEntry}, List<Text4_text_sort>, Core_csort_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // Monomorphic sort
  rule CppFunctionParam(#env, (#type,), csort⟦ ##canno* ##CONSTRUCTOR ##csorts? ⟧, #cont)
  → text⟦, †⟨#type⟩& ⟨STRING: value:String⟩†⟨#cont(AddParam(#env, text⟦⟨STRING: value⟩⟧, csort⟦ ##canno* ##CONSTRUCTOR ##csorts? ⟧))⟩⟧

  // Sort variable
  rule CppFunctionParam(#env, (#type,), csort⟦ ##canno*  ##VARIABLE ⟧, #cont)
  → text⟦, †⟨#type⟩& ⟨STRING: value:String⟩†⟨#cont(AddParam(#env, text⟦⟨STRING: value⟩⟧, csort⟦ ##canno* ##VARIABLE ⟧))⟩⟧

  // Syntactic variable sort
 rule CppFunctionParam(#env, (#type, #types...), csort⟦ [ ##csort ] ##csort2 ⟧, #cont)
 → text⟦, †⟨#type⟩& ⟨STRING: var:String⟩†⟨
     CppFunctionParam(AddParam(#env, text⟦⟨STRING: var⟩⟧, #csort), #types, #csort2, #cont)⟩⟧

 // Formal parameter sort
 rule CppFunctionParam(#env, #types, csort⟦ ##canno* ( ##csort ) ##csort2 ⟧, #cont)
 → CppFunctionParam(#env, #types, #csort2, #cont)

 rule CppFunctionParam(#env, (#type, ), csort⟦ ##canno* { ##cmapsort* } ⟧, #cont)
 → text⟦, †⟨#type⟩& ⟨STRING: map:String⟩†⟨
     #cont(AddParam(#env, text⟦⟨STRING: map⟩⟧, csort⟦ ##canno* { ##cmapsort* } ⟧))⟩⟧

 rule CppFunctionParam(#env, #types, csort⟦ ##canno* data ##csort ⟧, #cont)
 → CppFunctionParam(#env, #types, #csort, #cont)

 rule CppFunctionParam(#env, #types, csort⟦ ##canno* thunk ##csort ⟧, #cont)
 → CppFunctionParam(#env, #types, #csort, #cont)

/* Generate function body. See GenBody for the exact condition. */
func CppMaybeBody({String : EnvEntry}, String, Bool /* generate body? */) -> Text4_text_sort
rule CppMaybeBody(#env, #key, FALSE) → text⟦);⟧
rule CppMaybeBody(#env, #key, TRUE)  → text⟦) †⟨CppBody(#env, GetRulesForKeyC(GetContent(#env), #key))⟩⟧

func CppBody({String : EnvEntry}, Option<List<Core_cdecl_sort>>) -> Text4_text_sort

// No rules: it must be an external function (not yet checked but should)
  rule CppBody(#env, NONE)
  → text⟦;⟧

  // At least one rule: not external
  rule CppBody(#env, SOME(#rules))
  → text⟦
{→†⟨TextMapFoldES((rule) -> CppBodyRule(SetDiscard(NewMetas(NewVars(#env)), ()), rule), #rules)⟩†⟨TextIf(Not(HasAnnotation("Fallback", GetFnAnno(#env))), ()->text⟦¶throw std::runtime_error("Missing case");⟧)⟩←¶}⟧

// --- Start method body

func CppBodyRule({String : EnvEntry}, Core_cdecl_sort) -> Text4_text_sort

  rule CppBodyRule(#env, cdecl⟦ ##canno* rule  ##canno*2 ##CONSTRUCTOR ( ##cterm* ) ##csortanno? → ##cterm ⟧)
  → CppPattern(SetRuleAnno(#env, #canno*), #cterm*, #cterm)

  rule CppBodyRule(#env, cdecl⟦ ##canno* rule ##CONSTRUCTOR → ##cterm ⟧)
  → CppContractum(SetRuleAnno(#env, #canno*), #cterm)

// --- Pattern matching

func CppPattern(#env: {String : EnvEntry}, #cterms: List<Core_cterm_sort>, #contractum: Core_cterm_sort) -> Text4_text_sort
→ CppCasePattern(SetDelayEntries(#env, {}), #cterms, #contractum)

// Iterate over top-level pattern arguments
func CppCasePattern({String : EnvEntry}, List<Core_cterm_sort>, Core_cterm_sort) -> Text4_text_sort

  rule CppCasePattern(#env, cterm*⟦⟧, #contractum)
  → CppContractum(#env, #contractum)

  rule CppCasePattern(#env, cterm*⟦ ##cterm ##cterm* ⟧, #contractum)
  → let #currentParam = CurrentParam(#env)
    let #currentSort = CurrentParamSort(#env)
    let #nextParam = NextParam(CppMayDiscard(#env, #cterm, GetRuleAnno(#env)))
    CppPatternTerm(#nextParam, #cterm, #currentParam, SOME(#currentSort), PARAMETER, (env) ->
    CppCasePattern(env, #cterm*, #contractum))

// --- Term pattern matching

func CppPatternTerm({String : EnvEntry}, Core_cterm_sort, Text4_text_sort /* Current term */,
                       Option<Core_csort_sort> /* Sort when known */, Storage, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternTerm(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #term, #csort, #storage, #cont)
  → text⟦¶auto ⟨STRING: value:String⟩ = †⟨#term⟩.†⟨CppAsMethodName(#CONSTRUCTOR)⟩(†⟨GetContext(#env)⟩);
if (⟨STRING: value⟩)
{→†⟨CppPatternMaybeSubs(#env, #cterms?, text⟦⟨STRING: value⟩⟧, MaybeFindFormC(GetContent(#env), #csort, #CONSTRUCTOR), #cont)⟩←¶}⟧

  // TODO: check literal
  rule CppPatternTerm(#env, cterm⟦ ##canno* ##cliteral ⟧, #term, #csort, #storage, #cont)
  → #cont(#env)

  // REVISIT: bound variable reordering, ie. (x)(y)#(y, x)
  // For now only accepts patterns of the form (x)...(y)#(x, ... y)
  rule CppPatternTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #term, #csort, #storage, #cont)
  → text⟦†⟨CppPatternMaybeMetaArgs(#env, #METAVAR, #csubst?, #term, #csort, #storage, #cont)⟩⟧

  rule CppPatternTerm(#env, cterm⟦ ##canno* ##VARIABLE  ##csortanno? ⟧, #term, #csort, #storage, #cont)
  → CppPatternVariable(MaybeGetVar(#env, #VARIABLE), #env, #VARIABLE, MaybeSortAnnoToSort(#csortanno?), #term, #cont)

  rule CppPatternTerm(#env, cterm⟦ ##canno* { ##cmapentries? } : { ##cmapsort } ⟧, #term, #csort, #storage, #cont)
  → CppPatternMap(#env, #cmapentries?, #term, #cmapsort, #cont)

  rule CppPatternTerm(#env, cterm⟦ ##canno* [ v ##csortanno? ] ##cterm[v] ⟧, #term, #csort, PARAMETER, #cont)
  → let #currentParam = CurrentParam(#env)
    let #nextParam = NextParam(AddVar(CppMayDiscard(#env, #cterm[var:String], GetRuleAnno(#env)), var, Bound(#term, MaybeSortAnnoToSort(#csortanno?))))
    CppPatternTerm(#nextParam, #cterm[var], #currentParam, SOME(CurrentParamSort(#env)), PARAMETER, #cont)

  rule CppPatternTerm(#env, cterm⟦ ##canno* [ v : ##csort ] ##cterm[v] ⟧, #term, #sort, ARGUMENT, #cont)
  → text⟦
      C†⟨CppType(#csort)⟩Var& ⟨STRING: boundvar:String⟩ = †⟨GetParent(#env)⟩.value().getVar†⟨NumberToText(GetSubIndex(#env))⟩_†⟨NumberToText(GetSubBinderIndex(#env))⟩();†⟨
      CppPatternTerm(IncSubBinderIndex(AddVar(#env, var, Bound(text⟦⟨STRING: boundvar⟩⟧, SOME(#csort)))), #cterm[var], #term, #sort, ARGUMENT, #cont)⟩⟧

  rule CppPatternTerm(#env, cterm⟦ ##canno* ( f  ##csortanno? ) ##cterm[f] ⟧, #term, #csort, #storage, #cont)
  → CppPatternTerm(#env, #cterm[var:String], #term, #csort, #storage, #cont)

  rule CppPatternTerm(#env, cterm⟦ ##canno* ##METAVAR ##csortanno? = ##cterm ⟧, #term, #csort, #storage, #cont)
  → CppPatternNamedTerm(#env, #METAVAR, #cterm, #term, #csort, #storage, #cont)

// Pattern matching on construction arguments.
func CppPatternMaybeSubs( {String : EnvEntry}, List<Core_cterms_sort>, Text4_text_sort, Option<PPair<Core_cdecl_sort Core_cform_sort>>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMaybeSubs(#env, cterms?⟦⟧, #term, #cform, #cont)
  → #cont(#env)

  rule CppPatternMaybeSubs(#env, cterms?⟦()⟧, #term, #cform, #cont)
  → #cont(#env)

  rule CppPatternMaybeSubs(#env, cterms?⟦ ( ##cterm* ) ⟧, #term, SOME(PairCons(#cdecl, cform⟦ ##CONSTRUCTOR ##csortsdefault? ⟧)), #cont)
  → CppPatternSubs(#env, #cterm*, #term, 1, SOME(MaybeSortsDefaultToSorts(#csortsdefault?)), #cont)

  rule CppPatternMaybeSubs(#env, cterms?⟦ ( ##cterm* ) ⟧, #term, NONE, #cont)
  → CppPatternSubs(#env, #cterm*, #term, 1, NONE, #cont)

  func CppPatternSubs( {String : EnvEntry}, List<Core_cterm_sort>,
                     Text4_text_sort /* parent term */, Numeric /* Current subindex */, Option<List<Core_csort_sort>>, /* sub sorts, if known */
                     ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternSubs(#env, cterm*⟦⟧,  #term, #index, #csort*, #cont)
  → #cont(#env)

  rule CppPatternSubs(#env, cterm*⟦ ##cterm ##cterm* ⟧, #term, #index, #csort*, #cont)
  → text⟦¶auto& ⟨STRING: sub:String⟩ = †⟨#term⟩.value().getValue†⟨NumberToText(#index)⟩(†⟨GetContext(#env)⟩, true);†⟨
      CppPatternTerm(SetSubBinderIndex(SetParent(SetSubIndex(#env, #index), #term), 1),
                  #cterm, text⟦⟨STRING: sub⟩⟧, SubSort(#env, #cterm, #csort*), ARGUMENT,
                  (x) -> CppPatternSubs(x, #cterm*, #term, NumberPlus(#index, 1), Maybe((x)->Tail<Core_csort_sort>(x), #csort*), #cont))⟩⟧

  // --- Variable pattern matching outside of meta

func CppPatternVariable(Option<VarEntry>, {String : EnvEntry}, String, Option<Core_csort_sort>, Text4_text_sort /* Current term */, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // First variable occurrence: the term is a free variable.
  rule CppPatternVariable(NONE, #env, #variable, #csort, #term, #cont)
  → text⟦¶Optional<C†⟨MaybeCppTypeD(#csort, text⟦⟧)⟩Var> ⟨STRING: ovar⟩ = †⟨#term⟩.GetVariable();
if (⟨STRING: ovar⟩)
{→
C†⟨MaybeCppTypeD(#csort, text⟦⟧)⟩Var& ⟨STRING: var⟩ = ⟨STRING: ovar⟩.value();
†⟨CppApplyDelayEntries(AddVar(#env, #variable, Free(text⟦⟨STRING: var⟩⟧, #csort)), #variable, #cont)⟩←¶}⟧

  rule CppPatternVariable(SOME(Bound(#var, #sort)), #env, #variable, #csort, #term, #cont)
  → text⟦¶Optional<C†⟨MaybeCppTypeD(#csort, text⟦⟧)⟩Var> ⟨STRING: ovar⟩ = †⟨#term⟩.GetVariable();
if (⟨STRING: ovar⟩ && †⟨#var⟩ == ⟨STRING: ovar⟩.value())
{→†⟨#cont(#env)⟩←¶}⟧

  // --- pattern matching inside meta

// Iterate over meta arguments and find corresponding bound variables, and update environment
func CppPatternMaybeMetaArgs({String : EnvEntry}, String, List<Core_csubst_sort>, Text4_text_sort /* Current term */, Option<Core_csort_sort>,
                             Storage, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMaybeMetaArgs(#env, #metavar, csubst?⟦⟧, #term, #csort, #storage, #cont)
  → CppApplyDelayEntries(AddMeta(#env, #metavar, #term, (), #storage), #metavar, #cont)

  // meta substitution
  rule CppPatternMaybeMetaArgs(#env, #metavar, csubst?⟦ [ ##cterm* ] ⟧, #term, #csort, #storage, #cont)
  → #cont(AddMeta(#env, #metavar, #term, Map((x) -> CppFindBoundVar(#env, x), #cterm*), #storage))

  func CppFindBoundVar( {String : EnvEntry},Core_cterm_sort) -> Text4_text_sort

  rule CppFindBoundVar(#env, cterm⟦ ##canno* ##VARIABLE ⟧)
  → GetVar(#env, #VARIABLE)

  rule CppFindBoundVar(#env, #cterm)
  → Error(ConcatString("Invalid argument in metavariable: ", PrintTerm("", #cterm)))

  // --- Map pattern matching

func CppPatternMap({String : EnvEntry}, List<Core_cmapentries_sort>, Text4_text_sort, Core_cmapsort_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMap(#env, cmapentries?⟦⟧, #term, #cmapsort, #cont)
  → text⟦¶if (†⟨#term⟩.isEmpty())¶{→¶†⟨#cont(#env)⟩←¶}⟧

  rule CppPatternMap(#env, cmapentries?⟦ ##cmapentry* ⟧, #term, #cmapsort, #cont)
  → CppPatternMapEntries(#env, #cmapentry*, #term, #cmapsort, #cont)

func CppPatternMapEntries({String : EnvEntry}, List<Core_cmapentry_sort>, Text4_text_sort, Core_cmapsort_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMapEntries(#env, cmapentry*⟦ ##cmapentry ##cmapentry* ⟧, #term, #cmapsort, #cont)
  → CppPatternMapEntry(#env, #cmapentry, #term, #cmapsort, (env)->CppPatternMapEntries(env, #cmapentry*, #term, #cmapsort, #cont))

  rule CppPatternMapEntries(#env, cmapentry*⟦  ⟧, #term, #cmapsort, #cont)
  → #cont(#env)

func CppPatternMapEntry({String : EnvEntry}, Core_cmapentry_sort, Text4_text_sort, Core_cmapsort_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMapEntry(#env, cmapentry⟦ : ##METAVAR ⟧, #term, #cmapsort, #cont)
  → #cont(AddMeta(#env, #METAVAR, #term, (), ARGUMENT))

  rule CppPatternMapEntry(#env, cmapentry⟦  ¬ ##METAVAR ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetMetaVarO(#env, #METAVAR),
      (key)->text⟦¶if (!†⟨#term⟩.contains(†⟨key⟩))¶{→†⟨#cont(#env)⟩←¶}⟧,
      ()->#cont(DelayMapEntry(#env, #METAVAR, MapEntry(cmapentry⟦ ¬ ##METAVAR ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ##METAVAR : ##cterm ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetMetaVarO(#env, #METAVAR),
      (key)->text⟦¶auto ⟨STRING: mval⟩ = †⟨#term⟩.getValue(†⟨GetContext(#env)⟩, †⟨key⟩).asSOME(†⟨GetContext(#env)⟩);
if (⟨STRING: mval⟩)
{→
†⟨CppType(GetMapValueSort(#cmapsort))⟩& ⟨STRING: value⟩ = ⟨STRING: mval⟩.value().getValue1(ctx, true);
†⟨CppPatternTerm(#env, #cterm, text⟦⟨STRING: value⟩⟧, SOME(GetMapValueSort(#cmapsort)), ARGUMENT, #cont)⟩←
}⟧,
      ()->#cont(DelayMapEntry(#env, #METAVAR, MapEntry(cmapentry⟦ ##METAVAR : ##cterm ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ##VARIABLE ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetVarO(#env, #VARIABLE),
      (key)->text⟦¶if (!†⟨#term⟩.containsVar(†⟨UnVarVar(key)⟩.GetVariable()))
{→†⟨#cont(#env)⟩←¶}⟧,
      ()->#cont(DelayMapEntry(#env, #VARIABLE, MapEntry(cmapentry⟦ ##VARIABLE ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ¬ ##VARIABLE ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetVarO(#env, #VARIABLE),
      (key)->text⟦¶if (†⟨#term⟩.containsVar(†⟨UnVarVar(key)⟩.GetVariable()))
{→†⟨#cont(#env)⟩←¶}⟧,
      ()->#cont(DelayMapEntry(#env, #VARIABLE, MapEntry(cmapentry⟦ ¬ ##VARIABLE ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ##VARIABLE : ##cterm ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetVarO(#env, #VARIABLE),
      (key)->text⟦¶auto ⟨STRING: mval⟩ = †⟨#term⟩.getValue(†⟨GetContext(#env)⟩, †⟨UnVarVar(key)⟩.Use()).asSOME(†⟨GetContext(#env)⟩);
if (⟨STRING: mval⟩)
{→
†⟨CppType(GetMapValueSort(#cmapsort))⟩& ⟨STRING: value⟩ = ⟨STRING: mval⟩.value().getValue1(ctx, true);
†⟨CppPatternTerm(#env, #cterm, text⟦⟨STRING: value⟩⟧, SOME(GetMapValueSort(#cmapsort)), ARGUMENT, #cont)⟩←
}⟧,
      ()->#cont(DelayMapEntry(#env, #VARIABLE, MapEntry(cmapentry⟦ ##VARIABLE : ##cterm ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ##STRING ⟧, #term, #cmapsort, #cont)
  → text⟦¶if (†⟨#term⟩.contains(†⟨CppExprLiteral(cliteral⟦ ##STRING ⟧)⟩))
{→†⟨#cont(#env)⟩←}⟧

  rule CppPatternMapEntry(#env, cmapentry⟦ ¬ ##STRING ⟧, #term, #cmapsort, #cont)
  → text⟦¶if (!†⟨#term⟩.contains(†⟨CppExprLiteral(cliteral⟦ ##STRING ⟧)⟩))
{→†⟨#cont(#env)⟩←}⟧

  rule CppPatternMapEntry(#env, cmapentry⟦ ##STRING  : ##cterm ⟧, #term, #cmapsort, #cont)
 → text⟦¶auto ⟨STRING: mval⟩ = †⟨#term⟩.getValue(†⟨GetContext(#env)⟩, †⟨CppExprLiteral(cliteral⟦ ##STRING ⟧)⟩).asSOME(†⟨GetContext(#env)⟩);
if (⟨STRING: mval⟩)
{→
†⟨CppType(GetMapValueSort(#cmapsort))⟩& ⟨STRING: value⟩ = ⟨STRING: mval⟩.value().getValue1(ctx, true);
†⟨CppPatternTerm(#env, #cterm, text⟦⟨STRING: value⟩⟧, SOME(GetMapValueSort(#cmapsort)), ARGUMENT, #cont)⟩
←}⟧


/* Apply delayed map entries waiting for the given `#var` (meta or not) to be initialized */
func CppApplyDelayEntries(#env: {String : EnvEntry}, #var: String, #cont:({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
→ CppApplyDelayEntriesAux(#env, GetDelayEntriesForVar(#env, #var), #cont)

func CppApplyDelayEntriesAux({String : EnvEntry}, List<MapEntry>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
rule CppApplyDelayEntriesAux(#env, Cons(MapEntry(#cmapentry, #term, #cmapsort), #entries), #cont) → CppPatternMapEntry(#env, #cmapentry, #term, #cmapsort, (env)->CppApplyDelayEntriesAux(env, #entries, #cont))
rule CppApplyDelayEntriesAux(#env, Nil                                                    , #cont) → #cont(#env)

// --- Named term

func CppPatternNamedTerm(#env: {String : EnvEntry}, #metavar: String, #cterm: Core_cterm_sort, #term: Text4_text_sort,
                         #csort: Option<Core_csort_sort>, #storage: Storage, #cont: ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
→ CppPatternMaybeMetaArgs(#env, #metavar, csubst?⟦⟧, #term, #csort, #storage, (env)->
  CppPatternTerm(env, #cterm, #term, #csort, #storage, #cont))

//  --------- Helper function for pattern matching

/* Get sub sort. Get it from term and if not available on sort */
func SubSort(#env: {String : EnvEntry}, #cterm: Core_cterm_sort, #csorts?: Option<List<Core_csort_sort>>) -> Option<Core_csort_sort>
→ SubSort2(SubSortFromTerm(#env, #cterm), #csorts?)

func SubSort2(Option<Core_csort_sort>, Option<List<Core_csort_sort>>) -> Option<Core_csort_sort>
  rule SubSort2(SOME(#csort:Core_csort_sort), #)       → SOME(#csort)
  rule SubSort2(NONE, NONE)                            → NONE
  rule SubSort2(NONE, SOME(csort*⟦ ##csort ##csort* ⟧)) → SOME(#csort)

func SubSortFromTerm({String : EnvEntry}, Core_cterm_sort) -> Option<Core_csort_sort>

  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##cqconstructor ##csortargs? ##cterms? : ##csort ⟧)
  → SOME(#csort)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##STRING ⟧)
  → SOME(csort⟦ String ⟧)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##NUMBER ⟧)
  → SOME(csort⟦ Numeric⟧)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##VARIABLE ##csortanno? ⟧)
  → SubSortFromVar(MaybeGetVar(#env, #VARIABLE), #VARIABLE)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧)
  → MaybeSortAnnoToSort(#csortanno?)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* let ##METAVAR ##csortanno? = ##cterm ##cterm2 ⟧)
  → SubSortFromTerm(#env, #cterm2)

  rule SubSortFromTerm(#env, cterm⟦ ##canno* { ##cmapentries? } ##csortanno? ⟧)
  → MaybeSortAnnoToSort(#csortanno?)

  // TODO: maybe error?
  rule SubSortFromTerm(#env, cterm⟦ ##canno* [ x ##csortanno?[] ] ##cterm[x] ⟧)
  → SubSortFromTerm(#env, #cterm[var:String])

  // TODO: maybe error?
  rule SubSortFromTerm(#env, cterm⟦ ##canno* ( f ##csortanno?[] ) ##cterm[f] ⟧)
  → SubSortFromTerm(#env, #cterm[var:String])

func SubSortFromVar(Option<VarEntry>, String) -> Option<Core_csort_sort>
rule SubSortFromVar(NONE, #var)             → NONE
rule SubSortFromVar(SOME(#varEntry), #var)  → UnVarSort(#varEntry)

// ---- Reference counting

/* Determine whether the current parameter must be kept or not. */
func CppMayDiscard({String : EnvEntry}, Core_cterm_sort, List<Core_canno_sort>) -> {String : EnvEntry}

  rule CppMayDiscard(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #ruleanno*)
  → CppMayDiscardMeta(#env, #METAVAR, IfPresent(GetAnnotation("KeepAll", #ruleanno*), (anno)->GetAnnotationArgs(anno), ()->()))

  rule CppMayDiscard(#env, cterm⟦ ##canno* ##METAVAR ##csortanno? = ##cterm  ⟧, #ruleanno*)
  → CppMayDiscardMeta(#env, #METAVAR, IfPresent(GetAnnotation("KeepAll", #ruleanno*), (anno)->GetAnnotationArgs(anno), ()->()))

  // TODO: check for binder reuse. If not, release!
  rule CppMayDiscard(#env, cterm⟦ ##canno* [ x ##csortanno? ] ##cterm[x] ⟧, #ruleanno*)
  → #env

  rule CppMayDiscard(#env, cterm⟦ ##canno* ( f ##csortanno? ) ##cterm[f] ⟧, #ruleanno*)
  → #env

  rule CppMayDiscard(#env, #cterm, #ruleanno*)
  → AddDiscard(#env, CurrentParam(#env))

func CppMayDiscardMeta(#env: {String : EnvEntry}, #meta: String, #keep: List<Core_cterm_sort>) -> {String : EnvEntry}
→ If(CppMustKeep(#keep, #meta), ()->#env, ()->AddDiscard(#env, CurrentParam(#env)))

/* Discard term parameters not used in the contraction */
// TODO: CLOSURES ARE NOT RELEASED YET!!
func CppDiscard(#env: {String : EnvEntry}) -> Text4_text_sort
→ TextMapFoldES((param)->text⟦¶†⟨param⟩.Release();⟧, GetDiscard(#env))

// Tell whether the given `#meta` variable must be kept
func CppMustKeep(#keep: List<Core_cterm_sort>, #meta:String) -> Bool
→ HasOption(PickFirst(#keep, (term)->IsNamedMeta(term, #meta)))

/* Keep subterm used in contraction */
func CppKeepSub(#env: {String : EnvEntry}, #canno*: List<Core_canno_sort>) -> Text4_text_sort
→ CppKeepSub2(#env, IfPresent(GetAnnotation("KeepAll", #canno*), (anno)->GetAnnotationArgs(anno), ()->()))

func CppKeepSub2(#env: {String : EnvEntry}, #keep: List<Core_cterm_sort>) -> Text4_text_sort
→ TextMapFoldES((annometa)->
                  If(CgIsArgument(GetMetaStorage(#env, Snd(annometa))),
                    ()->text⟦¶†⟨GetMetaVar(#env, Snd(annometa))⟩.AddRef();⟧,
                    ()->text⟦⟧),
                GetAnnoMetaVariables(#keep))

// ----- Contraction

func CppContractum(#env: {String : EnvEntry}, #term: Core_cterm_sort) -> Text4_text_sort
→ text⟦†⟨CppKeepSub(#env, GetRuleAnno(#env))⟩†⟨
    CppDiscard(#env)⟩†⟨
    CppFreshesTerm(SetCounter(SetFreshCounter(#env, 0), 0), #term, (env)->
    CppStatementTerm(SetCounter(env, 0), #term, (env stmt) -> stmt))⟩⟧

/* Generate the contraction code. Two passes are performed:
   - the first pass generates statements initializing fresh and bound variables. Variable names are deterministic using an internal counter
   - the second pass generates statements and expressions. Bound variables names are recomputed in a deterministic manner
    */

// TODO: issue in type inference prevent using type alias
type CppConsumer = ({String : EnvEntry} /* Environment */ Text4_text_sort /* Statement or Expression */)->Text4_text_sort

// ---- Generate term code - Produces C++ statements

func CppStatementTerm({String : EnvEntry}, Core_cterm_sort, ({String : EnvEntry} Text4_text_sort)->Text4_text_sort) -> Text4_text_sort

rule CppStatementTerm(#env, cterm⟦ ##canno* let ##METAVAR : ##csort = ##cterm ##cterm2 ⟧, #cont)
→ let #cppvar = text⟦⟨STRING: Mangle(RemoveFirstChar(#METAVAR))⟩⟧
  CppExprTerm(SetInline(#env), #cterm, (env letexpr)->
  text⟦¶†⟨CppType(#csort)⟩& †⟨#cppvar⟩ = †⟨letexpr⟩;†⟨
    CppStatementTerm(AddMeta(env, #METAVAR, #cppvar, (), ARGUMENT), #cterm2, #cont)⟩⟧)

rule CppStatementTerm(#env, #cterm, #cont)
→ CppExprTerm(SetInline(#env), #cterm, (env expr)->#cont(env, text⟦¶return †⟨expr⟩;⟧))

// ---- Generate fresh variable - Only in C++ statement mode

func CppFreshesTerm({String : EnvEntry}, Core_cterm_sort, ({String : EnvEntry})->Text4_text_sort) -> Text4_text_sort

  rule CppFreshesTerm(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #cont)
  → CppFreshesMaybeTerms(#env, #cterms?, #cont)

  rule CppFreshesTerm(#env, cterm⟦ ##canno* ##cliteral ⟧, #cont)
  → #cont(#env)

  rule CppFreshesTerm(#env, cterm⟦ ##canno* ##VARIABLE ##csortanno? ⟧, #cont)
  → CppFreshesVariable(#env, GetAnnotation("Reuse", #canno*), MaybeGetVar(#env, #VARIABLE), #VARIABLE, #csortanno?, TRUE, #cont)

  rule CppFreshesTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #cont)
  → CppFreshesMaybeTerms(#env, #cterms?, (env) -> CppFreshesMaybeSubst(env, #csubst?, #cont))

  rule CppFreshesTerm(#env, cterm⟦ ##canno* [ x ##csortanno? ] ##cterm[x] ⟧, #cont)
  → CppFreshesVariable(#env, GetAnnotation("Reuse", #canno*), NONE, var, #csortanno?, FALSE, (env) -> CppFreshesTerm(env, #cterm[var], #cont))

  rule CppFreshesTerm(#env, cterm⟦ ##canno* ( f ##csortanno?[] ) ##cterm[f] ⟧, #cont)
  → CppFreshesTerm(AddVar(#env, var, Formal(text⟦ dummy ⟧, NONE)), #cterm[var], #cont)

  rule CppFreshesTerm(#env, cterm⟦ ##canno* { ##cmapentries? } ##csortanno? ⟧, #cont)
  → Error("Internal Error: map expression must no occur in the contraction.")

  rule CppFreshesTerm(#env, cterm⟦ ##canno* thunk ##cterm ⟧, #cont)
  → CppFreshesTerm(#env, #cterm, #cont)

  rule CppFreshesTerm(#env, cterm⟦ ##canno* let ##METAVAR ##csortanno? = ##cterm ##cterm2 ⟧, #cont)
  → CppFreshesTerm(#env, #cterm, (env)->CppFreshesTerm(env, #cterm2, #cont))

func CppFreshesMaybeTerms({String : EnvEntry}, List<Core_cterms_sort>, ({String : EnvEntry})->Text4_text_sort) -> Text4_text_sort
rule CppFreshesMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧, #cont) → CppFreshesTerms(#env, #cterm*, #cont)
rule CppFreshesMaybeTerms(#env, #cterms?              , #cont) → #cont(#env)

func CppFreshesTerms({String : EnvEntry}, List<Core_cterm_sort>, ({String : EnvEntry})->Text4_text_sort) -> Text4_text_sort
rule CppFreshesTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, #cont) → CppFreshesTerm(#env, #cterm, (env) -> CppFreshesTerms(env, #cterm*, #cont))
rule CppFreshesTerms(#env, cterm*⟦                  ⟧, #cont) → #cont(#env)

func CppFreshesMaybeSubst({String : EnvEntry}, List<Core_csubst_sort>, ({String : EnvEntry})->Text4_text_sort) -> Text4_text_sort
rule CppFreshesMaybeSubst(#env, csubst?⟦              ⟧, #cont) → #cont(#env)
rule CppFreshesMaybeSubst(#env, csubst?⟦ [ ##cterm* ] ⟧, #cont) → CppFreshesTerms(#env, #cterm*, #cont)

func CppFreshesVariable({String : EnvEntry}, Option<Core_canno_sort>, Option<VarEntry>, String, List<Core_csortanno_sort>, Bool /*Fresh or Bound?*/, ({String : EnvEntry})->Text4_text_sort) -> Text4_text_sort

  // New fresh variable, no reuse
  rule CppFreshesVariable(#env, NONE, NONE, #var, csortanno?⟦ : ##csort ⟧, TRUE, #cont)
  → let #cppvar = text⟦fresh†⟨NumberToText(GetFreshCounter(#env))⟩⟧
    let #cpptype = CppType(#csort)
    text⟦¶C†⟨#cpptype⟩Var& †⟨#cppvar⟩ = var†⟨#cpptype⟩(†⟨GetContext(#env)⟩, †⟨Text-QuoteEscape(Show(#var))⟩);⟨
      #cont(IncFreshCounter(AddVar(#env, #var, Fresh(#cppvar, SOME(#csort)))))⟩⟧

  // New bound variable, no reuse
  rule CppFreshesVariable(#env, NONE, NONE, #var, csortanno?⟦ : ##csort ⟧, FALSE, #cont)
  → let #cppvar = text⟦bound†⟨NumberToText(GetCounter(#env))⟩⟧
    let #cpptype = CppType(#csort)
    text⟦¶C†⟨#cpptype⟩Var& †⟨#cppvar⟩ = var†⟨#cpptype⟩(†⟨GetContext(#env)⟩, †⟨Text-QuoteEscape(Show(#var))⟩);⟨
      #cont(IncCounter(AddVar(#env, #var, Bound(#cppvar, SOME(#csort)))))⟩⟧

  // Fresh variable, reuse binder
  rule CppFreshesVariable(#env, SOME(canno⟦ @Reuse( ##METAVAR, ##NUMBER ) ⟧), NONE, #var, csortanno?⟦ : ##csort ⟧, TRUE, #cont)
  →  #cont(AddVar(#env, #var, Fresh(GetMetaArgsAt(#env, #METAVAR, ToInteger(#NUMBER)), SOME(#csort))))

  // New bound variable, reuse binder
  rule CppFreshesVariable(#env, SOME(canno⟦ @Reuse( ##METAVAR, ##NUMBER ) ⟧), NONE, #var, csortanno?⟦ : ##csort ⟧, FALSE, #cont)
  →  #cont(AddVar(#env, #var, Bound(text⟦dummy⟧, SOME(#csort))))

 // Variable already exists
 rule CppFreshesVariable(#env, #canno, SOME(#), #var, #csortanno?, #fresh, #cont)
  → #cont(#env)

// ---- Generate term code - Produces statements and return expression

func CppExprTerm({String : EnvEntry}, Core_cterm_sort, ({String : EnvEntry} Text4_text_sort)->Text4_text_sort) -> Text4_text_sort

 rule CppExprTerm(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #cont)
 → CppExprConstruction(#env, #canno*, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #cont)

 rule CppExprTerm(#env, cterm⟦ ##canno* ##cliteral ⟧, #cont)
 → #cont(#env, text⟦†⟨CppExprLiteral(#cliteral)⟩⟧)

 rule CppExprTerm(#env, cterm⟦ ##canno* ##VARIABLE ##csortanno? ⟧, #cont)
 → CppExprMaybeVar(#env, #canno*, MaybeGetVar(#env, #VARIABLE), #VARIABLE, #cont)

 rule CppExprTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #cont)
 → CppExprMeta(#env, #canno*, #METAVAR, #cterms?, #csubst?, #cont)

 rule CppExprTerm(#env, cterm⟦ ##canno* [ x ##csortanno? ] ##cterm[x] ⟧, #cont)
 → CppExprBoundVar(#env, GetAnnotation("Reuse", #canno*), #csortanno?, [x]->#cterm[x], #cont)

 rule CppExprTerm(#env, cterm⟦ ##canno* ( f ##csortanno? ) ##cterm[f] ⟧, #cont)
 → CppExprLambda(HasAnnotation("NoLambda", #canno*), #env, cterm⟦ ##canno* ( f ##csortanno? ) ##cterm[f] ⟧, #cont)

// TODO: reuse thunk
 rule CppExprTerm(#env, cterm⟦ ##canno* thunk ##cterm ⟧, #cont)
 → CppExprLambdaNew(#env, #cterm, 0, (env lambda)->
   #cont(env, text⟦thunk†⟨CppLambdaTypeArgs(#cterm)⟩(†⟨lambda⟩)⟧))

 rule CppExprTerm(#env, cterm⟦ ##canno* let ##METAVAR ##csortanno? = ##cterm ##cterm2 ⟧, #cont)
 → Error("Error: Let expression cannot occur within another expression: it must be a the top-level expression.")

/* */
func CppExprMayInline(Bool, {String : EnvEntry}, Text4_text_sort, ({String : EnvEntry} Text4_text_sort)->Text4_text_sort) -> Text4_text_sort

  rule CppExprMayInline(TRUE, #env, #expr, #cont)
  → #cont(#env, #expr)

  rule CppExprMayInline(FALSE, #env, #expr, #cont)
  → text⟦¶auto& ⟨STRING: Show(var:String)⟩ = †⟨#expr⟩;†⟨#cont(#env, text⟦⟨STRING: var⟩⟧)⟩⟧


// ---- construction expression

func CppExprConstruction({String : EnvEntry}, List<Core_canno_sort>, String,  List<Core_csortargs_sort>, List<Core_cterms_sort>, List<Core_csortanno_sort>,
                         ({String : EnvEntry} Text4_text_sort)->Text4_text_sort) -> Text4_text_sort

// TODO: type arguments are only needed when the return type is a type variable. The rest should be deducable.
 rule CppExprConstruction(#env, #canno*, #constructor, #csortargs?, #cterms?, #csortanno?, #cont)
 → let #inline = IsInline(#env)
   CppExprMaybeTerms(#env, #cterms?, (env args)->
   CppExprMayInline(#inline, env, text⟦†⟨CppConsMethodName(#constructor, HasAnnotation("Data", #canno*))⟩†⟨CppMaybeTypeArgs(#csortargs?)⟩(ctx†⟨args⟩)⟧, #cont))

func CppExprMaybeTerms({String : EnvEntry}, List<Core_cterms_sort>, ({String : EnvEntry} Text4_text_sort)->Text4_text_sort) -> Text4_text_sort
rule CppExprMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧, #cont) → CppExprTerms(UnsetInline(#env), #cterm*, #cont)
rule CppExprMaybeTerms(#env, #cterms?              , #cont) → #cont(#env, text⟦⟧)

func CppExprTerms({String : EnvEntry}, List<Core_cterm_sort>, ({String : EnvEntry} Text4_text_sort)->Text4_text_sort) -> Text4_text_sort

  rule CppExprTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, #cont)
  → CppExprTerm(#env, #cterm, (env cterm)->
    CppExprTerms(env, #cterm*, (env cterms)->
    #cont(env, text⟦, †⟨cterm⟩†⟨cterms⟩⟧)))

    rule CppExprTerms(#env, cterm*⟦⟧, #cont)
    → #cont(#env, text⟦⟧)

// --- Variable

func CppExprMaybeVar({String : EnvEntry}, List<Core_canno_sort>, Option<VarEntry>, String, ({String : EnvEntry} Text4_text_sort)->Text4_text_sort) -> Text4_text_sort

 rule CppExprMaybeVar(#env, #canno*, SOME(Formal(#var, #type)), #svar, #cont)
 → if HasAnnotation("Keep", #canno*)
     CppExprMayInline(IsInline(#env), #env, text⟦tosca::NewRef(†⟨#var⟩)⟧, #cont)
   else
     #cont(#env, #var)

 // fallback
 rule CppExprMaybeVar(#env, #canno*, SOME(#varEntry), #svar, #cont)
 → #cont(#env, text⟦†⟨UnVarVar(#varEntry)⟩.Use()⟧)

/*func CppExprRefVar(#env: {String : EnvEntry}, #canno*: List<Core_canno_sort>, #var: Text4_text_sort,
                   #cont: ({String : EnvEntry} Text4_text_sort)->Text4_text_sort) -> Text4_text_sort
 → if HasAnnotation("Keep", #canno*)
     text⟦¶auto& ⟨STRING: var:String⟩ = tosca::NewRef(†⟨#var⟩);†⟨#cont(#env, text⟦⟨STRING: var⟩⟧)⟩⟧
   else
     #cont(#env, #var)*/

// ----  metavar expression

func CppExprMeta({String : EnvEntry}, List<Core_canno_sort>, String, List<Core_cterms_sort>, List<Core_csubst_sort>, ({String : EnvEntry} Text4_text_sort)->Text4_text_sort) -> Text4_text_sort

 // No arguments -> just return the metavariable.
 rule CppExprMeta(#env, #canno*, #metavar, cterms?⟦⟧, csubst?⟦⟧, #cont)
 → CppExprRefMeta(#env, #canno*, #metavar, text⟦⟧, #cont)

 // No arguments in parenthesis -> call lambda with no param.
 rule CppExprMeta(#env, #canno*, #metavar, cterms?⟦ () ⟧, csubst?⟦⟧, #cont)
 → CppExprRefMeta(#env, #canno*, #metavar, text⟦.Eval(ctx)⟧, #cont)

 // Apply arguments -> call lambda
 rule CppExprMeta(#env, #canno*, #metavar, cterms?⟦ ( ##cterm* ) ⟧, csubst?⟦⟧, #cont)
 → CppExprTerms(UnsetInline(#env), #cterm*, (env terms)->
   CppExprRefMeta(env, #canno*, #metavar, text⟦.Eval(ctx†⟨terms⟩)⟧, #cont))

 // Maybe Substitution
 rule CppExprMeta(#env, #canno*, #metavar, cterms?⟦⟧, csubst?⟦ [ ##cterm* ] ⟧, #cont)
 → if HasAnnotation("NoSubst", #canno*)
     CppExprRefMeta(#env, #canno*, #metavar, text⟦⟧, #cont) // No need to substitute.
   else
     CppExprMetaSubst(#env, #metavar, #cterm*, #cont)

// Meta-application with Substitution
func CppExprMetaSubst(#env: {String : EnvEntry}, #metavar: String, #cterm*: List<Core_cterm_sort>, #cont: ({String : EnvEntry} Text4_text_sort)->Text4_text_sort) -> Text4_text_sort
→ CppExprMetaArgs(#env, #cterm*, text⟦⟧, (env terms)->
  text⟦¶auto& ⟨STRING: var:String⟩ = Subst(ctx, †⟨GetMetaVar(#env, #metavar)⟩, { †⟨TextMapFold((b)->text⟦&†⟨b⟩⟧, GetMetaArgs(#env, #metavar), text⟦, ⟧)⟩ }, { †⟨terms⟩ });†⟨
    #cont(env, text⟦⟨STRING: var⟩⟧)⟩⟧)

func CppExprMetaArgs({String : EnvEntry}, List<Core_cterm_sort> /* contraction args */, Text4_text_sort, ({String : EnvEntry} Text4_text_sort)->Text4_text_sort) -> Text4_text_sort

 rule CppExprMetaArgs(#env, (#arg, #args...), #sep, #cont)
 → CppExprTerm(#env, #arg, (env arg)->
   CppExprMetaArgs(env, #args, text⟦, ⟧, (env args)->
   #cont(env, text⟦†⟨#sep⟩&†⟨arg⟩†⟨args⟩⟧)))

  rule CppExprMetaArgs(#env, (), #sep, #cont)
  → #cont(#env, text⟦⟧)

// Helper generating code adding a new term reference when @Keep is present.
func CppExprRefMeta(#env: {String: EnvEntry}, #canno*: List<Core_canno_sort>, #metavar: String,
                    #suffix: Text4_text_sort,
                    #cont: ({String : EnvEntry} Text4_text_sort)->Text4_text_sort) -> Text4_text_sort
→ if HasAnnotation("Keep", #canno*)
    text⟦¶auto& ⟨STRING: var:String⟩ = tosca::NewRef(†⟨GetMetaVar(#env, #metavar)⟩)†⟨#suffix⟩;†⟨
         #cont(#env, text⟦⟨STRING: var⟩⟧)⟩⟧
  else
    #cont(#env, text⟦†⟨GetMetaVar(#env, #metavar)⟩†⟨#suffix⟩⟧)

// ---- bound variable

func CppExprBoundVar({String : EnvEntry}, Option<Core_canno_sort>, List<Core_csortanno_sort>, [String]->Core_cterm_sort,
                       ({String : EnvEntry} Text4_text_sort)->Text4_text_sort) -> Text4_text_sort

  // Binder is not reused. Create a new one then.
  rule CppExprBoundVar(#env, NONE, #csortanno?, [x]->#cterm[x], #cont)
  → let #counter = NumberToText(GetCounter(#env))
    let #boundvar = text⟦bound†⟨#counter⟩⟧
    CppExprTerm(AddVar(IncCounter(#env), var, Bound(#boundvar, MaybeSortAnnoToSort(#csortanno?))), #cterm[var], (env term)->
    #cont(env, text⟦†⟨#boundvar⟩, †⟨term⟩⟧))

  // Binder is reused.
  rule CppExprBoundVar(#env, SOME(canno⟦ @Reuse( ##METAVAR, ##NUMBER ) ⟧), #csortanno?, [x]->#cterm[x], #cont)
  → let #reusecppvar = GetMetaArgsAt(#env, #METAVAR, ToInteger(#NUMBER))
    CppExprTerm(AddVar(#env, var, Bound(#reusecppvar, MaybeSortAnnoToSort(#csortanno?))), #cterm[var], (env term)->
    #cont(env, text⟦†⟨#reusecppvar⟩, †⟨term⟩⟧))

// ---- lambda expression

func CppExprLambda(Bool /* Reuse? */, {String : EnvEntry}, Core_cterm_sort, ({String : EnvEntry} Text4_text_sort)->Text4_text_sort) -> Text4_text_sort

  // Can be reuse: skip the formal arguments
  rule CppExprLambda(TRUE, #env, #cterm, #cont)
  → CppExprLambdaReuse(#env, StripBinders(#cterm), #cont)

  // Can't reuse it, so create...
  rule CppExprLambda(FALSE, #env, #cterm, #cont)
  → CppExprLambdaNew(#env, #cterm, 0, (env lambda)->
    #cont(env, text⟦closure†⟨CppLambdaTypeArgs(#cterm)⟩(†⟨lambda⟩)⟧))

func CppExprLambdaNew({String : EnvEntry}, Core_cterm_sort, Numeric, ({String : EnvEntry} Text4_text_sort)->Text4_text_sort) -> Text4_text_sort

 rule CppExprLambdaNew(#env, cterm⟦ ##canno* ( f ##csortanno? ) ##cterm[f] ⟧, #arity, #cont)
 → CppExprLambdaNew(AddVar(#env, var, Formal(text⟦⟨STRING: var⟩⟧, MaybeSortAnnoToSort(#csortanno?))), #cterm[var], Plus(#arity, 1), #cont)

 rule CppExprLambdaNew(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #arity, #cont)
 → CppExprTerms(#env, SubList(MaybeTermsToTerms(#cterms?), #arity), (env terms)->
   #cont(env, text⟦&†⟨CppConsMethodName(#CONSTRUCTOR, HasAnnotation("Data", #canno*))⟩†⟨terms⟩⟧))

  rule CppExprLambdaNew(#env, #cterm, #arity, #cont)
  → Error("Internal Error: Invalid lambda expression. Lambda must be of the form (x .. y) -> C(x .. y, #1 .. #n)")

// Generate closure function type arguments. Not needed if the called function is not parameterized, C++ is capable of deducing types.
func CppLambdaTypeArgs(Core_cterm_sort) -> Text4_text_sort

  rule CppLambdaTypeArgs(cterm⟦ ##canno* ( f ##csortanno? ) ##cterm[f] ⟧)
  → CppLambdaTypeArgs(#cterm[dummy])

  // Generate type arguments.
  rule CppLambdaTypeArgs(cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs ##cterms? : ##csort ⟧)
  → text⟦<†⟨TextFold((CppType(#csort), CppGetSortsMaybeTerms(#cterms?)...), text⟦, ⟧)⟩>⟧

  // No type arguments
  rule CppLambdaTypeArgs(cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##cterms? ##csortanno? ⟧)
  → text⟦⟧

  // No type arguments
  rule CppLambdaTypeArgs(cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧)
  → text⟦⟧

  rule CppLambdaTypeArgs(#cterm)
  → Error("Internal Error: Invalid lambda expression. Lambda must be of the form (x .. y) -> C(x .. y, #1 .. #n)")

func CppExprLambdaReuse({String : EnvEntry}, Core_cterm_sort, ({String : EnvEntry} Text4_text_sort)->Text4_text_sort) -> Text4_text_sort

  // Lambda can be reuse. Must be a metavar
  rule CppExprLambdaReuse(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #cont)
  → CppExprMeta(#env, #canno*, #METAVAR, cterms?⟦⟧, csubst?⟦⟧, #cont)

  rule CppExprLambdaReuse(#env, #cterm, #cont)
  → Error("Internal Error: Cannot reuse a lambda expression that is not bound to a metavariable.")

func CppFindCptrMeta(#pairs:  List<PPair<List<Core_canno_sort> String>>, #METAVAR: String) -> PPair<List<Core_canno_sort> String>
→ UnSOME(PickFirst(#pairs, (annovar)->Equal(Snd(annovar), #METAVAR)))

// --- Literal

func CppExprLiteral(Core_cliteral_sort) -> Text4_text_sort
rule CppExprLiteral(cliteral⟦ ##STRING ⟧) → text⟦newStringTerm(†⟨Text-QuoteEscape(#STRING)⟩)⟧
rule CppExprLiteral(cliteral⟦ ##NUMBER ⟧) → text⟦newDoubleTerm(⟨STRING: #NUMBER⟩)⟧

// --- Sort translation functions

/* Generate template prefix for given sort variables */
func CppTemplatePrefix(List<Core_csortvars_sort>) -> Text4_text_sort

  rule CppTemplatePrefix(csortvars?⟦⟧) → text⟦⟧

  rule CppTemplatePrefix(csortvars?⟦ ∀ ##VARIABLE+ . ⟧)
  → text⟦¶template <†⟨CppTypeParameters(#VARIABLE+)⟩>⟧

/* Generate comma-seperated list of type parameters */
func CppTypeParameters(#vars: List<String>) -> Text4_text_sort
→ TextFold(Map((var) -> text⟦typename ⟨STRING: var⟩⟧, #vars), text⟦, ⟧)

/* Generate comma-separated list of type arguments from sort variables, if any*/
func MaybeCppTypeArguments(List<Core_csortvars_sort>) -> Text4_text_sort
rule MaybeCppTypeArguments(csortvars?⟦⟧) → text⟦⟧
rule MaybeCppTypeArguments(csortvars?⟦ ∀ ##VARIABLE+ . ⟧) → text⟦<†⟨CppTypeArguments(#VARIABLE+)⟩>⟧

/* Generate comma-separated list of type arguments from sort variables */
func CppTypeArguments(#vars: List<String>) -> Text4_text_sort
→ TextFold(Map<String Text4_text_sort>((var) -> text⟦⟨STRING: var⟩⟧, #vars), text⟦, ⟧)

/* Generate (possibility dependent) type name corresponding to the given data sort type */
func CppTypeName(List<Core_csortvars_sort>, String) -> Text4_text_sort

  rule CppTypeName(csortvars?⟦⟧, #sortname)
  → SortNameToCppClassName(#sortname)

  //TODO: might need typename when occurs within a template class.
  rule CppTypeName(csortvars?⟦ ∀ ##VARIABLE+ . ⟧, #sortname)
  → text⟦†⟨SortNameToCppClassName(#sortname)⟩<†⟨CppTypeArguments(#VARIABLE+)⟩>⟧

/* Generate (possibility dependent) type name corresponding to the given data sort type */
func CppTypeRefName(#csortvars?: List<Core_csortvars_sort>, #sortname:String) -> Text4_text_sort
→ text⟦†⟨CppTypeName(#csortvars?, #sortname)⟩&⟧

/* Generate arguments for template instantiation */
func MaybeCppTemplateArgs(List<Core_csorts_sort>) -> Text4_text_sort

    rule MaybeCppTemplateArgs(csorts?⟦ ⟧)
    → text⟦⟧

    rule MaybeCppTemplateArgs(csorts?⟦ ( ##csort* )⟧)
    → text⟦<†⟨TextFold(Map((csort) -> CppType(csort), #csort*), text⟦, ⟧)⟩>⟧

/* Convert list of sorts to a list of formal parameters or arguments. */
func MaybeCppFormalParams(List<Core_csorts_sort>, Text4_text_sort, Bool /* omit types */) -> Text4_text_sort

  rule MaybeCppFormalParams(csorts?⟦⟧, #sep, #isarg)
  → text⟦⟧

  rule MaybeCppFormalParams(csorts?⟦ ( ##csort*) ⟧, #sep, #isarg)
  → CppFormalParams(#csort*, 1, #sep, #isarg)

func CppFormalParams(List<Core_csort_sort>, Numeric, Text4_text_sort, Bool) -> Text4_text_sort

  rule CppFormalParams(csort*⟦⟧, #index, #sep, #isarg)
  → text⟦⟧

  rule CppFormalParams(csort*⟦ ##csort ##csort* ⟧, #index, #sep, #isarg)
  → text⟦†⟨#sep⟩†⟨CppFormalParam(CppTypes(#csort), #index, 1, #isarg)⟩†⟨CppFormalParams(#csort*, Plus(#index, 1), text⟦, ⟧, #isarg)⟩⟧

func CppFormalParam(List<Text4_text_sort>, Numeric, Numeric, Bool) -> Text4_text_sort

  rule CppFormalParam(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex, #isarg)
  → text⟦†⟨If(#isarg, ()->text⟦⟧, ()->text⟦†⟨#type⟩& ⟧)⟩†⟨ParamName(#index)⟩⟧

  rule CppFormalParam(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex, #isarg)
  → text⟦†⟨If(#isarg, ()->text⟦⟧, ()->text⟦†⟨#type⟩& ⟧)⟩†⟨VarParamName(#index, #subindex)⟩, †⟨CppFormalParam(#types, #index, Plus(#subindex, 1), #isarg)⟩⟧

func ParamName(#index: Numeric) -> Text4_text_sort
→ text⟦param†⟨NumberToText(#index)⟩⟧

func VarParamName(#index: Numeric, #subindex: Numeric) -> Text4_text_sort
→ text⟦param†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩⟧

/* Translate TS sort to equivalent list of C++ types:
 * A list of types corresponding to syntactic variable sorts and a type for the last sort
 * Note: return a type, not a type reference
 */
func CppTypes(#csort: Core_csort_sort) -> List<Text4_text_sort>
→ CppTypes2(#csort, ())

func CppTypes2(Core_csort_sort, List<Text4_text_sort> /* formal params */) -> List<Text4_text_sort>

  rule CppTypes2(csort⟦ ##canno* ##CONSTRUCTOR ##csorts? ⟧, ())
  → (text⟦†⟨SortNameToCppClassName(CppFixupPrimitiveType(#CONSTRUCTOR))⟩†⟨MaybeCppTemplateArgs(#csorts?)⟩⟧,)

  rule CppTypes2(csort⟦ ##canno* ##CONSTRUCTOR ##csorts? ⟧, (#formal, #formals...))
  → (text⟦Closure†⟨NumberToText(Plus(ListLength<Text4_text_sort>(#formals), 1))⟩<†⟨
       SortNameToCppClassName(CppFixupPrimitiveType(#CONSTRUCTOR))⟩†⟨MaybeCppTemplateArgs(#csorts?) /* Return type */⟩, †⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* Formal params */⟩>⟧,)

  rule CppTypes2(csort⟦ ##canno* ##VARIABLE ⟧, ())
  → (text⟦⟨STRING: #VARIABLE⟩⟧,)

  rule CppTypes2(csort⟦ ##canno* ##VARIABLE ⟧, (#formal, #formals...))
  → (text⟦Closure†⟨NumberToText(Plus(ListLength(#formals), 1))⟩<⟨STRING: #VARIABLE /* Return type */⟩, †⟨
       TextFold((#formal, #formals...), text⟦, ⟧) /* Formal params */⟩>⟧,)

  rule CppTypes2(csort⟦ ##canno* [ ##csort ] ##csort2 ⟧, #formals)
  → Cons(text⟦C†⟨CppType(#csort)⟩Var⟧, CppTypes2(#csort2, #formals)) // TODO: Var must be printed before template args.

  rule CppTypes2(csort⟦ ##canno* ( ##csort ) ##csort2 ⟧, #formals) // no higher-order csort for now.
  → CppTypes2(#csort2, Append(CppType(#csort), #formals))

  rule CppTypes2(csort⟦ ##canno* { ##csort1 : ##csort2 } ⟧, ())
  → Cons(text⟦MapTerm<†⟨CppType(#csort1)⟩,†⟨CppType(#csort2)⟩>⟧, Nil)

  rule CppTypes2(csort⟦ ##canno* { ##cmapsort } ⟧, Cons(#formal:Text4_text_sort, #formals:List<Text4_text_sort>))
  → Cons(text⟦Closure†⟨NumberToText(Plus(ListLength(#formals), 1))⟩<MapTerm, †⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* Formal params */⟩>⟧, Nil)

  rule CppTypes2(csort⟦ ##canno* data ##csort ⟧, #formals)
  → CppTypes2(#csort, #formals)

  rule CppTypes2(csort⟦ ##canno* thunk ##csort ⟧, #formals)
  → Cons(text⟦Closure0<†⟨CppType(#csort)⟩>⟧, Nil)

/* Same as above, expect ignore syntactic variables */
func CppType(#csort: Core_csort_sort) -> Text4_text_sort
→ Last(CppTypes(#csort)) // TODO: could optimize

/* Same as above, but return a reference type */
func CppTypeRef(#csort: Core_csort_sort) -> Text4_text_sort
→ text⟦†⟨CppType(#csort)⟩&⟧

/* Same as above, expect maybe get a sort. Generate auto& when no type. */
func MaybeCppType(#csort?: Option<Core_csort_sort>) -> Text4_text_sort
→ IfPresent(Maybe((csort)->CppType(csort), #csort?), (type) -> type, () -> text⟦auto&⟧)

/* Same as above, expect with default value */
func MaybeCppTypeD(Option<Core_csort_sort>, Text4_text_sort) -> Text4_text_sort
rule MaybeCppTypeD(NONE        , #default) → #default
rule MaybeCppTypeD(SOME(#csort), #default) → CppType(#csort) // TODO: could optimize

/* Rename builtin types to avoid conflict with C++ types */
func CppFixupPrimitiveType(#typename: String) -> String
→ If(StringEqual(#typename, "String"), ()->"StringTerm",
    ()->If(StringEqual(#typename, "Numeric"), ()->"DoubleTerm",
    ()->If(StringEqual(#typename, "Appendable"), ()->"StringTerm",
    ()->#typename)))

func CppMaybeTypeArgs(List<Core_csortargs_sort>) -> Text4_text_sort
rule CppMaybeTypeArgs(csortargs?⟦              ⟧) → text⟦⟧
rule CppMaybeTypeArgs(csortargs?⟦ < ##csort* > ⟧) → text⟦<†⟨TextFold(Map((csort)->CppType(csort), #csort*), text⟦, ⟧)⟩>⟧

/* Extract sorts from the given optional list of arguments */
func CppGetSortsMaybeTerms(List<Core_cterms_sort>) -> List<Text4_text_sort>
rule CppGetSortsMaybeTerms(cterms?⟦ ( ##cterm* ) ⟧ ) → CppGetSortsTerms(#cterm*)
rule CppGetSortsMaybeTerms(#cterms?               ) → ()

func CppGetSortsTerms(#terms: List<Core_cterm_sort>) -> List<Text4_text_sort>
→ Map((term) -> IfPresent(TermSort(term), (sort)->CppType(sort), ()->Error("Internal Error: missing sort.")), #terms)

// --- Basic conversion functions

/* Convert data sort name to corresponding C++ class name */
func SortNameToCppClassName(#name: String) -> Text4_text_sort
→ If(Equal(#name, "STRING"), ()->text⟦ESTRING⟧, ()->text⟦⟨STRING: Mangle(#name)⟩⟧)

/* Convert data sort name to equivalent C++ class name reference */
func SortNameToCppClassNameRef(#name: String) -> Text4_text_sort
→ text⟦†⟨SortNameToCppClassName(#name)⟩&⟧

/* Convert the given contructor (function or data) to corresponding C++ method name */
func CppConsMethodName(#name: String, #isdata: Bool) -> Text4_text_sort
→ text⟦†⟨TextIf(#isdata, ()->text⟦new⟧)⟩⟨STRING: Mangle(#name)⟩⟧

/* Convert data form to corresponding C++ constructor method name */
func CppNewMethodName(#name: String) -> Text4_text_sort
→ text⟦new⟨STRING: Mangle(#name)⟩⟧

/* Convert data form to corresponding C++ 'as' method name */
func CppAsMethodName(#name: String) -> Text4_text_sort
→ text⟦as⟨STRING: Mangle(#name)⟩⟧

/* Convert parameterized data form to corresponding C++ class name */
func ParamFormCppClassName(#name: String, #csortvars?: List<Core_csortvars_sort>, #kind: CppFormClassKind) -> Text4_text_sort
→ text⟦†⟨FormCppClassName(#name)⟩†⟨CppFormClassSuffix(#kind)⟩†⟨MaybeCppTypeArguments(#csortvars?)⟩⟧

/* Convert data form to corresponding C++ class name */
func FormCppClassName(#name: String) -> Text4_text_sort
→ If(Equal(#name, "STRING"), ()->text⟦CSTRING⟧, ()->text⟦C⟨STRING: Mangle(#name)⟩⟧)

/* Convert data form to corresponding C++ class name reference */
func FormCppClassNameRef(#name: String) -> Text4_text_sort
→ text⟦†⟨FormCppClassName(#name)⟩&⟧

/* Convert TS function name to corresponding C++ function name  */
func CppFnName(#name: String) -> Text4_text_sort
→ text⟦⟨STRING: Mangle(#name)⟩⟧

/* Print form class suffix based of the given `#kind` */
func CppFormClassSuffix(CppFormClassKind) -> Text4_text_sort
rule CppFormClassSuffix(CFC_CONS)   → text⟦⟧
rule CppFormClassSuffix(CFC_VAR)    → text⟦Var⟧
rule CppFormClassSuffix(CFC_VARUSE) → text⟦Use⟧

// --- helper function

/* Whether to generate function body */
func GenBody(#csortvars? : List<Core_csortvars_sort>, #header : Bool, #forward: Bool) -> Bool
→ And(
    Not(#forward),
    Or(
      And(IsEmpty   (#csortvars?), Not(#header)),
      And(IsNotEmpty(#csortvars?), #header)))

/* Generate method qualifier, only for definitions */
func CppQualifier(#sortname: String, #csortvars? : List<Core_csortvars_sort>, #def : Bool) -> Text4_text_sort
→ TextIf(#def, ()->text⟦†⟨CppTypeName(#csortvars?, #sortname)⟩::⟧)

/* Generate form class qualifier, only for definitions */
func CppFormQualifier(#formname: String, #csortvars? : List<Core_csortvars_sort>, #kind: CppFormClassKind, #def : Bool) -> Text4_text_sort
→ TextIf(#def, ()->text⟦†⟨ParamFormCppClassName(#formname, #csortvars?, #kind)⟩::⟧)
