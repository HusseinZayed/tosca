// Copyright (c) 2`018 IBM Corporation.
/*
 * CRSX Java backend code generator
 *
 * Generate Java 8 source code from core Crsx.
 *
 * Only one Java file is created from a Crsx system. This will have to change in order to scale.
 */

import Core::Core
import Std::Core
import Std::String
import Std::Num
import Std::Text
import Std::List
import Std::Pair
import Std::Map
import Text::Text4
import Std::Language
import System

// ===== API

/*
 * Generates Java code from a sorted core Crsx system
 * @param System The crsx system
 */
func CrsxToJava(System) -> Text
rule CrsxToJava(System(#url, #modules))
→ JavaUnits(#url, MapValues(#modules))

// --- Generate code.
/*
 Each Crsx module corresponds to a single Java class.

 Each rule declaration corresponds to a single Java function.
*/

func JavaUnits(String, List<Module>) -> Text
rule JavaUnits(#url, #modules)
  → text⟦
/** Generated File */
⟨PackageDeclaration⟩

import java.util.function.Function;
import java.util.Map;
import org.transscript.runtime.Context;
import org.transscript.runtime.Ref;
import org.transscript.runtime.MemoFunction;

⟨TextFold(Map([x] -> JavaUnit(#url, x), #modules), text⟦⟧)⟩
⟧

/* Generate class for the given module */
func JavaUnit(String, eager Module) -> Text
rule JavaUnit(#mainurl, Module(#url, Loaded(LoadedContent(#imports, #rules, #datasorts, #funcsorts))))
→ text⟦
⟨TextFold(Map([x] -> JavaImport(x), #imports), text⟦⟧)⟩

@SuppressWarnings("unused")
⟨JavaClassVisibility(#mainurl, #url)⟩ class †⟨ClassName(#url)⟩ {

  /* Typed enumerations */
  ⟨TextFold( Map([x] ->EnumToClass(x), MapValues(#datasorts)), text⟦⟧)⟩
  ⟨TextFold( Map([x] ->JavaMethod(x, #rules, #datasorts, #funcsorts), MapKeys(#rules)), text⟦⟧)⟩
  ⟨InitModule(#datasorts, #funcsorts, #imports)⟩
}⟧

func JavaImport(String) -> Text
rule JavaImport(#name)
→ text⟦
import static ⟨PathToImport(#name)⟩.*;⟧

func JavaClassVisibility(String, String) -> Text
rule JavaClassVisibility(#mainurl, #url)
→ If(Equal(#mainurl, #url), text⟦public⟧, text⟦static⟧)

//--- Translate enumerations

/** Generate enumeration descriptors */
func EnumToDataDesc(Core_cdecl_sort) -> Text
rule EnumToDataDesc(cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧)
→ TextFold(Map([x] -> EnumFormToDesc(#CONSTRUCTOR, x), #cform*), text⟦⟧)

func EnumFormToDesc(String, Core_cform_sort) -> Text
rule EnumFormToDesc(#sortname, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
→ text⟦
final public static ConstructionDescriptor ⟨Descriptor(#CONSTRUCTOR)⟩ = makeData(⟨Text-QuoteEscape(#CONSTRUCTOR)⟩, ⟨NumberToText(MaybeSortsCount(#csorts?))⟩, ⟨EnumToClassRef(#sortname, #CONSTRUCTOR)⟩);⟧

func EnumToClassRef(String, String) -> Text
rule EnumToClassRef(#sortname, #formname) → text⟦⟨ToJavaClassName(#sortname)⟩.⟨ToJavaClassName(#formname)⟩.class⟧

/* Generate interfaces corresponding to the enum type */
func EnumToClass(Core_cdecl_sort) -> Text
rule EnumToClass(cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧)
→ text⟦

⟨TextFold(Map([x] -> FormToMethodNew(#CONSTRUCTOR, #csortvars?, x), #cform*), text⟦⟧)⟩

static ⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ new⟨ToJavaClassName(#CONSTRUCTOR)⟩Memo(Function<Context, ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, false)⟩> function)
{
  return new ⟨ToJavaClassName(#CONSTRUCTOR)⟩Memo(function);
}

public interface ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ extends Ref
{
  ⟨TextFold(Map([x] -> FormToMethodAs(#CONSTRUCTOR, #csortvars?, x), #cform*), text⟦⟧)⟩

  default ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ force(Context c)
  {
    return eval(c);
  }

  default ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ eval(Context context)
  {
    return Ref.ref(this);
  }

}

⟨TextFold(Map([x] -> FormToInterfaceValue(#CONSTRUCTOR, #csortvars?, x), #cform*), text⟦⟧)⟩
⟨TextFold(Map([x] -> FormToImplValue(#CONSTRUCTOR, #csortvars?, x), #cform*), text⟦⟧)⟩

static class ⟨ToJavaClassName(#CONSTRUCTOR)⟩Memo⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ extends MemoFunction<⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩>implements ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩
{

  public ⟨ToJavaClassName(#CONSTRUCTOR)⟩Memo(Function<Context, ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩> function)
	{
		super(function);
	}

  ⟨TextFold(Map([x] -> FormToMethodMemoAs(#CONSTRUCTOR, #csortvars?, x), #cform*), text⟦⟧)⟩


  @Override
	public ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ eval(Context c)
	{
		return Ref.ref(apply(c));
	}

}

⟧

/*public abstract <R> R match(⟨TextFold(Map([x] -> FormToParam(x), #cform*), text⟦, ⟧)⟩);*/

/* Generate a 'new' static method for each enum value */
// TODO: optimize constant value.
func FormToMethodNew(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text
rule FormToMethodNew(#constructor, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
→ text⟦
    static ⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ ⟨ToJavaClassName(#constructor)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ ⟨ToJavaMethodName(ConcatString("new", #CONSTRUCTOR))⟩ (⟨MaybeSortsToFormalParams(#csorts?)⟩)
    {
      return new ⟨ToJavaClassName(#CONSTRUCTOR)⟩Impl⟨SortParamToTypeParam(#csortvars?, FALSE)⟩(⟨MaybeSortsToArgs(#csorts?)⟩);
    }⟧

// --- Generate a 'as' method for each enum value

func FormToMethodAs(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text
rule FormToMethodAs(#enumname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
→ text⟦
    default ⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ ⟨MethodNameAs(#CONSTRUCTOR)⟩(Context context)
    {
      return null;
    }⟧

func FormToMethodMemoAs(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text
rule FormToMethodMemoAs(#enumname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
→ text⟦
   @Override
   final public ⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ ⟨MethodNameAs(#CONSTRUCTOR)⟩(Context context)
   {
     return apply(context).⟨MethodNameAs(#CONSTRUCTOR)⟩(context);
   }⟧

func MethodNameAs(String) -> Text
rule MethodNameAs(#formCons) → ToJavaMethodName(ConcatString("as", #formCons))

// --- Generate an interface the enumeration value

func FormToInterfaceValue(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text
  rule FormToInterfaceValue(#enumtype, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
  → text⟦
      interface ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ extends ⟨ToJavaClassName(#enumtype)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩
      {
        ⟨MaybeSortsToGetValueSig(#csorts?)⟩

        @Override
        default ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ ⟨MethodNameAs(#CONSTRUCTOR)⟩(Context context)
        {
          return this;
        }
      }⟧

// --- Generate an implementation for the enumeration value

func FormToImplValue(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text
  rule FormToImplValue(#typename, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
  → text⟦
      static class ⟨ToJavaClassName(#CONSTRUCTOR)⟩Impl⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ implements ⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩
      {
          ⟨MaybeSortsToClassFields(#csorts?)⟩

          public ⟨ToJavaClassName(#CONSTRUCTOR)⟩Impl(⟨MaybeSortsToFormalParams(#csorts?)⟩)
          {
            ⟨MaybeSortsToInitFields(#csorts?)⟩
          }

          ⟨MaybeSortsToGetValue(#csorts?)⟩

      }⟧

//--- Class fields

func MaybeSortsToClassFields(List<Core_csorts_sort>) -> Text
  rule MaybeSortsToClassFields(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToClassFields(csorts?⟦ ( ##csort* ) ⟧)
  → text⟦
    /* Form arguments */
    ⟨SortsToClassFields(#csort*, 1)⟩⟧

func SortsToClassFields(List<Core_csort_sort>, Numeric) -> Text
  rule SortsToClassFields(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToClassFields(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦⟨SortToClassFields(SortToTypes(#csort), #index, 1)⟩⟨SortsToClassFields(#csort*, Plus(#index, 1))⟩⟧

func SortToClassFields(List<Text>, eager Numeric, eager Numeric) -> Text
  rule SortToClassFields(Cons(#type, Nil), #index, #subindex)
  → text⟦⟨#type⟩ field⟨FieldSuffix(#index, #subindex)⟩;⟧

  rule SortToClassFields(Cons(#type, #types), #index, #subindex)
  → text⟦
     ⟨#type⟩ var⟨NumberToText(#index)⟩_⟨NumberToText(#subindex)⟩;
     ⟨SortToClassFields(#types, #index, Plus(#subindex, 1))⟩⟧

//--- Class fields initialization

func MaybeSortsToInitFields(List<Core_csorts_sort>) -> Text
  rule MaybeSortsToInitFields(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToInitFields(csorts?⟦ ( ##csort* ) ⟧)
  → SortsToInitFields(#csort*, 1)

func SortsToInitFields(List<Core_csort_sort>, Numeric) -> Text
  rule SortsToInitFields(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToInitFields(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦⟨SortToInitFields(SortToTypes(#csort), #index, 1)⟩⟨SortsToInitFields(#csort*, Plus(#index, 1))⟩⟧

func SortToInitFields(List<Text>, eager Numeric, eager Numeric) -> Text
  rule SortToInitFields(Cons(#type, Nil), #index, #subindex)
  → text⟦this.field⟨FieldSuffix(#index, #subindex)⟩ = param⟨FieldSuffix(#index, #subindex)⟩;⟧

  rule SortToInitFields(Cons(#type, #types), #index, #subindex)
  → text⟦this.var⟨NumberToText(#index)⟩_⟨NumberToText(#subindex)⟩ = param⟨NumberToText(#index)⟩_⟨NumberToText(#subindex)⟩; ⟨SortToInitFields(#types, #index, Plus(#subindex, 1))⟩⟧

//--- Sort to formal parameters

func MaybeSortsToFormalParams(List<Core_csorts_sort>) -> Text
  rule MaybeSortsToFormalParams(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToFormalParams(csorts?⟦ ( ##csort*) ⟧)
  → SortsToFormalParams(#csort*, 1, text⟦⟧)

func SortsToFormalParams(List<Core_csort_sort>, Numeric, Text) -> Text
  rule SortsToFormalParams(csort*⟦⟧, #index, #sep)
  → text⟦⟧

  rule SortsToFormalParams(csort*⟦ ##csort ##csort* ⟧, #index, #sep)
  → text⟦⟨#sep⟩⟨SortToFormalParams(SortToTypes(#csort), #index, 1)⟩⟨SortsToFormalParams(#csort*, Plus(#index, 1), text⟦, ⟧)⟩⟧

func SortToFormalParams(List<Text>, Numeric, Numeric) -> Text
  rule SortToFormalParams(Cons(#type, Nil), #index, #subindex)
  → text⟦⟨#type⟩ param⟨FieldSuffix(#index, #subindex)⟩⟧

  rule SortToFormalParams(Cons(#type, #types), #index, #subindex)
  → text⟦⟨#type⟩ param⟨NumberToText(#index)⟩_⟨NumberToText(#subindex)⟩, ⟨SortToFormalParams(#types, #index, Plus(#subindex, 1))⟩⟧

//--- Sort to function call arguments

func MaybeSortsToArgs(List<Core_csorts_sort>) -> Text
  rule MaybeSortsToArgs(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToArgs(csorts?⟦ ( ##csort*) ⟧)
  → SortsToArgs(#csort*, 1, text⟦⟧)

func SortsToArgs(List<Core_csort_sort>, Numeric, Text) -> Text
  rule SortsToArgs(csort*⟦⟧, #index, #sep)
  → text⟦⟧

  rule SortsToArgs(csort*⟦ ##csort ##csort* ⟧, #index, #sep)
  → text⟦⟨#sep⟩⟨SortToArgs(SortToTypes(#csort), #index, 1)⟩⟨SortsToArgs(#csort*, Plus(#index, 1), text⟦, ⟧)⟩⟧

func SortToArgs(List<Text>, Numeric, Numeric) -> Text
  rule SortToArgs(Cons(#type, Nil), #index, #subindex)
  → text⟦param⟨FieldSuffix(#index, #subindex)⟩⟧

  rule SortToArgs(Cons(#type, #types), #index, #subindex)
  → text⟦param⟨NumberToText(#index)⟩_⟨NumberToText(#subindex)⟩, ⟨SortToArgs(#types, #index, Plus(#subindex, 1))⟩⟧

//--- Get value method signature

func MaybeSortsToGetValueSig(List<Core_csorts_sort>) -> Text
  rule MaybeSortsToGetValueSig(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToGetValueSig(csorts?⟦ ( ##csort* ) ⟧)
  → SortsToGetValueSig(#csort*, 1)

func SortsToGetValueSig(List<Core_csorts_sort>, eager Numeric) -> Text
  rule SortsToGetValueSig(csort*⟦⟧, #index)
  → text⟦⟧

  rule SortsToGetValueSig(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦⟨SortToGetValueSig(SortToTypes(#csort), #index, 1)⟩⟨SortsToGetValueSig(#csort*, Plus(#index, 1))⟩⟧

func SortToGetValueSig(List<Text>, eager Numeric, eager Numeric) -> Text
  rule SortToGetValueSig(Cons(#type, Nil), #index, #subindex)
  → text⟦⟨#type⟩ getField⟨FieldSuffix(#index, #subindex)⟩();⟧

  rule SortToGetValueSig(Cons(#type, #types), #index, #subindex)
  → text⟦⟨#type⟩ getVar⟨NumberToText(#index)⟩_⟨NumberToText(#subindex)⟩();
         ⟨SortToGetValueSig(#types, #index, Plus(#subindex, 1))⟩⟧

//--- Get value method implementation

func MaybeSortsToGetValue(List<Core_csorts_sort>) -> Text
  rule MaybeSortsToGetValue(csorts?⟦⟧)
  → text⟦⟧

  rule MaybeSortsToGetValue(csorts?⟦ ( ##csort* ) ⟧)
  → SortsToGetValue(#csort*, 1)

func SortsToGetValue(List<Core_csorts_sort>, eager Numeric) -> Text
  rule SortsToGetValue(csort*⟦ ⟧, #index)
  → text⟦⟧

  rule SortsToGetValue(csort*⟦ ##csort ##csort* ⟧, #index)
  → text⟦⟨SortToGetValue(SortToTypes(#csort), #index, 1)⟩⟨SortsToGetValue(#csort*, Plus(#index, 1))⟩⟧

func SortToGetValue(List<Text>, eager Numeric, eager Numeric) -> Text
  rule SortToGetValue(Cons(#type, Nil), #index, #subindex)
  → text⟦@Override
         public ⟨#type⟩ getField⟨FieldSuffix(#index, #subindex)⟩() {
            return field⟨FieldSuffix(#index, #subindex)⟩;
         };⟧

  rule SortToGetValue(Cons(#type, #types), #index, #subindex)
  → text⟦@Override
         ⟨#type⟩ getVar⟨NumberToText(#index)⟩_⟨NumberToText(#subindex)⟩() {
           return var⟨NumberToText(#index)⟩_⟨NumberToText(#subindex)⟩;
        };
        ⟨SortToGetValue(#types, #index, Plus(#subindex, 1))⟩⟧

//--- Helpers

func FieldSuffix(Numeric, Numeric) -> Text
  rule FieldSuffix(#index, #subindex)
  → text⟦⟨NumberToText(#index)⟩⟨If( NumberEqual(#subindex, 1), text⟦⟧, text⟦_⟨NumberToText(#subindex)⟩⟧ )⟩⟧


func MaybeSortsCount(List<Core_csorts_sort>) -> Numeric
  rule MaybeSortsCount(csorts?⟦⟧)             → 0
  rule MaybeSortsCount(csorts?⟦ (##csort*) ⟧) → ListLength(#csort*)

//--- Find form in sort

func FindForm(Core_cdecl_sort, String) -> Core_cform_sort
rule FindForm(cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧, #formname)
→ UnSOME(PickFirst(#cform*, [x] -> MatchConsForm(x, #formname)))

func MatchConsForm(Core_cform_sort, String) -> Boolean
  rule MatchConsForm(cform⟦ ##CONSTRUCTOR ##csorts? ⟧, #formname)
  → Equal(#CONSTRUCTOR, #formname)

  rule MatchConsForm(#, #formname)
  → FALSE

//---- Sort tranlation

func SortParamToTypeParam(List<Core_csortvars_sort>, Boolean /* parameterize or parameterization? */) -> Text
  rule SortParamToTypeParam(csortvars?⟦ ⟧, #parameterize)
  → text⟦⟧

  rule SortParamToTypeParam(csortvars?⟦ ∀ ##variable_TOK+ . ⟧, #parameterize)
  → text⟦<⟨TextFold(Map([x] -> text⟦⟨ToJavaTypeParameter(x)⟩⟧, #variable_TOK+), text⟦, ⟧)⟩⟨MaybeExtendsTerm(#parameterize)⟩>⟧

func MaybeSortsToTypeParams(List<Core_csorts_sort>) -> Text
  rule MaybeSortsToTypeParams(csorts?⟦ ⟧)
  → text⟦⟧

  rule MaybeSortsToTypeParams(csorts?⟦ ( ##csort* )⟧)
  → text⟦<⟨TextFold( Flatten(Map([x] -> SortToTypes(x), #csort*)), text⟦, ⟧)⟩>⟧

func SortToTypes(Core_csort_sort) -> List<Text>
  rule SortToTypes(csort⟦ ##CONSTRUCTOR ##csorts? ⟧)
  → Cons(text⟦⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨MaybeSortsToTypeParams(#csorts?)⟩⟧, Nil)

  rule SortToTypes(csort⟦ ##VARIABLE ⟧)
  → Cons(text⟦⟨ToJavaTypeParameter(#VARIABLE)⟩⟧, Nil)

  rule SortToTypes(csort⟦ [ ##csort ] ##csort2 ⟧)
  → Cons(text⟦Variable⟧, SortToTypes(#csort2))

  rule SortToTypes(csort⟦ data ##csort ⟧)
  → SortToTypes(#csort)

func MaybeExtendsTerm(Boolean) -> Text
rule MaybeExtendsTerm(TRUE) → text⟦ extends Term⟧
rule MaybeExtendsTerm(FALSE) → text⟦⟧

func JavaFuncDesc(String, Core_cdecl_sort) -> Text
rule JavaFuncDesc(#classname, cdecl⟦ ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧)
→ text⟦
  final public static DynamicFunctionDescriptor ⟨Descriptor(#CONSTRUCTOR)⟩ =
    makeFunction(⟨Text-QuoteEscape(#CONSTRUCTOR)⟩, †⟨#classname⟩⟨JavaExtern(#extern_TOK?)⟩.class, "⟨ToJavaId(#CONSTRUCTOR)⟩", ⟨ThunkClass(#csort)⟩, ⟨MaybeSortsToSubIndex(#csorts?)⟩);⟧

func JavaExtern(List<Core_extern_sort>) -> Text
rule JavaExtern(extern_TOK?⟦⟧) → text⟦⟧
// Something is wrong with this rule.
//rule JavaExtern(extern_TOK?⟦ extern ⟧) → text⟦Extern⟧
rule JavaExtern(( #extern )) → text⟦Extern⟧

func ThunkClass(Core_csort_sort) -> Text
rule ThunkClass(csort⟦ ##CONSTRUCTOR ##csorts? ⟧) → text⟦⟨ToJavaClassName(#CONSTRUCTOR)⟩⟨ToJavaClassName(#CONSTRUCTOR)⟩Thunk.class⟧

// --- Generate array of int correponding to sub index in a flat array mixing binders and subs */

func MaybeSortsToSubIndex(List<Core_csorts_sort>) -> Text
  rule MaybeSortsToSubIndex(csorts?⟦⟧)
  → text⟦null⟧

  rule MaybeSortsToSubIndex(csorts?⟦ ( ##csort* ) ⟧)
  → text⟦new int[] { ⟨SortsToSubIndex(#csort*, 0, text⟦⟧)⟩ }⟧

func SortsToSubIndex(List<Core_csort_sort>, Numeric, Text) -> Text
  rule SortsToSubIndex(csort*⟦⟧, #index, #sep)
  → text⟦⟧

  rule SortsToSubIndex(csort*⟦ ##csort ##csort* ⟧, #index, #sep)
  → SortToSubIndex(Plus(Minus(ListLength(SortToTypes(#csort)), 1), #index), #csort*, #sep)

func SortToSubIndex(eager Numeric, List<Core_csort_sort>, Text) -> Text
  rule SortToSubIndex(#subindex, #csort*, #sep)
  → text⟦⟨#sep⟩⟨ NumberToText( #subindex ) ⟩⟨SortsToSubIndex(#csort*, Plus(#subindex, 1), text⟦,⟧)⟩⟧

/* Generate a method per function */

func JavaMethod(String, {String : List<Core_cdecl_sort>},
           { String : Core_cdecl_sort }, { String : Core_cdecl_sort }) -> Text
rule JavaMethod(#constructor, #rules, #datasorts, #funcsorts)
→ text⟦final public static ⟨
          JavaMethodSig( SetDataSorts(SetFuncSorts(NewEnv, #funcsorts), #datasorts),
                         UnSOME(MapGet(#funcsorts, #constructor)),
                         UnSOME(MapGet(#rules, #constructor)))⟩⟧

func JavaMethodSig(eager {String : JavaEnvEntry}, Core_cdecl_sort, List<Core_cdecl_sort>) -> Text
rule JavaMethodSig(#env, cdecl⟦ ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧, #rules)
→ text⟦⟨ReturnType(#csortvars?, #csort)⟩⟨ToJavaMethodName(#CONSTRUCTOR)⟩(Context context⟨
      JavaSigMaybeArgs(SetMethodName(SetThunkType(AddThunk(#env, text⟦c⟧), ThunkType(#csortvars?, #csort)), ToJavaMethodName(#CONSTRUCTOR)), #csorts?, #rules)⟩⟧   // )

// --- Generate return type

func ReturnType(List<Core_csortvars_sort>, Core_csort_sort) -> Text
rule ReturnType(#csortvars?, #csort)
→ text⟦⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ ⟨TextFold(SortToTypes(#csort), text⟦⟧)⟩ ⟧

// --- Generate thunk type

func ThunkType(List<Core_csortvars_sort>, Core_csort_sort) -> Text
rule ThunkType(#csortvars?, #csort)
→ text⟦⟨TextFold(SortToTypes(#csort), text⟦⟧)⟩⟨SortParamToTypeParam(#csortvars?, FALSE)⟩⟧

// --- Generate method signature

func JavaSigMaybeArgs(eager {String : JavaEnvEntry}, List<Core_csorts_sort>, List<Core_cdecl_sort>) -> Text
  rule JavaSigMaybeArgs(#env, csorts?⟦⟧, #rules)
  → JavaBody(#env, #rules)

  rule JavaSigMaybeArgs(#env, csorts?⟦ ( ##csort* ) ⟧, #rules)
  → JavaSigArgs(#env, #csort*, FALSE, #rules)

// Generate method signature and record the argument names in the environment, keeping them in order
func JavaSigArgs(eager {String : JavaEnvEntry}, List<Core_csort_sort>, Boolean, List<Core_cdecl_sort>) -> Text


  rule JavaSigArgs(#env, csort*⟦ ⟧, #data, #rules)
  → JavaBody(#env, #rules)

  rule JavaSigArgs(#env, csort*⟦ ##CONSTRUCTOR ##csorts? ##csort* ⟧, #data, #rules)
  → text⟦, ⟨TextFold(SortToTypes(csort⟦ ##CONSTRUCTOR ##csorts? ⟧), text⟦⟧)⟩ ⟨value⟩⟨
      JavaSigArgs(AddThunk(AddParam(AddMaybeData(#env, #data, value), value, Core_csort_A1(#CONSTRUCTOR, #csorts?)), value), #csort*, FALSE, #rules)⟩⟧

  rule JavaSigArgs(#env, csort*⟦ ##VARIABLE ##csort* ⟧, #data, #rules) // Sort variable
  → text⟦, ⟨TextFold(SortToTypes(csort⟦ ##VARIABLE ⟧), text⟦⟧)⟩ ⟨value⟩⟨
      JavaSigArgs(AddThunk(AddParam(AddMaybeData(#env, #data, value), value, csort⟦ ##VARIABLE ⟧), value), #csort*, FALSE, #rules)⟩⟧

  //rule JavaSigArgs(#env, csort*⟦ [ ##csort ] ##csort2 ##csort* ⟧, #data, #rules)
  rule JavaSigArgs(#env, Cons(Core_csort_A3(#csort, #csort2), #csort*), #data, #rules)
  → text⟦, Variable ⟨var⟩⟨
      JavaSigArgs(AddThunk(AddParam(#env, var, #csort), var), Cons(#csort2, #csort*), #data, #rules)⟩⟧

  rule JavaSigArgs(#env, csort*⟦ { ##cmapsort* } ##csort*  ⟧, #data, #rules)
  → text⟦, Map ⟨map⟩⟨
      JavaSigArgs(AddThunk(AddParam(AddMaybeData(#env, #data, map), map, csort⟦ { ##cmapsort* } ⟧), map), #csort*, FALSE, #rules)⟩⟧

  rule JavaSigArgs(#env, csort*⟦ data ##csort ##csort* ⟧, #data, #rules)
  → JavaSigArgs(#env, Cons(#csort, #csort*), TRUE, #rules)

// --- Generate method body

func JavaBody(eager {String : JavaEnvEntry}, List<Core_cdecl_sort>) -> Text
  rule JavaBody(#env, #rules)
  → text⟦
    ) {
        if (context.sd ++ < 256) {
          ⟨TextFold(Map([x] -> JavaApplyData(GetSink(#env), x), GetData(#env)), text⟦⟧)⟩
          ⟨TextFold(Map([x] -> JavaBodyRule(#env, x), #rules), text⟦⟧)⟩
        }
        return new ⟨GetThunkType(#env)⟩Memo( c -> { return ⟨GetMethodName(#env)⟩(⟨TextFold(GetThunk(#env), text⟦, ⟧)⟩); } );
      }⟧

// Generate code to normalize arguments marked as 'data'
func JavaApplyData(Text, Text) -> Text
rule JavaApplyData(#sink, #term)
→ text⟦⟨#term⟩.eval(context).release();⟧

// --- Start method body

func JavaBodyRule(eager {String : JavaEnvEntry}, Core_cdecl_sort) -> Text
  rule JavaBodyRule(#env, cdecl⟦ rule ##CONSTRUCTOR → ##cterm2 ⟧)
  → JavaContractum(#env, #cterm2)

  rule JavaBodyRule(#env, cdecl⟦ rule ##CONSTRUCTOR ( ##cterm* ) → ##cterm2 ⟧)
  → JavaPattern(#env, #cterm*, #cterm2)

// --- Pattern matching

func JavaPattern(eager {String : JavaEnvEntry}, List<Core_cterm_sort>, Core_cterm_sort) -> Text

// TODO: case where there is only one rule.
rule JavaPattern(#env, #cterms, #contractum)
→ text⟦⟨label⟩:{⟨JavaCasePattern(SetLabel(#env, label), #cterms, #contractum)⟩
}⟧

// Data sort helper indicating whether the current term is a method parameter, or an argument (local variable).
enum Storage | PARAMETER | ARGUMENT

// Iterate over top-level pattern arguments
func JavaCasePattern(eager {String : JavaEnvEntry}, List<Core_cterm_sort>, Core_cterm_sort) -> Text

rule JavaCasePattern(#env, cterm*⟦ ⟧, #contractum)
→ JavaContractum(#env, #contractum)

rule JavaCasePattern(#env, cterm*⟦ ##cterm ##cterm* ⟧, #contractum)
→ JavaPatternTerm(NextParam(#env), #cterm, CurrentParam(#env), CurrentParamSort(#env), PARAMETER, [env] -> JavaCasePattern(env, #cterm*, #contractum))

// --- Term pattern matching

func JavaPatternTerm(eager {String : JavaEnvEntry}, Core_cterm_sort, Text /* Current term */, Core_csort_sort, Storage, [{String : JavaEnvEntry}] -> Text) -> Text

rule JavaPatternTerm(#env, cterm⟦ ##CONSTRUCTOR ##cterms? ⟧, #term, csort⟦ ##CONSTRUCTOR2 ##csorts? ⟧, #storage, [env]->#(env))
→ text⟦
⟨ToJavaClassName(#CONSTRUCTOR)⟩ ⟨value⟩ = ⟨#term⟩.force(context).⟨MethodNameAs(#CONSTRUCTOR)⟩(context);
if (⟨value⟩ == null)
{
  break ⟨GetLabel(#env)⟩;
}⟨JavaPatternMaybeSubs(#env, #cterms?, value, FindForm(UnSOME(MapGet(GetDataSorts(#env), #CONSTRUCTOR2)), #CONSTRUCTOR), [x] -> #(x))⟩⟧

// TODO:
rule JavaPatternTerm(#env, cterm⟦ ##cliteral ⟧, #term, #csort, #storage, [env]->#(env))
→ #(#env)

// REVISIT: bound variable reordering, ie. (x)(y)#(y, x)
// For now only accepts patterns of the form (x)...(y)#(x, ... y)
rule JavaPatternTerm(#env, cterm⟦ ##METAVAR ##cterms? ⟧, #term, #csort, #storage, [env]->#(env))
→ text⟦
/* ⟨Text-CommentToken(#METAVAR)⟩=⟨Text-CommentToken(Show(#term))⟩ */⟨JavaPatternMaybeMetaArgs(#env, #METAVAR, #cterms?, #term, #csort, [x] -> #(x))⟩⟧

rule JavaPatternTerm(#env, cterm⟦ ##VARIABLE ⟧, #term, #csort, #storage, [env]->#(env))
→ JavaPatternVariable(MaybeGetVar(#env, #VARIABLE), #env, #VARIABLE, #term, #csort, [env]->#(env))

rule JavaPatternTerm(#env, Core_cterm_A6([x] -> #cterm(x)), #term, #csort, PARAMETER, [env]->#(env))
//rule JavaPatternTerm(#env, cterm⟦ [ ##VARIABLE ] ##cterm ⟧, #term, PARAMETER, [env]->#(env))
→ JavaPatternTerm(NextParam(AddVar(#env, var, Bound(#term))), #cterm(var), CurrentParam(#env), CurrentParamSort(#env), PARAMETER, [env]->#(env))

rule JavaPatternTerm(#env, Core_cterm_A6([x] -> #cterm(x)), #term,  #csort, ARGUMENT, [env]->#(env))
//rule JavaPatternTerm(#env, cterm⟦ [ ##VARIABLE ] ##cterm ⟧, #term, ARGUMENT, [env]->#(env))
→ text⟦
Variable ⟨boundvar⟩ = ⟨GetParent(#env)⟩.binders(⟨GetSubIndex(#env)⟩)[⟨Text-Integer(GetSubBinderIndex(#env))⟩];⟨JavaPatternTerm(IncSubBinderIndex(AddVar(#env, var, Bound(boundvar))), #cterm(var), #term, ARGUMENT, [x]->#(x))⟩⟧

// Pattern matching on construction arguments.
func JavaPatternMaybeSubs(eager {String : JavaEnvEntry}, List<Core_cterms_sort>, Text, Core_cform_sort, [{String : JavaEnvEntry}] -> Text) -> Text

rule JavaPatternMaybeSubs(#env, cterms?⟦⟧, #term, #cform, [env]->#(env))
→ #(#env)

rule JavaPatternMaybeSubs(#env, cterms?⟦ ( ##cterm* ) ⟧, #term, cform⟦ ##CONSTRUCTOR ( ##csort* ) ⟧, [env]->#(env))
→ JavaPatternSubs(#env, #cterm*, #csort*, #term, 1, [env]->#(env))

func JavaPatternSubs(eager {String : JavaEnvEntry}, List<Core_cterm_sort>, List<Core_csort_sort>,
                     Text /* parent term */, Numeric /* Current subindex */, [{String : JavaEnvEntry}] -> Text) -> Text

rule JavaPatternSubs(#env, cterm*⟦⟧, #csort*, #term, #index, [env]->#(env))
→ #(#env)

rule JavaPatternSubs(#env, cterm*⟦ ##cterm ##cterm* ⟧, csort*⟦ ##csort ##csort* ⟧, #term, #index, [env]->#(env))
→ text⟦
⟨Head(SortToTypes(#csort))⟩ ⟨sub⟩ = ⟨#term⟩.getField⟨FieldSuffix(#index, 1)⟩();⟨
  JavaPatternTerm(SetSubBinderIndex(SetParent(SetSubIndex(#env, Text-Integer(#index)), #term), 0),
                  #cterm, sub, #csort, ARGUMENT,
                  [x] -> JavaPatternSubs(x, #cterm*, #csort*, #term, NumberPlus(#index, 1), [x] -> #(x)))⟩⟧

// --- Variable pattern matching outside of meta

func JavaPatternVariable(Option<VarEntry>, eager {String : JavaEnvEntry}, String /* TODO: Core_cvariable_sort when metaparser is fixed */, Text /* Current term */, [{String : JavaEnvEntry}] -> Text) -> Text

// First variable occurrence: the term is a variable use.
rule JavaPatternVariable(NONE, #env, #variable, #term, [env]->#(env))
→ text⟦
Variable ⟨var⟩ = ⟨#term⟩.variable();⟨#(AddVar(#env, #variable, Free(var)))⟩⟧

// Bound variable
// TODO: update term's parent with evaluated term.
// TODO: release acquired references.
rule JavaPatternVariable(SOME(Bound(#javavar)), #env, #variable, #term, [env]->#(env))
→ text⟦
⟨#term⟩ = force(⟨GetSink(#env)⟩.context(), ⟨#term⟩);
if (!isVariableUse(⟨#term⟩) || ⟨#javavar⟩ != ⟨#term⟩.variable()) {
  break ⟨GetLabel(#env)⟩;
}⟨#(#env)⟩⟧

// --- pattern matching inside meta

// Iterate over meta arguments and find corresponding bound variables.
func JavaPatternMaybeMetaArgs(eager {String : JavaEnvEntry}, String, List<Core_cterms_sort>, Text /* Current term */, Core_csort_sort, [{String : JavaEnvEntry}] -> Text) -> Text

rule JavaPatternMaybeMetaArgs(#env, #metavar, cterms?⟦⟧, #term, #csort, [env]->#(env))
→ #(AddMeta(#env, #metavar, #term, ()))

rule JavaPatternMaybeMetaArgs(#env, #metavar, cterms?⟦ ( ##cterm* ) ⟧, #term, #csort, [env]->#(env))
→ #(AddMeta(#env, #metavar, #term, Map([x] -> JavaFindBoundVar(#env, x), #cterm*)))

func JavaFindBoundVar(eager {String : JavaEnvEntry},Core_cterm_sort) -> Text

rule JavaFindBoundVar(#env, cterm⟦ ##VARIABLE ⟧)
→ GetVar(#env, #VARIABLE)

// Interpreter does not handle Fallback
//-(Fallback):
//JavaFindBoundVar(#env, #cterm)
//→ $(Error, $(:, "Invalid argument in metavariable: ", $(Show, #cterm)))

// ----- Contraction

func JavaContractum(eager {String : JavaEnvEntry}, Core_cterm_sort) -> Text
rule JavaContractum(#env, #term)
→ JavaStatementTerm(#env, #term, [env] -> text⟦⟧)

func JavaStatementTerm(eager {String : JavaEnvEntry}, Core_cterm_sort, [{String : JavaEnvEntry}] -> Text) -> Text

  rule JavaStatementTerm(#env, #cterm, [env]->#(env))
  → text⟦⟨If( GetTail(#env), text⟦return ⟧, text⟦⟧ )⟩⟨JavaExprTerm(#env, #cterm)⟩;⟨#(#env)⟩⟧

// ---- Generate term code - Java expression mode

func JavaExprTerm(eager {String : JavaEnvEntry}, Core_cterm_sort) -> Text

  rule JavaExprTerm(#env, cterm⟦ ##CONSTRUCTOR ##cterms? ⟧)
  → JavaExprConstruction(#env, #CONSTRUCTOR, #cterms?)

  rule JavaExprTerm(#env, cterm⟦ ##cliteral ⟧)
  → Literal(#cliteral)

  rule JavaExprTerm(#env, cterm⟦ ##VARIABLE ⟧)
  → text⟦⟨GetVar(#VARIABLE)⟩⟧

  rule JavaExprTerm(#env, cterm⟦ ##METAVAR ##cterms? ⟧)
  → JavaExprMeta(#env, #METAVAR, #cterms?)

//rule JavaEvalTerm(#env, cterm⟦ [ ##VARIABLE ] ##cterm ⟧, [env]->#(env))
  rule JavaExprTerm(#env, Core_cterm_A6([x] -> #cterm(x)))
  → text⟦context.makeVariable("x")⟧

// ---- construction expression

func JavaExprConstruction(eager {String : JavaEnvEntry}, String, List<Core_cterms_sort>) -> Text

rule JavaExprConstruction(#env, #constructor, #cterms?)
→ If( IsFuncSort(#env, #constructor),
    text⟦⟨ToJavaClassName(#constructor)⟩(context, ⟨JavaExprMaybeTerms(#env, #cterms?)⟩)⟧,
    text⟦new⟨ToJavaClassName(#constructor)⟩(⟨JavaExprMaybeTerms(#env, #cterms?)⟩)⟧)

func JavaExprMaybeTerms(eager {String : JavaEnvEntry}, List<Core_cterms_sort>) -> Text
  rule JavaExprMaybeTerms(#env, cterms?⟦⟧)
  → text⟦⟧

  rule JavaExprMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧)
  → JavaExprTerms(#env, #cterm*, text⟦⟧)

func JavaExprTerms(eager {String : JavaEnvEntry}, List<Core_cterm_sort>, Text) -> Text
  rule JavaExprTerms(#env, cterm*⟦⟧, #sep)
  → text⟦⟧

  rule JavaExprTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, #sep)
  → text⟦⟨#sep⟩⟨JavaExprTerm(#env, #cterm)⟩⟨JavaExprTerms(#env, #cterm*, text⟦, ⟧)⟩⟧

// ----  metavar expression

func JavaExprMeta(eager {String : JavaEnvEntry}, String, List<Core_cterms_sort>) -> Text

// No argument -> just send value.
rule JavaExprMeta(#env, #metavar, cterms?⟦⟧)
→ text⟦Ref.ref(⟨GetMetaVar(#env, #metavar)⟩)⟧

/*
// With arguments -> substitute.
// Start by computing arguments and then call substitute.
rule JavaExprMeta(#env, #metavar, cterms?⟦ ( ##cterm* ) ⟧)
→ text⟦⟨JavaSetTerms(#env, #cterm*, [x] -> JavaSendSubstitutes(#env, #metavar, x))⟩⟨#(#env)⟩⟧

func JavaSendSubstitutes(eager {String : JavaEnvEntry}, String, List<Text>) -> Text
rule JavaSendSubstitutes(#env, #metavar, #substitutes)
→ text⟦
⟨GetSink(#env)⟩.substitute(⟨GetMetaVar(#env, #metavar)⟩.ref(), new Variable⟨JavaSendBrackets⟩ { ⟨TextFold(GetMetaArgs(#env, #metavar), text⟦, ⟧)⟩ }, new Term⟨JavaSendBrackets⟩ {⟨TextFold(#substitutes, text⟦, ⟧)⟩});⟧

// Temporary hack till get rid of mix crsx3/crsx4 mode
func JavaSendBrackets -> Text
rule JavaSendBrackets → Text4_text_A1(Text4_content_A1("[]"), Text4_text_A2)
*/

// ----- initModule

/* Generate code initializing a module.
   Dynamically register data and function descriptors.
*/
func InitModule({ String : Core_cdecl_sort }, { String : Core_cdecl_sort }, List<String>) -> Text

rule InitModule(#data, #func, #imports)
→ text⟦
private static boolean initialized = false;
public static void init(Context context) {
}⟧

func RegisterImport(eager String) -> Text
rule RegisterImport(#name)
→ text⟦
⟨PathToImport(#name)⟩.init(context);⟧

func RegisterDataSort(Core_cdecl_sort) -> Text
rule RegisterDataSort(cdecl⟦ data ##csortvars? ##CONSTRUCTOR ( ##cform* ) ⟧)
→ TextFold(Map([x] -> RegisterDataForm(x), #cform*), text⟦⟧)

func RegisterDataForm(Core_cform_sort) -> Text
rule RegisterDataForm(cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
→ text⟦
context.register(⟨Descriptor(#CONSTRUCTOR)⟩);⟧

func RegisterFuncSort(Core_cdecl_sort) -> Text
rule RegisterFuncSort(cdecl⟦ ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧)
→ text⟦
context.register(⟨Descriptor(#CONSTRUCTOR)⟩);⟧

/* Print package declaration */
func PackageDeclaration -> Text
rule PackageDeclaration → PackageDeclaration2(GetEnv("javabasepackage", ""), GetEnv("javapackage", ""))

func PackageDeclaration2(String, String) -> Text
rule PackageDeclaration2(#base, #sub)
→ text⟦
package †⟨#base⟩⟨PackageDeclaration3(If(StringEqual(Trim(#base), ""),"", "."), #sub)⟩;⟧

func PackageDeclaration3(String, String) -> Text
rule PackageDeclaration3(#sep, #sub)
→ If(StringEqual(Trim(#sub), ""), text⟦⟧, text⟦†⟨#sep⟩†⟨#sub⟩⟧)

// Print java import
func PathToImport(String) -> Text

rule PathToImport(#name)
→ PathToImport2(If(StartsWith(#name, "Std::"), "org.transscript.compiler", GetEnv("javabasepackage", "")), PathToDot(DownCaseFirst(#name)))

func PathToImport2(String, String) -> Text

rule PathToImport2(#package, #name)
→  text⟦⟨StringToText(#package)⟩.⟨StringToText(#name)⟩⟧

func PathToDot(String) -> String
rule PathToDot(#path) → PathToDot2(Replace(#path, "::", "."))

func PathToDot2(String) -> String
rule PathToDot2(#subpackage)
→
If(Contains(#subpackage, "."),
    ConcatString(ConcatString(BeforeLast(#subpackage, "."), "."), UpCaseFirst(AfterLast(#subpackage, "."))),
    UpCaseFirst(#subpackage))

// Print class name
func ClassName(String) -> String
rule ClassName(#name) → UpCaseFirst(AfterLast(BeforeLast(#name, "."), "/"))



// ----------- Code generation environment

// To change when upgrade to crsx4.

enum VarEntry | Free(Text /* Java var */) | Bound(Text /* Java var */) | Fresh(Text /* Java var */)

enum MetaEntry | MetaVar(Text,       /* Java variable associated with the meta variable*/
                         List<Text>) /* Java variables associated to the meta variable bound variables */

enum JavaEnvEntry | ENum(Numeric) |  EText(Text) | ETexts(List<Text>) | EBool(Boolean) | EMapMeta({String : MetaEntry})
                  | EMapVar({ String : VarEntry }) | EMapDecl({ String : Core_cdecl_sort })
                  | EParams(List<Pair<Text Core_csort_sort>>)


func NewEnv -> {String : JavaEnvEntry}
rule NewEnv →
    MapPut2("sink"        , EText(text⟦⟧),    /* Current sink. */
    MapPut2("params"      , EParams(()),     /* Java method arguments. */
    MapPut2("thunk"       , ETexts(()),     /* thunk arguments */
    MapPut2("label"       , EText(text⟦⟧),    /* Current pattern block label. */
    MapPut2("tail"        , EBool(TRUE),   /* Tail? */
    MapPut2("meta"        , EMapMeta(MapNew),  /* Map meta variable to java variables */
    MapPut2("vars"        , EMapVar(MapNew),   /* Map variable to VarEntry */
    MapPut2("parent"      , EText(text⟦⟧),    /* Sub parent (if any) */
    MapPut2("subindex"    , EText(text⟦⟧),    /* Sub index */
    MapPut2("binderindex" , ENum(0),         /* Current sub binder index */
    MapPut2("binders"     , ETexts(()),    /* Binders list being constructed in contraction */
    MapPut2("data"        , ETexts(()),    /* List of parameters marked as data */
    MapNew))))))))))))


// --- Java printing helpers

// Print construction descriptor name
func Descriptor(String) -> Text
rule Descriptor(#constructor) → ToJavaIdString(#constructor)

// Print literal as a java string
func Literal(Core_cliteral_sort) -> Text
rule Literal(cliteral⟦ ##STRING ⟧) → StringToText(ConcatString("\"", ConcatString(#STRING, "\"")))
rule Literal(cliteral⟦ ##NUMBER ⟧) → StringToText(#NUMBER)

// Convert constructor to legal Java ID
func ToJavaId(String) -> Text
rule ToJavaId(#constructor) → Text-Mangle(UpCaseFirst(#constructor))

// Convert constructor to legal Java ID
func ToJavaIdString(String) -> Text
rule ToJavaIdString(#name) → Text-Mangle(#name)

// --- Helpers.

func GetValue<a>(eager {String : JavaEnvEntry}, String, [{String : JavaEnvEntry}] -> a) -> a
rule GetValue(#env, #key, [x] -> #unwrap(x))
→ #unwrap(UnSOME(MapGet(#env, #key)))

func SetValue(eager {String : JavaEnvEntry}, String, eager JavaEnvEntry) -> {String : JavaEnvEntry}
rule SetValue(#env, #key, #value)
→ MapPut(#env, #key, #value)

func UnNum(JavaEnvEntry) -> Numeric
rule UnNum(ENum(#)) → #

func UnText(JavaEnvEntry) -> Text
rule UnText(EText(#)) → #

func UnTexts(JavaEnvEntry) -> List<Text>
rule UnTexts(ETexts(#)) → #

func UnParams(JavaEnvEntry) -> List<Pair<Text Core_csort_sort>>
rule UnParams(EParams(#)) → #

func UnBool(JavaEnvEntry) -> Boolean
rule UnBool(EBool(#)) → #

func UnMapMeta(JavaEnvEntry) -> {String : MetaEntry}
rule UnMapMeta(EMapMeta(#)) → #

func UnMapVar(JavaEnvEntry) -> { String : VarEntry }
rule UnMapVar(EMapVar(#)) → #

func UnMapDecl(JavaEnvEntry) -> { String : Core_cdecl_sort }
rule UnMapDecl(EMapDecl(#)) → #


func UnVarVar(VarEntry) -> Text
rule UnVarVar(Bound(#)) → #
rule UnVarVar(Free(#)) → #
rule UnVarVar(Fresh(#)) → #

func UnMetaVar(MetaEntry) -> Text
rule UnMetaVar(MetaVar(#1, #2)) → #1

func UnMetaArgs(MetaEntry) -> List<Text>
rule UnMetaArgs(MetaVar(#1, #2)) → #2

// --- Data sorts

func GetDataSorts(eager {String : JavaEnvEntry}) -> { String : Core_cdecl_sort }
rule GetDataSorts(#env) → GetValue(#env, "datasorts", [x] -> UnMapDecl(x))

func SetDataSorts(eager {String : JavaEnvEntry}, { String : Core_cdecl_sort }) -> {String : JavaEnvEntry}
rule SetDataSorts(#env, #sorts) → SetValue(#env, "datasorts", EMapDecl(#sorts))

func IsDataSort(eager {String : JavaEnvEntry}, String) -> Boolean
rule IsDataSort(#env, #cons) → HasOption(MapGet(GetDataSorts(#env), #cons))

// --- Function sorts

func GetFuncSorts(eager {String : JavaEnvEntry}) -> { String : Core_cdecl_sort }
rule GetFuncSorts(#env) → GetValue(#env, "funcsorts", [x] -> UnMapDecl(x))

func SetFuncSorts(eager {String : JavaEnvEntry}, { String : Core_cdecl_sort }) -> {String : JavaEnvEntry}
rule SetFuncSorts(#env, #sorts) → SetValue(#env, "funcsorts", EMapDecl(#sorts))

func IsFuncSort(eager {String : JavaEnvEntry}, String) -> Boolean
rule IsFuncSort(#env, #cons) → HasOption(MapGet(GetFuncSorts(#env), #cons))

// --- Sink

func GetSink(eager {String : JavaEnvEntry}) -> Text
rule GetSink(#env) → GetValue(#env, "sink", [x] -> UnText(x))

func SetSink(eager {String : JavaEnvEntry}, Text) -> {String : JavaEnvEntry}
rule SetSink(#env, #sink) → SetValue(#env, "sink", EText(#sink))

// --- Step method arguments

func GetParams(eager {String : JavaEnvEntry}) -> List<Pair<Text Core_csort_sort>>
rule GetParams(#env) → GetValue(#env, "params", [x] -> UnParams(x))

func SetParams(eager {String : JavaEnvEntry}, List<Pair<Text Core_csort_sort>>) -> {String : JavaEnvEntry}
rule SetParams(#env, #params) → SetValue(#env, "params",  EParams(#params))

func AddParam(eager {String : JavaEnvEntry}, Text, Core_csort_sort) -> {String : JavaEnvEntry}
rule AddParam(#env, #param, #csort) → SetValue(#env, "params", EParams(Append(PairCons(#param, #csort), GetParams(#env))))

// Move to the next parameter
func NextParam(eager {String : JavaEnvEntry}) -> {String : JavaEnvEntry}
rule NextParam(#env) → SetParams(#env, Tail(GetParams(#env)))

// Get the current parameter text
func CurrentParam(eager {String : JavaEnvEntry}) -> Text
rule CurrentParam(#env) → Fst(Head(GetParams(#env)))

// Get the current parameter text
func CurrentParamSort(eager {String : JavaEnvEntry}) -> Text
rule CurrentParamSort(#env) → Snd(Head(GetParams(#env)))

// --- Current method name

func GetMethodName(eager {String : JavaEnvEntry}) -> Text
rule GetMethodName(#env) → GetValue(#env, "methodname", [x] -> UnText(x))

func SetMethodName(eager {String : JavaEnvEntry}, Text) -> {String : JavaEnvEntry}
rule SetMethodName(#env, #name) → SetValue(#env, "methodname", EText(#name))

// --- Thunk type

func GetThunkType(eager {String : JavaEnvEntry}) -> Text
rule GetThunkType(#env) → GetValue(#env, "thunktype", [x] -> UnText(x))

func SetThunkType(eager {String : JavaEnvEntry}, Text) -> {String : JavaEnvEntry}
rule SetThunkType(#env, #type) → SetValue(#env, "thunktype", EText(#type))

// --- Thunk arguments

func GetThunk(eager {String : JavaEnvEntry}) -> List<Text>
rule GetThunk(#env) → GetValue(#env, "thunk", [x] -> UnTexts(x))

func SetThunk(eager {String : JavaEnvEntry}, List<Text>) -> {String : JavaEnvEntry}
rule SetThunk(#env, #thunk) → SetValue(#env, "thunk", ETexts(#thunk))

func AddThunk(eager {String : JavaEnvEntry}, Text) -> {String : JavaEnvEntry}
rule AddThunk(#env, #thunk) → SetValue(#env, "thunk", ETexts(Append(#thunk, GetThunk(#env))))

// --- Rule case label

func GetLabel(eager {String : JavaEnvEntry}) -> Text
rule GetLabel(#env) → GetValue(#env, "label", [x] -> UnText(x))

func SetLabel(eager {String : JavaEnvEntry}, Text) -> {String : JavaEnvEntry}
rule SetLabel(#env, #label) → SetValue(#env, "label", EText(#label))

// --- Tail mode.

func GetTail(eager {String : JavaEnvEntry}) -> Boolean
rule GetTail(#env) → GetValue(#env, "tail", [x] -> UnBool(x))

func SetTail(eager {String : JavaEnvEntry}) -> {String : JavaEnvEntry}
rule SetTail(#env) → SetValue(#env, "tail", EBool(TRUE))

func UnsetTail(eager {String : JavaEnvEntry}) -> {String : JavaEnvEntry}
rule UnsetTail(#env) → SetValue(#env, "tail", EBool(FALSE))

// --- Meta

func GetMetas(eager {String : JavaEnvEntry}) -> {String : MetaEntry}
rule GetMetas(#env) → GetValue(#env, "meta", [x] -> UnMapMeta(x))

func GetMetaVar(eager {String : JavaEnvEntry}, String) -> Text
rule GetMetaVar(#env, #metavar) → UnMetaVar(UnSOME(MapGet(GetMetas(#env), #metavar)))

func GetMetaArgs(eager {String : JavaEnvEntry}, String) -> List<Text>
rule GetMetaArgs(#env, #metavar) → UnMetaArgs(UnSOME(MapGet(GetMetas(#env), #metavar)))

func AddMeta(eager {String : JavaEnvEntry}, String, Text, List<Text>) -> {String : JavaEnvEntry}
rule AddMeta(#env, #metavar, #term, #boundvars)
→ SetValue(#env,  "meta", EMapMeta(MapPut(GetMetas(#env), #metavar, MetaVar(#term, #boundvars))))

// --- Variable

func GetVars(eager {String : JavaEnvEntry}) -> { String : VarEntry }
rule GetVars(#env) → GetValue(#env, "vars", [x] -> UnMapVar(x))

func GetVar(eager {String : JavaEnvEntry}, String) -> Text
rule GetVar(#env, #var) → UnVarVar(UnSOME(MapGetVar(GetVars(#env), #var)))

func MaybeGetVar(eager {String : JavaEnvEntry}, String) -> Option<VarEntry>
rule MaybeGetVar(#env, #var) → MapGetVar(GetVars(#env), #var)

func AddVar(eager {String : JavaEnvEntry}, String /* TODO: Core_cvariable_sort */, VarEntry) -> {String : JavaEnvEntry}
rule AddVar(#env, #var, #entry)
→ SetValue(#env, "vars", EMapVar(MapPut(GetVars(#env), #var, #entry)))

// --- Parent term

func GetParent(eager {String : JavaEnvEntry}) -> Text
rule GetParent(#env) → GetValue(#env, "parent", [x] -> UnText(x))

func SetParent(eager {String : JavaEnvEntry}, Text) -> {String : JavaEnvEntry}
rule SetParent(#env, #parent)
→ SetValue(#env, "parent",  EText(#parent))

// --- sub index

func GetSubIndex(eager {String : JavaEnvEntry}) -> Text
rule GetSubIndex(#env) → GetValue(#env, "subindex", [x] -> UnText(x))

func SetSubIndex(eager {String : JavaEnvEntry}, Text) -> {String : JavaEnvEntry}
rule SetSubIndex(#env, #parent)
→ SetValue(#env, "subindex", EText(#parent))

// --- sub binder index

func GetSubBinderIndex(eager {String : JavaEnvEntry}) -> Numeric
rule GetSubBinderIndex(#env) → GetValue(#env, "binderindex", [x] -> UnNum(x))

func SetSubBinderIndex(eager {String : JavaEnvEntry}, Numeric) -> {String : JavaEnvEntry}
rule SetSubBinderIndex(#env, #index)
→ SetValue(#env, "binderindex", ENum(#index))

func IncSubBinderIndex(eager {String : JavaEnvEntry}) -> {String : JavaEnvEntry}
rule IncSubBinderIndex(#env)
→ SetValue(#env, "binderindex", ENum(Plus(GetSubBinderIndex(#env), 1)))

// --- Binders

func GetBinders(eager {String : JavaEnvEntry}) -> List<Text>
rule GetBinders(#env) → GetValue(#env, "binders", [x] -> UnTexts(x))

func SetBinders(eager {String : JavaEnvEntry}, List<Text>) -> {String : JavaEnvEntry}
rule SetBinders(#env, #binders) → SetValue(#env, "binders", ETexts(#binders))

func AddBinder(eager {String : JavaEnvEntry}, Text) -> {String : JavaEnvEntry}
rule AddBinder(#env, #binders) → SetValue(#env, "binders", ETexts(Append(#binders, GetBinders(#env))))

// --- Parameters marked as data

func GetData(eager {String : JavaEnvEntry}) -> List<Text>
rule GetData(#env) → GetValue(#env, "data", [x] -> UnTexts(x))

func AddMaybeData(eager {String : JavaEnvEntry}, Boolean, Text) -> {String : JavaEnvEntry}
rule AddMaybeData(#env, FALSE, #term) → #env

rule AddMaybeData(#env, TRUE, #term)
→ SetValue(#env, "data", ETexts(Append(#term, GetData(#env))))
