// Copyright (c) 2016 IBM Corporation.

import std::core
import std::string
import std::num
import std::listdef
import std::pairdef
import std::text
import std::text::Text4

import core::Core
import core::utils
import cg::cppenv
import systemdef

// --- Data translation functions

/* Generate a constructor method for the given form. */
func CppMethodNew(String, List<Core_csortvars_sort>, Core_cform_sort, Bool) -> Text4_text_sort

  rule CppMethodNew(#sortname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧, #header)
  → text⟦
      †⟨CppTemplatePrefix(#csortvars?)⟩
      †⟨CppTypeName(#csortvars?, #sortname)⟩ †⟨CppConsMethodName(#CONSTRUCTOR)⟩ (Context context†⟨MaybeCppFormalParams(#csorts?, text⟦, ⟧, FALSE)⟩)†⟨
      If(GenBody(#csortvars?, #header, FALSE), ()->text⟦{
       return (*new †⟨SortNameToCppClassName(#CONSTRUCTOR)⟩†⟨MaybeCppTypeArguments(#csortvars?)⟩(†⟨MaybeCppFormalParams(#csorts?, text⟦⟧, TRUE)⟩));
      }⟧, ()->text⟦;⟧)⟩
    ⟧

  rule CppMethodNew(#sortname, #csortvars?, cform⟦ allows-variable ⟧, #header)
  → text⟦
      †⟨CppTemplatePrefix(#csortvars?)⟩
      †⟨CppTypeName(#csortvars?, #sortname)⟩ Var†⟨SortNameToCppClassName(#sortname)⟩ †⟨CppFnName(ConcatString("var", #sortname))⟩ (Context ctx, std::string&& hint)†⟨
      If(GenBody(#csortvars?, #header, FALSE), ()->text⟦{
        return *(new Var†⟨SortNameToCppClassName(#sortname)⟩†⟨MaybeCppTypeArguments(#csortvars?)⟩(*(new std::string(hint))));
      }⟧, ()->text⟦;⟧)⟩
    ⟧

/* Generate base lookup method (the 'as' method) for the given form. */
func CppMethodAs(String, List<Core_csortvars_sort>, Core_cform_sort, Bool) -> Text4_text_sort

  rule CppMethodAs(#sortname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧, #header)
  → text⟦
    †⟨TextIf(#header, ()->text⟦virtual⟧)⟩ Optional<†⟨FormCppClassName(#CONSTRUCTOR)⟩†⟨MaybeCppTypeArguments(#csortvars?)⟩> †⟨CppFormQualifier(#sortname, #csortvars?, #header)⟩†⟨CppAsMethodName(#CONSTRUCTOR)⟩(Context context)†⟨
    If(GenBody(#csortvars?, #header, FALSE), ()->text⟦{
       return Optional<†⟨FormCppClassName(#CONSTRUCTOR)⟩†⟨MaybeCppTypeArguments(#csortvars?)⟩>::nullopt;
    }⟧, ()->text⟦;⟧)⟩⟧


  rule CppMethodAs(#sortname, #csortvars?, cform⟦ allows-variable ⟧, #header)
  → text⟦
      ⟧

  /*
  func FormToMethodMemoAs(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text4_text_sort
  rule FormToMethodMemoAs(#enumname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
  → text⟦
   @Override
   final public †⟨EValueClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ †⟨MethodNameAs(#CONSTRUCTOR)⟩(Context context)
   {
     return eval(context).†⟨MethodNameAs(#CONSTRUCTOR)⟩(context);
   }⟧


  rule FormToMethodMemoAs(#enumname, #csortvars?, cform⟦ allows-variable ⟧)
  → text⟦⟧
  */


/* Generate constructor. */
func CppFormConstructor(String, List<Core_csortvars_sort>, String, List<Core_csorts_sort>, Bool) -> Text4_text_sort
  rule CppFormConstructor(#sortname, #csortvars?, #formname, #csorts?, #header)
  → text⟦
    †⟨CppQualifier(#formname, #csortvars?, #header)⟩†⟨FormCppClassName(#formname)⟩(†⟨MaybeCppFormalParams(#csorts?, text⟦⟧, FALSE)⟩)†⟨
    If(GenBody(#csortvars?, #header, FALSE),
      ()->text⟦†⟨TextIf(HasSorts(#csorts?),
        ()->text⟦: †⟨MaybeCppClassFields(#csorts?, (isvar type index subindex)->CppInitField(isvar, type, index, subindex))⟩⟧)⟩{}⟧,
      ()->text⟦;⟧)⟩⟧

/* Generate overridden lookup method (the 'as' method) for the given form. Generate body only if asked for. */
func CppFormMethodAs(String, List<Core_csortvars_sort>, String, Bool) -> Text4_text_sort
  rule CppFormMethodAs(#sortname, #csortvars?, #formname, #header)
  → text⟦
    Optional<†⟨FormCppClassName(#formname)⟩†⟨MaybeCppTypeArguments(#csortvars?)⟩> †⟨CppFormQualifier(#formname, #csortvars?, #header)⟩†⟨CppAsMethodName(#formname)⟩(Context context)†⟨
    If<Text4_text_sort>(GenBody(#csortvars?, #header, FALSE), ()->text⟦{
       return make_optional<†⟨FormCppClassName(#formname)⟩†⟨MaybeCppTypeArguments(#csortvars?)⟩>(*this);
    }⟧, ()->text⟦;⟧)⟩⟧

/* Generate overridden copy method for the given form. Generate body only if asked for. */
func CppFormMethodCopy(String, List<Core_csortvars_sort>, String, Bool) -> Text4_text_sort
  rule CppFormMethodCopy(#sortname, #csortvars?, #formname, #header)
  → text⟦
    Term †⟨CppQualifier(#formname, #csortvars?, #header)⟩Copy(Context context)†⟨
    If<Text4_text_sort>(GenBody(#csortvars?, #header, FALSE), ()->text⟦{
       return (*new †⟨FormCppClassName(#formname)⟩†⟨MaybeCppTypeArguments(#csortvars?)⟩());
    }⟧, ()->text⟦;⟧)⟩⟧


/* Generate getValue method for the given form. Generate body only if asked for. */
func CppFormGetValue(String, List<Core_csortvars_sort>, String,  List<Core_csorts_sort>, Bool) -> Text4_text_sort

  rule CppFormGetValue(#sortname, #csortvars?, #formname, #csorts?, #header)
  → MaybeCppClassFields(#csorts?, (isvar type index subindex)->CppGetValue(isvar, type, index, subindex, GenBody(#csortvars?, #header, FALSE), CppFormQualifier(#formname, #csortvars?, #header)))

/* GetValue generator */
func CppGetValue(Bool, Text4_text_sort, Numeric, Numeric, Bool, Text4_text_sort) -> Text4_text_sort

  rule CppGetValue(FALSE, #type, #index, #subindex, #genbody, #qualifier)
  → text⟦†⟨#type⟩& †⟨#qualifier⟩getValue†⟨NumberToText(#index)⟩(Context ctx, bool mustforce)†⟨
      If(#genbody, ()->text⟦{
        if (mustforce)
         †⟨FieldName(#index)⟩ = force(ctx, †⟨FieldName(#index)⟩);
        return †⟨FieldName(#index)⟩;
      }⟧, ()->text⟦;⟧)⟩⟧

  rule CppGetValue(TRUE, #type, #index, #subindex, #genbody, #qualifier)
  → text⟦†⟨#type⟩& †⟨#qualifier⟩getVar†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩()†⟨
      If(#genbody, ()->text⟦{
        return †⟨VarFieldName(#index, #subindex)⟩;
      }⟧, ()->text⟦;⟧)⟩⟧

// --- Generate code for class field declarations, initialization, lookup, and update

/* Generic form sorts traversal */
func MaybeCppClassFields(List<Core_csorts_sort>, (Bool Text4_text_sort Numeric Numeric)->Text4_text_sort) -> Text4_text_sort

  rule MaybeCppClassFields(csorts?⟦⟧, #print)
  → text⟦⟧

  rule MaybeCppClassFields(csorts?⟦ ( ##csort* ) ⟧, #print)
  → CppClassFields(#csort*, 1, #print)

func CppClassFields(List<Core_csort_sort>, Numeric, (Bool Text4_text_sort Numeric Numeric)->Text4_text_sort) -> Text4_text_sort
  rule CppClassFields(csort*⟦⟧, #index, #print)
  → text⟦⟧

  rule CppClassFields(csort*⟦ ##csort ##csort* ⟧, #index, #print)
  → text⟦†⟨CppClassField(CppTypes(#csort), #index, 1, #print)⟩†⟨CppClassFields(#csort*, Plus(#index, 1), #print)⟩⟧

func CppClassField(List<Text4_text_sort>, Numeric, Numeric, (Bool Text4_text_sort Numeric Numeric)->Text4_text_sort) -> Text4_text_sort
  rule CppClassField(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex, #print)
  → #print(FALSE, #type, #index, #subindex)

  rule CppClassField(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex, #print)
  → text⟦†⟨#print(TRUE, #type, #index, #subindex)⟩†⟨CppClassField(#types, #index, Plus(#subindex, 1), #print)⟩⟧

func FieldName(#index: Numeric) -> Text4_text_sort
→ text⟦field†⟨NumberToText(#index)⟩⟧

func VarFieldName(#index: Numeric, #subindex: Numeric) -> Text4_text_sort
→ text⟦field†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩⟧

/* Print separator when not first field */
func FieldSep(#sep: Text4_text_sort, #index: Numeric, #subindex: Numeric) -> Text4_text_sort
→ TextIf(Not(And(NumberEqual(#index, 1), NumberEqual(#subindex, 1))), ()->#sep)

/* Field initialization helper */
func CppInitField(Bool, Text4_text_sort, Numeric, Numeric) -> Text4_text_sort
rule CppInitField(FALSE, #type, #index, #subindex) → text⟦†⟨FieldSep(text⟦, ⟧, #index, #subindex)⟩†⟨FieldName(#index)⟩(†⟨ParamName(#index)⟩)⟧
rule CppInitField(TRUE, #type, #index, #subindex)  → text⟦†⟨FieldSep(text⟦, ⟧, #index, #subindex)⟩†⟨VarFieldName(#index, #subindex)⟩(†⟨VarParamName(#index, #subindex)⟩)⟧

// --- Function translation functions

func CppFunctionDecl(#env: {String : EnvEntry}, #key: String, #header: Bool) -> Text4_text_sort
→ CppFunctionDeclD(#env, UnSOME(GetFuncSort(GetContent(#env), #key)), #header, FALSE)

func CppFunctionDeclD({String : EnvEntry}, Core_cdecl_sort, Bool, Bool) -> Text4_text_sort
rule CppFunctionDeclD(#env, cdecl⟦ ##canno* ##EXTERN? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧, #header, #forward)
→ TextIf(And(Not(HasAnnotation("Extern", #canno*)), Or(#forward, Or(And(#header, Not(IsEmpty(#csortvars?))), And(Not(#header), IsEmpty(#csortvars?))))), ()->
  text⟦
   †⟨CppTemplatePrefix(#csortvars?)⟩
   †⟨CppTypeRef(#csort)⟩ †⟨CppFnName(#CONSTRUCTOR)⟩(Context ctx†⟨CppMaybeFunctionParams(SetContext(SetFnAnno(#env, #canno*), text⟦ctx⟧, 1), #csorts?, (env) ->
      CppMaybeBody(env, #CONSTRUCTOR, GenBody(#csortvars?, #header, #forward)))⟩⟧) // missing )

func CppMaybeFunctionParams({String : EnvEntry}, List<Core_csorts_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
   rule CppMaybeFunctionParams(#env, csorts?⟦⟧, #cont)
   → #cont(#env)

   rule CppMaybeFunctionParams(#env, csorts?⟦ ( ##csort* ) ⟧, #cont)
   → CppFunctionParams(NewParams(#env), #csort*, #cont)

/* Generate method signature and record the argument names in the environment, keeping them in order */
func CppFunctionParams({String : EnvEntry}, List<Core_csort_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppFunctionParams(#env, csort*⟦ ⟧, #cont)
   → #cont(#env)

  rule CppFunctionParams(#env, csort*⟦ ##csort ##csort* ⟧, #cont)
  → CppFunctionParam(#env, CppTypes(#csort), #csort, (env) -> CppFunctionParams(env, #csort*, #cont))

func CppFunctionParam({String : EnvEntry}, List<Text4_text_sort>, Core_csort_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // Monomorphic sort
  rule CppFunctionParam(#env, Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), csort⟦ ##CONSTRUCTOR ##csorts? ⟧, #cont)
  → text⟦, †⟨#type⟩& ⟨STRING: value:String⟩†⟨#cont(AddParam(#env, text⟦⟨STRING: value⟩⟧, csort⟦ ##CONSTRUCTOR ##csorts? ⟧))⟩⟧

  // Sort variable
  rule CppFunctionParam(#env, Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), csort⟦ ##VARIABLE ⟧, #cont)
  → text⟦, †⟨#type⟩& ⟨STRING: value:String⟩†⟨#cont(AddParam(#env, text⟦⟨STRING: value⟩⟧, csort⟦ ##VARIABLE ⟧))⟩⟧

  // Syntactic variable sort
 rule CppFunctionParam(#env, Cons(#type:Text4_text_sort, #types: List<Text4_text_sort>), csort⟦ [ ##csort ] ##csort2 ⟧, #cont)
 → text⟦, †⟨#type⟩ ⟨STRING: var:String⟩†⟨
     CppFunctionParam(AddParam(#env, text⟦⟨STRING: var⟩⟧, #csort), #types, #csort2, #cont)⟩⟧

 // Formal parameter sort
 rule CppFunctionParam(#env, #types, csort⟦ ( ##csort ) ##csort2 ⟧, #cont)
 → CppFunctionParam(#env, #types, #csort2, #cont)

 rule CppFunctionParam(#env, (#type, ), csort⟦ { ##cmapsort* } ⟧, #cont)
 → text⟦, †⟨#type⟩ ⟨STRING: map:String⟩†⟨
     #cont(AddParam(#env, text⟦⟨STRING: map⟩⟧, csort⟦ { ##cmapsort* } ⟧))⟩⟧

 rule CppFunctionParam(#env, #types, csort⟦ data ##csort ⟧, #cont)
 → CppFunctionParam(#env, #types, #csort, #cont)

 rule CppFunctionParam(#env, #types, csort⟦ thunk ##csort ⟧, #cont)
 → CppFunctionParam(#env, #types, #csort, #cont)

/* Generate function body. See GenBody for the exact condition. */
func CppMaybeBody({String : EnvEntry}, String, Bool /* generate body? */) -> Text4_text_sort
rule CppMaybeBody(#env, #key, FALSE) → text⟦);⟧
rule CppMaybeBody(#env, #key, TRUE)  → text⟦) †⟨CppBody(#env, GetRulesForKeyC(GetContent(#env), #key))⟩⟧

func CppBody({String : EnvEntry}, Option<List<Core_cdecl_sort>>) -> Text4_text_sort

// No rules: it must be an external function (not yet checked but should)
  rule CppBody(#env, NONE)
  → text⟦;⟧

  // At least one rule: not external
  rule CppBody(#env, SOME(#rules:List<Core_cdecl_sort>))
  → text⟦{
      †⟨TextMapFold<Core_cdecl_sort>((r) -> CppBodyRule(NewMetas(NewVars(#env)), r), #rules)⟩
      †⟨TextIf(Not(HasAnnotation("Fallback", GetFnAnno(#env))), ()->text⟦throw std::runtime_error("Missing case");⟧)⟩}⟧

// --- Start method body

func CppBodyRule({String : EnvEntry}, Core_cdecl_sort) -> Text4_text_sort

  rule CppBodyRule(#env, cdecl⟦ rule ##CONSTRUCTOR → ##cterm ⟧)
  → CppContractum(#env, #cterm)

  rule CppBodyRule(#env, cdecl⟦ rule ##CONSTRUCTOR ( ##cterm* ) → ##cterm2 ⟧)
  → CppPattern(#env, #cterm*, #cterm2)

// --- Pattern matching

func CppPattern({String : EnvEntry}, List<Core_cterm_sort>, Core_cterm_sort) -> Text4_text_sort
rule CppPattern(#env, #cterms, #contractum) → CppCasePattern(SetDelayEntries(#env, {}), #cterms, #contractum)

// Data sort helper indicating whether the current term is a method parameter, or an argument (local variable).
enum Storage | PARAMETER | ARGUMENT

// Iterate over top-level pattern arguments
func CppCasePattern({String : EnvEntry}, List<Core_cterm_sort>, Core_cterm_sort) -> Text4_text_sort

  rule CppCasePattern(#env, cterm*⟦ ⟧, #contractum)
  → CppContractum(#env, #contractum)

  rule CppCasePattern(#env, cterm*⟦ ##cterm ##cterm* ⟧, #contractum)
  → CppPatternTerm(NextParam(#env), #cterm, CurrentParam(#env), SOME(CurrentParamSort(#env)), PARAMETER,
    (env) -> CppCasePattern(env, #cterm*, #contractum))

// --- Term pattern matching

func CppPatternTerm({String : EnvEntry}, Core_cterm_sort, Text4_text_sort /* Current term */,
                       Option<Core_csort_sort> /* Sort when known */, Storage, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternTerm(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #term, #csort, #storage, #cont)
  → text⟦
      †⟨ForceParameter(#env, #term, #storage)⟩
      auto ⟨STRING: value:String⟩ = †⟨#term⟩.†⟨CppAsMethodName(#CONSTRUCTOR)⟩(†⟨GetContext(#env)⟩);
      if (⟨STRING: value⟩) {
        †⟨CppPatternMaybeSubs(#env, #cterms?, text⟦⟨STRING: value⟩⟧, MaybeFindFormC(GetContent(#env), #csort, #CONSTRUCTOR), #cont)⟩
      }⟧

  // TODO: check literal
  rule CppPatternTerm(#env, cterm⟦ ##cliteral ⟧, #term, #csort, #storage, #cont)
  → #cont(#env)

  // REVISIT: bound variable reordering, ie. (x)(y)#(y, x)
  // For now only accepts patterns of the form (x)...(y)#(x, ... y)
  rule CppPatternTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #term, #csort, #storage, #cont)
  → text⟦†⟨CppPatternMaybeMetaArgs(#env, #METAVAR, #csubst?, #term, #csort, #cont)⟩⟧

  rule CppPatternTerm(#env, cterm⟦ ##canno* ##VARIABLE  ##csortanno? ⟧, #term, #csort, #storage, #cont)
  → CppPatternVariable(MaybeGetVar(#env, #VARIABLE), #env, #VARIABLE, MaybeSortAnnoToSort(#csortanno?), #term, #cont)

  rule CppPatternTerm(#env, cterm⟦ { ##cmapentries? } : { ##cmapsort } ⟧, #term, #csort, #storage, #cont)
  → CppPatternMap(#env, #cmapentries?, #term, #cmapsort, #cont)

  rule CppPatternTerm(#env, cterm⟦ [ v ##csortanno?[] ] ##cterm[v] ⟧, #term, #csort, PARAMETER, #cont)
  → CppPatternTerm(NextParam(AddVar(#env, var, Bound(#term, MaybeSortAnnoToSort(#csortanno?)))), #cterm[var], CurrentParam(#env), SOME(CurrentParamSort(#env)), PARAMETER, #cont)

  rule CppPatternTerm(#env, cterm⟦ [ v ##csortanno?[] ] ##cterm[v] ⟧, #term, #csort, ARGUMENT, #cont)
  → text⟦
      Variable ⟨STRING: boundvar:String⟩ = †⟨GetParent(#env)⟩.getVar†⟨NumberToText(GetSubIndex(#env))⟩_†⟨NumberToText(GetSubBinderIndex(#env))⟩();†⟨
      CppPatternTerm(IncSubBinderIndex(AddVar(#env, var:String, Bound(text⟦⟨STRING: boundvar⟩⟧, MaybeSortAnnoToSort(#csortanno?)))), #cterm[var], #term, #csort, ARGUMENT, #cont)⟩⟧

  rule CppPatternTerm(#env, cterm⟦ ( f  ##csortanno? ) ##cterm[f] ⟧, #term, #csort, #storage, #cont)
  → CppPatternTerm(#env, #cterm[var:String], #term, #csort, #storage, #cont)

// Pattern matching on construction arguments.
func CppPatternMaybeSubs( {String : EnvEntry}, List<Core_cterms_sort>, Text4_text_sort, Option<Pair<Core_cdecl_sort Core_cform_sort>>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMaybeSubs(#env, cterms?⟦⟧, #term, #cform, #cont)
  → #cont(#env)

  rule CppPatternMaybeSubs(#env, cterms?⟦()⟧, #term, #cform, #cont)
  → #cont(#env)

  rule CppPatternMaybeSubs(#env, cterms?⟦ ( ##cterm* ) ⟧, #term, SOME(Pair<Core_cdecl_sort Core_cform_sort>::PairCons(#cdecl:Core_cdecl_sort, cform⟦ ##CONSTRUCTOR ( ##csort* ) ⟧)), #cont)
  → CppPatternSubs(#env, #cterm*, #term, 1, SOME(#csort*), #cont)

  rule CppPatternMaybeSubs(#env, cterms?⟦ ( ##cterm* ) ⟧, #term, NONE, #cont)
  → CppPatternSubs(#env, #cterm*, #term, 1, NONE, #cont)

  func CppPatternSubs( {String : EnvEntry}, List<Core_cterm_sort>,
                     Text4_text_sort /* parent term */, Numeric /* Current subindex */, Option<List<Core_csort_sort>>, /* sub sorts, if known */
                     ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternSubs(#env, cterm*⟦⟧,  #term, #index, #csort*, #cont)
  → #cont(#env)

  rule CppPatternSubs(#env, cterm*⟦ ##cterm ##cterm* ⟧, #term, #index, #csort*, #cont)
  → text⟦
      auto& ⟨STRING: sub:String⟩ = †⟨#term⟩.value().getValue†⟨NumberToText(#index)⟩(†⟨GetContext(#env)⟩, true);†⟨
      CppPatternTerm(SetSubBinderIndex(SetParent(SetSubIndex(#env, #index), #term), 1),
                  #cterm, text⟦⟨STRING: sub⟩⟧, SubSort(#env, #cterm, #csort*), ARGUMENT,
                  (x) -> CppPatternSubs(x, #cterm*, #term, NumberPlus(#index, 1), Maybe<List List>((x)->Tail<Core_csort_sort>(x), #csort*), #cont))⟩⟧


  // --- Variable pattern matching outside of meta

func CppPatternVariable(Option<VarEntry>, {String : EnvEntry}, String, Option<Core_csort_sort>, Text4_text_sort /* Current term */, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // First variable occurrence: the term is a variable use.
  rule CppPatternVariable(NONE, #env, #variable, #csort, #term, #cont)
  → text⟦
      Optional<Var†⟨MaybeCppTypeD(#csort, text⟦iable⟧)⟩> ⟨STRING: var⟩ = †⟨#term⟩.variable();
      if (⟨STRING: var⟩)
      {
        †⟨CppApplyDelayEntries(AddVar(#env, #variable, Free(text⟦⟨STRING: var⟩⟧, #csort)), #variable, #cont)⟩
      }⟧

  // Bound variable
  // TODO: update term's parent with evaluated term.
  // TODO: release acquired references.
  rule CppPatternVariable(SOME(Bound(#Cppvar, #sort)), #env, #variable, #csort, #term, #cont)
  → text⟦
      †⟨#term⟩ = force(context, †⟨#term⟩);
      if (isVariableUse(†⟨#term⟩) && †⟨#Cppvar⟩ != †⟨#term⟩.variable()) {
        †⟨#cont(#env)⟩
      }⟧

  // --- pattern matching inside meta

// Iterate over meta arguments and find corresponding bound variables, and update environment
func CppPatternMaybeMetaArgs({String : EnvEntry}, String, List<Core_csubst_sort>, Text4_text_sort /* Current term */, Option<Core_csort_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMaybeMetaArgs(#env, #metavar, csubst?⟦⟧, #term, #csort, #cont)
  → CppApplyDelayEntries(AddMeta(#env, #metavar, #term, ()), #metavar, #cont)

  // meta substitution
  rule CppPatternMaybeMetaArgs(#env, #metavar, csubst?⟦ [ ##cterm* ] ⟧, #term, #csort, #cont)
  → #cont(AddMeta(#env, #metavar, #term, Map((x) -> CppFindBoundVar(#env, x), #cterm*)))

  func CppFindBoundVar( {String : EnvEntry},Core_cterm_sort) -> Text4_text_sort

  rule CppFindBoundVar(#env, cterm⟦ ##VARIABLE ⟧)
  → GetVar(#env, #VARIABLE)

  // Interpreter does not handle Fallback
  //-(Fallback):
  //CppFindBoundVar(#env, #cterm)
  //→ $(Error, $(:, "Invalid argument in metavariable: ", $(Show, #cterm)))

  // --- Map pattern matching

func CppPatternMap({String : EnvEntry}, List<Core_cmapentries_sort>, Text4_text_sort, Core_cmapsort_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMap(#env, cmapentries?⟦⟧, #term, #cmapsort, #cont)
  → text⟦
      †⟨#term⟩ = force(context, †⟨#term⟩);
      if (†⟨#term⟩.isEmpty())
      {
        †⟨#cont(#env)⟩
      };
    ⟧

  rule CppPatternMap(#env, cmapentries?⟦ ##cmapentry* ⟧, #term, #cmapsort, #cont)
  → CppPatternMapEntries(#env, #cmapentry*, #term, #cmapsort, #cont)

func CppPatternMapEntries({String : EnvEntry}, List<Core_cmapentry_sort>, Text4_text_sort, Core_cmapsort_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMapEntries(#env, cmapentry*⟦ ##cmapentry ##cmapentry* ⟧, #term, #cmapsort, #cont)
  → CppPatternMapEntry(#env, #cmapentry, #term, #cmapsort, (env)->CppPatternMapEntries(env, #cmapentry*, #term, #cmapsort, #cont))

  rule CppPatternMapEntries(#env, cmapentry*⟦  ⟧, #term, #cmapsort, #cont)
  → #cont(#env)

func CppPatternMapEntry({String : EnvEntry}, Core_cmapentry_sort, Text4_text_sort, Core_cmapsort_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMapEntry(#env, cmapentry⟦ : ##METAVAR ⟧, #term, #cmapsort, #cont)
  → #cont(AddMeta(#env, #METAVAR, #term, ()))

  rule CppPatternMapEntry(#env, cmapentry⟦  ¬ ##METAVAR ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetMetaVarO(#env, #METAVAR),
      (key)->text⟦
        †⟨key⟩ = force(context, †⟨key⟩);
        if (!†⟨#term⟩.contains(†⟨key⟩))
        {
          †⟨#cont(#env)⟩
        }⟧,
      ()->#cont(DelayMapEntry(#env, #METAVAR, MapEntry(cmapentry⟦ ¬ ##METAVAR ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ##METAVAR : ##cterm ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetMetaVarO(#env, #METAVAR),
      (key)->text⟦
        †⟨key⟩ = force(context, †⟨key⟩);
        Option<†⟨CppType(GetMapValueSort(#cmapsort))⟩> ⟨STRING: mval⟩ = †⟨#term⟩.getValue(†⟨GetContext(#env)⟩, †⟨key⟩).asSOME(†⟨GetContext(#env)⟩);
        if (⟨STRING: mval⟩ == null)
          break †⟨GetLabel(#env)⟩;
        †⟨CppType(GetMapValueSort(#cmapsort))⟩ ⟨STRING: value⟩ = ⟨STRING: mval⟩.asSOME(†⟨GetContext(#env)⟩).getField1(†⟨GetContext(#env)⟩, false);
        †⟨CppPatternTerm(#env, #cterm, text⟦⟨STRING: value⟩⟧, SOME(GetMapValueSort(#cmapsort)), ARGUMENT, #cont)⟩⟧,
      ()->#cont(DelayMapEntry(#env, #METAVAR, MapEntry(cmapentry⟦ ##METAVAR : ##cterm ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ##VARIABLE ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetVarO(#env, #VARIABLE),
      (key)->text⟦
        if (!†⟨#term⟩.containsVar(†⟨UnVarVar(key)⟩.variable()))
          break †⟨GetLabel(#env)⟩;
        †⟨#cont(#env)⟩⟧,
      ()->#cont(DelayMapEntry(#env, #VARIABLE, MapEntry(cmapentry⟦ ##VARIABLE ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ¬ ##VARIABLE ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetVarO(#env, #VARIABLE),
      (key)->text⟦
        if (†⟨#term⟩.containsVar(†⟨UnVarVar(key)⟩.variable()))
          break †⟨GetLabel(#env)⟩;
        †⟨#cont(#env)⟩⟧,
      ()->#cont(DelayMapEntry(#env, #VARIABLE, MapEntry(cmapentry⟦ ¬ ##VARIABLE ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ##VARIABLE : ##cterm ⟧, #term, #cmapsort, #cont)
  → IfPresent(GetVarO(#env, #VARIABLE),
      (key)->text⟦
        Option<†⟨CppType(GetMapValueSort(#cmapsort))⟩> ⟨STRING: mval⟩ = †⟨#term⟩.getValueVar(†⟨GetContext(#env)⟩, †⟨UnVarVar(key)⟩.variable()).asSOME(†⟨GetContext(#env)⟩);
        if (⟨STRING: mval⟩)
        {
          †⟨CppType(GetMapValueSort(#cmapsort))⟩ ⟨STRING: value⟩ = ⟨STRING: mval⟩.asSOME(†⟨GetContext(#env)⟩).getField1(†⟨GetContext(#env)⟩, false);
          †⟨CppPatternTerm(#env, #cterm, text⟦⟨STRING: value⟩⟧, SOME(GetMapValueSort(#cmapsort)), ARGUMENT, #cont)⟩
        }⟧,
      ()->#cont(DelayMapEntry(#env, #VARIABLE, MapEntry(cmapentry⟦ ##VARIABLE : ##cterm ⟧, #term, #cmapsort))))

  rule CppPatternMapEntry(#env, cmapentry⟦ ##STRING ⟧, #term, #cmapsort, #cont)
  → text⟦
      if (†⟨#term⟩.contains(†⟨CppExprLiteral(cliteral⟦ ##STRING ⟧)⟩))
      {
        †⟨#cont(#env)⟩
      }⟧

  rule CppPatternMapEntry(#env, cmapentry⟦ ¬ ##STRING ⟧, #term, #cmapsort, #cont)
  → text⟦
      if (!†⟨#term⟩.contains(†⟨CppExprLiteral(cliteral⟦ ##STRING ⟧)⟩))
      {
        †⟨#cont(#env)⟩
      }⟧

  rule CppPatternMapEntry(#env, cmapentry⟦ ##STRING  : ##cterm ⟧, #term, #cmapsort, #cont)
 → text⟦
      Option<†⟨CppType(GetMapValueSort(#cmapsort))⟩> ⟨STRING: mval⟩ = †⟨#term⟩.getValue(†⟨GetContext(#env)⟩, †⟨CppExprLiteral(cliteral⟦ ##STRING ⟧)⟩).asSOME(†⟨GetContext(#env)⟩);
      if (⟨STRING: mval⟩)
      {
        †⟨CppType(GetMapValueSort(#cmapsort))⟩ ⟨STRING: value⟩ = ⟨STRING: mval⟩.asSOME(†⟨GetContext(#env)⟩).getField1(†⟨GetContext(#env)⟩, false);
        †⟨CppPatternTerm(#env, #cterm, text⟦⟨STRING: value⟩⟧, SOME(GetMapValueSort(#cmapsort)), ARGUMENT, #cont)⟩
      }⟧


/* Apply delayed map entries waiting for the given `#var` (meta or not) to be initialized */
func CppApplyDelayEntries(#env: {String : EnvEntry}, #var: String, #cont:({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
→ CppApplyDelayEntriesAux(#env, GetDelayEntriesForVar(#env, #var), #cont)

func CppApplyDelayEntriesAux({String : EnvEntry}, List<MapEntry>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
rule CppApplyDelayEntriesAux(#env, Cons(MapEntry(#cmapentry, #term, #cmapsort), #entries), #cont) → CppPatternMapEntry(#env, #cmapentry, #term, #cmapsort, (env)->CppApplyDelayEntriesAux(env, #entries, #cont))
rule CppApplyDelayEntriesAux(#env, Nil                                                    , #cont) → #cont(#env)

  //  --------- Helper function for pattern matching

  /* Generate force call if term is a parameter */
  func ForceParameter({String : EnvEntry}, Text4_text_sort, Storage) -> Text4_text_sort
    rule ForceParameter(#env, #term, PARAMETER) →  text⟦†⟨#term⟩ = force(†⟨GetContext(#env)⟩, †⟨#term⟩);⟧
    rule ForceParameter(#env, #term, #storage)  →  text⟦⟧

  /* Get sub sort. Get it from term and if not available on sort */
  func SubSort(#env: {String : EnvEntry}, #cterm: Core_cterm_sort, #csorts?: Option<List<Core_csort_sort>>) -> Option<Core_csort_sort>
  → SubSort2(SubSortFromTerm(#env, #cterm), #csorts?)

  func SubSort2(Option<Core_csort_sort>, Option<List<Core_csort_sort>>) -> Option<Core_csort_sort>
    rule SubSort2(SOME(#csort:Core_csort_sort), #)       → SOME(#csort)
    rule SubSort2(NONE, NONE)                            → NONE
    rule SubSort2(NONE, SOME(csort*⟦ ##csort ##csort* ⟧)) → SOME(#csort)

  func SubSortFromTerm({String : EnvEntry}, Core_cterm_sort) -> Option<Core_csort_sort>

    rule SubSortFromTerm(#env, cterm⟦ ##canno* ##csort :: ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧)
    → SOME(#csort)

    rule SubSortFromTerm(#env, cterm⟦ ##canno* ##CONSTRUCTOR ##csortargs?  ##cterms? ##csortanno? ⟧)
    → NONE

    rule SubSortFromTerm(#env, cterm⟦ ##STRING ⟧)
    → SOME(csort⟦ String ⟧)

    rule SubSortFromTerm(#env, cterm⟦ ##NUMBER ⟧)
    → SOME(csort⟦ Numeric⟧)

    rule SubSortFromTerm(#env, cterm⟦ ##canno* ##VARIABLE ⟧)
    → SubSortFromVar(MaybeGetVar(#env, #VARIABLE), #VARIABLE)

    rule SubSortFromTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧)
    → MaybeSortAnnoToSort(#csortanno?)

    rule SubSortFromTerm(#env, cterm⟦ { ##cmapentries? } ##csortanno? ⟧)
    → MaybeSortAnnoToSort(#csortanno?)

    // TODO: maybe error?
    rule SubSortFromTerm(#env, cterm⟦ [ x ##csortanno?[] ] ##cterm[x] ⟧)
    //rule SubSortFromTerm(#env, Core_cterm_A6(#csortanno?:List<Core_csortanno_sort>, [x] -> #cterm[x] : Core_cterm_sort))
    → SubSortFromTerm(#env, #cterm[var:String])

    // TODO: maybe error?
    rule SubSortFromTerm(#env, cterm⟦ ( f ##csortanno?[] ) ##cterm[f] ⟧)
    //rule SubSortFromTerm(#env, Core_cterm_A7(#csortanno?:List<Core_csortanno_sort>, [x] -> #cterm[x] : Core_cterm_sort))
    → SubSortFromTerm(#env, #cterm[var:String])

  func SubSortFromVar(Option<VarEntry>, String) -> Option<Core_csort_sort>
    rule SubSortFromVar(NONE, #var)                      → NONE
    rule SubSortFromVar(SOME(#varEntry:VarEntry), #var)  → UnVarSort(#varEntry)

// ----- Contraction

func CppContractum(#env: {String : EnvEntry}, #term: Core_cterm_sort) -> Text4_text_sort
→ CppStatementTerm(SetTail(#env, TRUE), #term)

func CppStatementTerm(#env: {String : EnvEntry}, #cterm: Core_cterm_sort) -> Text4_text_sort
→ text⟦†⟨CppFreshesTerm(SetCounter(#env, 0), #cterm, (env) ->
     text⟦†⟨TextIf(GetTail(env), ()->text⟦return ⟧)⟩†⟨CppExprTerm(SetCounter(env, 0), #cterm, (env) -> text⟦⟧)⟩;⟧)⟩⟧

// ---- Generate fresh variable - Only in Cpp statement mode

func CppFreshesTerm({String : EnvEntry}, Core_cterm_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppFreshesTerm(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #cont)
  → CppFreshesMaybeTerms(#env, #cterms?, #cont)

  rule CppFreshesTerm(#env, cterm⟦ ##canno* ##VARIABLE ##csortanno? ⟧, #cont)
  → CppFreshesVariable(#env, MaybeGetVar(#env, #VARIABLE), #VARIABLE, #csortanno?, #cont)

  rule CppFreshesTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #cont)
  → CppFreshesMaybeTerms(#env, #cterms?, (env) -> CppFreshesMaybeSubst(env, #csubst?, #cont))

  rule CppFreshesTerm(#env, cterm⟦ [ x ##csortanno?[] ] ##cterm[x] ⟧, #cont)
  → CppFreshesVariable(#env, NONE, var:String, #csortanno?, (env) -> CppFreshesTerm(env, #cterm[var], #cont))

  // TODO: track var to avoid generating dummy fresh variables
  rule CppFreshesTerm(#env, cterm⟦ ( f ##csortanno?[] ) ##cterm[f] ⟧, #cont)
  → CppFreshesTerm(AddVar(#env, var, Formal(text⟦ dummy ⟧, NONE)), #cterm[var], #cont)

  rule CppFreshesTerm(#env, cterm⟦ thunk ##cterm ⟧, #cont)
  → CppFreshesTerm(#env, #cterm, #cont)

  rule CppFreshesTerm(#env, cterm⟦ ##cliteral ⟧, #cont)
  → #cont(#env)

func CppFreshesMaybeTerms({String : EnvEntry}, List<Core_cterms_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
rule CppFreshesMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧, #cont) → CppFreshesTerms(#env, #cterm*, #cont)
rule CppFreshesMaybeTerms(#env, #cterms?              , #cont) → #cont(#env)

func CppFreshesTerms({String : EnvEntry}, List<Core_cterm_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
rule CppFreshesTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, #cont) → CppFreshesTerm(#env, #cterm, (env) -> CppFreshesTerms(env, #cterm*, #cont))
rule CppFreshesTerms(#env, cterm*⟦                  ⟧, #cont) → #cont(#env)

func CppFreshesMaybeSubst({String : EnvEntry}, List<Core_csubst_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
rule CppFreshesMaybeSubst(#env, csubst?⟦              ⟧, #cont) → #cont(#env)
rule CppFreshesMaybeSubst(#env, csubst?⟦ [ ##cterm* ] ⟧, #cont) → CppFreshesTerms(#env, #cterm*, #cont)

func CppFreshesVariable({String : EnvEntry}, Option<VarEntry>, String, List<Core_csortanno_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // untyped fresh var
  rule CppFreshesVariable(#env, NONE, #var, csortanno?⟦  ⟧, #cont)
  → text⟦
   VarStringTerm& fresh†⟨NumberToText(GetCounter(#env))⟩ = varStringTerm(†⟨Text-QuoteEscape(Show<String>(#var))⟩);†⟨
     #cont(IncCounter(AddVar(#env, #var, Fresh(text⟦fresh†⟨NumberToText(GetCounter(#env))⟩⟧, NONE))))⟩⟧

  // New typed fresh variable
  rule CppFreshesVariable(#env, NONE, #var, csortanno?⟦ : ##csort ⟧, #cont)
  → text⟦
   Var†⟨CppType(#csort)⟩& fresh†⟨NumberToText(GetCounter(#env))⟩ = var†⟨CppType(#csort)⟩(†⟨GetContext(#env)⟩, †⟨Text-QuoteEscape(Show<String>(#var))⟩);⟨
     #cont(IncCounter(AddVar(#env, #var, Fresh(text⟦fresh†⟨NumberToText(GetCounter(#env))⟩⟧, SOME(#csort)))))⟩⟧

  // Variable already exists
  rule CppFreshesVariable(#env, SOME(#:VarEntry), #var, #csortanno?, #cont)
  → #cont(#env)

// ---- Generate term code - C++ expression mode

func CppExprTerm({String : EnvEntry}, Core_cterm_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 rule CppExprTerm(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #cont)
 → CppExprConstruction(#env, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #cont)

 rule CppExprTerm(#env, cterm⟦ ##cliteral ⟧, #cont)
 → text⟦
     †⟨CppExprLiteral(#cliteral)⟩†⟨#cont(#env)⟩⟧

 rule CppExprTerm(#env, cterm⟦ ##canno* ##VARIABLE ##csortanno? ⟧, #cont)
 → CppExprMaybeVar(#env, MaybeGetVar(#env, #VARIABLE), #VARIABLE, #cont)

 rule CppExprTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #cont)
 → CppExprMeta(#env, #METAVAR, #cterms?, #csubst?, #cont)

 rule CppExprTerm(#env, cterm⟦ [ x ##csortanno?[] ] ##cterm[x] ⟧, #cont)
 → text⟦
     fresh†⟨NumberToText(GetCounter(#env))⟩, †⟨CppExprTerm(AddVar(IncCounter(#env), var:String, Fresh(text⟦fresh†⟨NumberToText(GetCounter(#env))⟩⟧, MaybeSortAnnoToSort(#csortanno?))), #cterm[var], #cont)⟩⟧

 rule CppExprTerm(#env, cterm⟦ ( f ##csortanno?[] ) ##cterm[f] ⟧, #cont)
 → text⟦closure†⟨CppLambdaTypeArgs(#cterm[dummy])⟩(†⟨CppExprLambda(#env, cterm⟦ ( f ##csortanno?[] ) ##cterm[f] ⟧, 0, #cont)⟩⟧

 rule CppExprTerm(#env, cterm⟦ thunk ##cterm ⟧, #cont)
 → text⟦thunk†⟨CppLambdaTypeArgs(#cterm)⟩(†⟨CppExprLambda(#env, #cterm, 0, #cont)⟩⟧

// ---- construction expression

func CppExprConstruction({String : EnvEntry}, String,  List<Core_csortargs_sort>, List<Core_cterms_sort>, List<Core_csortanno_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 rule CppExprConstruction(#env, #constructor, #csortargs?, #cterms?, #csortanno?, #cont)
 → text⟦†⟨CppFnName(#constructor)⟩†⟨CppMaybeTypeArgs(#csortargs?)⟩(†⟨GetContext(#env)⟩†⟨CppExprMaybeTerms(#env, #cterms?, #cont)⟩⟧

func CppExprMaybeTerms({String : EnvEntry}, List<Core_cterms_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 rule CppExprMaybeTerms(#env, cterms?⟦⟧, #cont)
 → text⟦)†⟨#cont(#env)⟩⟧

 rule CppExprMaybeTerms(#env, cterms?⟦()⟧, #cont)
 → text⟦)†⟨#cont(#env)⟩⟧

 rule CppExprMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧, #cont)
 → CppExprTerms(#env, #cterm*, #cont)

func CppExprTerms({String : EnvEntry}, List<Core_cterm_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 rule CppExprTerms(#env, cterm*⟦⟧, #cont)
 → text⟦)†⟨#cont(#env)⟩⟧

 rule CppExprTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, #cont)
 → text⟦, †⟨CppExprTerm(#env, #cterm, (env) -> CppExprTerms(env, #cterm*, #cont))⟩⟧

// --- Variable

func CppExprMaybeVar({String : EnvEntry}, Option<VarEntry>, String, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 rule CppExprMaybeVar(#env, NONE, #svar, #cont) // Fresh variable must have been declared
 → #cont(#env)

 rule CppExprMaybeVar(#env, SOME(VarEntry::Formal(#var:Text4_text_sort, #type:Option<Core_csort_sort>)), #svar, #cont)
 → text⟦†⟨#var⟩†⟨#cont(#env)⟩⟧

 // fallback
 rule CppExprMaybeVar(#env, SOME(#varEntry:VarEntry), #svar, #cont)
 → text⟦†⟨UnVarVar(#varEntry)⟩.use()†⟨#cont(#env)⟩⟧

// ----  metavar expression

func CppExprMeta({String : EnvEntry}, String, List<Core_cterms_sort>, List<Core_csubst_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // TODO: check that metavar is defined

 // No arguments -> just return the metavariable.
 rule CppExprMeta(#env, #metavar, cterms?⟦⟧, csubst?⟦⟧, #cont)
 → text⟦†⟨GetMetaVar(#env, #metavar)⟩†⟨#cont(#env)⟩⟧

 // No arguments in parenthesis -> call lambda with no param.
 rule CppExprMeta(#env, #metavar, cterms?⟦ () ⟧, csubst?⟦⟧, #cont)
 → text⟦†⟨GetMetaVar(#env, #metavar)⟩.eval(ctx)†⟨#cont(#env)⟩⟧

 // Apply arguments -> call lambda
 rule CppExprMeta(#env, #metavar, cterms?⟦ ( ##cterm* ) ⟧, csubst?⟦⟧, #cont)
 → text⟦†⟨GetMetaVar(#env, #metavar)⟩.eval(†⟨GetContext(#env)⟩†⟨CppExprTerms(#env, #cterm*, #cont)⟩⟧

 // Substitution
 rule CppExprMeta(#env, #metavar, cterms?⟦⟧, csubst?⟦ [ ##cterm* ] ⟧, #cont)
 → text⟦subst(†⟨GetContext(#env)⟩, †⟨GetMetaVar(#env, #metavar)⟩†⟨CppExprMetaArgs(#env, GetMetaArgs(#env, #metavar), #cterm*, #cont)⟩⟧

 // TODO: call and subsitution

func CppExprMetaArgs({String : EnvEntry}, List<Text4_text_sort> /* pattern args */, List<Core_cterm_sort> /* contraction args */,
                    ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 rule CppExprMetaArgs(#env, (), #args,  #cont)
 → text⟦)†⟨#cont(#env)⟩⟧

 rule CppExprMetaArgs(#env, Cons(#binder:Text4_text_sort,  #binders: List<Text4_text_sort>), Cons(#arg:Core_cterm_sort, #args:List<Core_cterm_sort>), #cont)
 → text⟦,†⟨#binder⟩,†⟨CppExprTerm(#env, #arg, (env) -> CppExprMetaArgs(env, #binders, #args, #cont))⟩⟧

// ---- lambda expression

func CppExprLambda({String : EnvEntry}, Core_cterm_sort, Numeric, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 rule CppExprLambda(#env, cterm⟦ ( f ##csortanno? ) ##cterm[f] ⟧, #arity, #cont)
 → CppExprLambda(AddVar(#env, var, Formal(text⟦⟨STRING: var⟩⟧, MaybeSortAnnoToSort(#csortanno?))), #cterm[var], Plus(#arity, 1), #cont)

 rule CppExprLambda(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #arity, #cont)
 → text⟦&†⟨CppConsMethodName(#CONSTRUCTOR)⟩†⟨CppExprTerms(#env, SubList(MaybeTermsToTerms(#cterms?), #arity), #cont)⟩⟧

  rule CppExprLambda(#env, #cterm, #arity, #cont)
  → Error("Internal Error: Invalid lambda expression. Lambda must be of the form (x .. y) -> C(x .. y, #1 .. #n)")

// Generate closure function type arguments. Not needed if the called function is not parameterized, C++ is callable of deducing types.
func CppLambdaTypeArgs(Core_cterm_sort) -> Text4_text_sort

  rule CppLambdaTypeArgs(cterm⟦ ( f ##csortanno?[] ) ##cterm[f] ⟧)
  → CppLambdaTypeArgs(#cterm[dummy])

  rule CppLambdaTypeArgs(cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs ##cterms? : ##csort ⟧)
  → text⟦<†⟨TextFold((CppType(#csort), CppGetSortsMaybeTerms(#cterms?)...), text⟦, ⟧)⟩>⟧

  rule CppLambdaTypeArgs(cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##cterms? ##csortanno? ⟧)
  → text⟦⟧

  rule CppLambdaTypeArgs(#cterm)
  → Error("Internal Error: Invalid lambda expression. Lambda must be of the form (x .. y) -> C(x .. y, #1 .. #n)")

// --- Literal

func CppExprLiteral(Core_cliteral_sort) -> Text4_text_sort
  rule CppExprLiteral(cliteral⟦ ##STRING ⟧) → text⟦stringTerm(†⟨Text-QuoteEscape(#STRING)⟩)⟧
  rule CppExprLiteral(cliteral⟦ ##NUMBER ⟧) → text⟦doubleTerm(⟨STRING: #NUMBER⟩)⟧

// --- Sort translation functions

/* Generate template prefix for given sort variables */
func CppTemplatePrefix(List<Core_csortvars_sort>) -> Text4_text_sort

  rule CppTemplatePrefix(csortvars?⟦⟧) → text⟦⟧

  rule CppTemplatePrefix(csortvars?⟦ ∀ ##VARIABLE+ . ⟧)
  → text⟦template <†⟨CppTypeParameters(#VARIABLE+)⟩>⟧

/* Generate comma-seperated list of type parameters */
func CppTypeParameters(#vars: List<String>) -> Text4_text_sort
→ TextFold(Map<String Text4_text_sort>((var) -> text⟦typename ⟨STRING: var⟩⟧, #vars), text⟦, ⟧)

/* Generate comma-separated list of type arguments from sort variables, if any*/
func MaybeCppTypeArguments(List<Core_csortvars_sort>) -> Text4_text_sort
rule MaybeCppTypeArguments(csortvars?⟦⟧) → text⟦⟧
rule MaybeCppTypeArguments(csortvars?⟦ ∀ ##VARIABLE+ . ⟧) → text⟦<†⟨CppTypeArguments(#VARIABLE+)⟩>⟧

/* Generate comma-separated list of type arguments from sort variables */
func CppTypeArguments(#vars: List<String>) -> Text4_text_sort
→ TextFold(Map<String Text4_text_sort>((var) -> text⟦⟨STRING: var⟩⟧, #vars), text⟦, ⟧)

/* Generate (possibility dependent) type name corresponding to the given data sort type */
func CppTypeName(List<Core_csortvars_sort>, String) -> Text4_text_sort

  rule CppTypeName(csortvars?⟦⟧, #sortname)
  → SortNameToCppClassNameRef(#sortname)

  //TODO: might need typename when occurs within a template class.
  rule CppTypeName(csortvars?⟦ ∀ ##VARIABLE+ . ⟧, #sortname)
  → text⟦†⟨SortNameToCppClassName(#sortname)⟩<†⟨CppTypeArguments(#VARIABLE+)⟩>&⟧

/* Generate arguments for template instantiation */
func MaybeCppTemplateArgs(List<Core_csorts_sort>) -> Text4_text_sort

    rule MaybeCppTemplateArgs(csorts?⟦ ⟧)
    → text⟦⟧

    rule MaybeCppTemplateArgs(csorts?⟦ ( ##csort* )⟧)
    → text⟦<†⟨TextFold(Map((csort) -> CppType(csort), #csort*), text⟦, ⟧)⟩>⟧

/* Convert list of sorts to a list of formal parameters or arguments. */
func MaybeCppFormalParams(List<Core_csorts_sort>, Text4_text_sort, Bool /* omit types */) -> Text4_text_sort

  rule MaybeCppFormalParams(csorts?⟦⟧, #sep, #isarg)
  → text⟦⟧

  rule MaybeCppFormalParams(csorts?⟦ ( ##csort*) ⟧, #sep, #isarg)
  → CppFormalParams(#csort*, 1, #sep, #isarg)

func CppFormalParams(List<Core_csort_sort>, Numeric, Text4_text_sort, Bool) -> Text4_text_sort

  rule CppFormalParams(csort*⟦⟧, #index, #sep, #isarg)
  → text⟦⟧

  rule CppFormalParams(csort*⟦ ##csort ##csort* ⟧, #index, #sep, #isarg)
  → text⟦†⟨#sep⟩†⟨CppFormalParam(CppTypes(#csort), #index, 1, #isarg)⟩†⟨CppFormalParams(#csort*, Plus(#index, 1), text⟦, ⟧, #isarg)⟩⟧

func CppFormalParam(List<Text4_text_sort>, Numeric, Numeric, Bool) -> Text4_text_sort

  rule CppFormalParam(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex, #isarg)
  → text⟦†⟨If(#isarg, ()->text⟦⟧, ()->text⟦†⟨#type⟩& ⟧)⟩†⟨ParamName(#index)⟩⟧

  rule CppFormalParam(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex, #isarg)
  → text⟦†⟨If(#isarg, ()->text⟦⟧, ()->text⟦†⟨#type⟩& ⟧)⟩†⟨VarParamName(#index, #subindex)⟩, †⟨CppFormalParam(#types, #index, Plus(#subindex, 1), #isarg)⟩⟧

func ParamName(#index: Numeric) -> Text4_text_sort
→ text⟦param†⟨NumberToText(#index)⟩⟧

func VarParamName(#index: Numeric, #subindex: Numeric) -> Text4_text_sort
→ text⟦param†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩⟧

/* Translate TS sort to equivalent list of C++ types:
 * A list of types corresponding to syntactic variable sorts and a type for the last sort
 * Note: return a type, not a type reference
 */
func CppTypes(#csort: Core_csort_sort) -> List<Text4_text_sort>
→ CppTypes2(#csort, ())

func CppTypes2(Core_csort_sort, List<Text4_text_sort> /* formal params */) -> List<Text4_text_sort>

  rule CppTypes2(csort⟦ ##CONSTRUCTOR ##csorts? ⟧, ())
  → Cons(text⟦†⟨SortNameToCppClassName(CppFixupPrimitiveType(#CONSTRUCTOR))⟩†⟨MaybeCppTemplateArgs(#csorts?)⟩⟧, Nil)

  rule CppTypes2(csort⟦ ##CONSTRUCTOR ##csorts? ⟧, Cons(#formal:Text4_text_sort, #formals:List<Text4_text_sort>))
  → Cons(text⟦_Closure†⟨NumberToText(Plus(ListLength<Text4_text_sort>(#formals), 1))⟩<†⟨
       SortNameToCppClassName(CppFixupPrimitiveType(#CONSTRUCTOR))⟩†⟨MaybeCppTemplateArgs(#csorts?) /* Return type */⟩, †⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* Formal params */⟩>⟧, Nil)

  rule CppTypes2(csort⟦ ##VARIABLE ⟧, ())
  → Cons(text⟦⟨STRING: #VARIABLE⟩⟧, Nil)

  rule CppTypes2(csort⟦ ##VARIABLE ⟧, Cons(#formal:Text4_text_sort, #formals:List<Text4_text_sort>))
  → Cons(text⟦_Closure†⟨NumberToText(Plus(ListLength(#formals), 1))⟩<⟨STRING: #VARIABLE /* Return type */⟩, †⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* Formal params */⟩>⟧, Nil)

  rule CppTypes2(csort⟦ [ ##csort ] ##csort2 ⟧, #formals)
  → Cons(text⟦_Var†⟨CppType(#csort)⟩⟧, CppTypes2(#csort2, #formals))

  rule CppTypes2(csort⟦ ( ##csort ) ##csort2 ⟧, #formals) // no higher-order csort for now.
  → CppTypes2(#csort2, Append(CppType(#csort), #formals))

  rule CppTypes2(csort⟦ { ##csort1 : ##csort2 } ⟧, ())
  → Cons(text⟦_MapTerm<†⟨CppType(#csort1)⟩,†⟨CppType(#csort2)⟩>⟧, Nil)

  rule CppTypes2(csort⟦ { ##cmapsort } ⟧, Cons(#formal:Text4_text_sort, #formals:List<Text4_text_sort>))
  → Cons(text⟦_Closure†⟨NumberToText(Plus(ListLength(#formals), 1))⟩<_MapTerm, †⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* Formal params */⟩>⟧, Nil)

  rule CppTypes2(csort⟦ data ##csort ⟧, #formals)
  → CppTypes2(#csort, #formals)

  rule CppTypes2(csort⟦ thunk ##csort ⟧, #formals)
  → Cons(text⟦_Closure0<†⟨CppType(#csort)⟩>⟧, Nil)

/* Same as above, expect ignore syntactic variables */
func CppType(#csort: Core_csort_sort) -> Text4_text_sort
→ Last(CppTypes(#csort)) // TODO: could optimize

/* Same as above, but return a reference type */
func CppTypeRef(#csort: Core_csort_sort) -> Text4_text_sort
→ text⟦†⟨CppType(#csort)⟩&⟧

/* Same as above, expect maybe get a sort. Generate auto& when no type. */
func MaybeCppType(#csort?: Option<Core_csort_sort>) -> Text4_text_sort
→ IfPresent(Maybe((csort)->CppType(csort), #csort?), (type) -> type, () -> text⟦auto&⟧)

/* Same as above, expect with default value */
func MaybeCppTypeD(Option<Core_csort_sort>, Text4_text_sort) -> Text4_text_sort
rule MaybeCppTypeD(NONE        , #default) → #default
rule MaybeCppTypeD(SOME(#csort), #default) → CppType(#csort) // TODO: could optimize

/* Rename builtin types to avoid conflict with C++ types */
func CppFixupPrimitiveType(#typename: String) -> String
→ If(StringEqual(#typename, "String"), ()->"StringTerm",
    ()->If(StringEqual(#typename, "Numeric"), ()->"DoubleTerm",
         ()->#typename))

func CppMaybeTypeArgs(List<Core_csortargs_sort>) -> Text4_text_sort
rule CppMaybeTypeArgs(csortargs?⟦              ⟧) → text⟦⟧
rule CppMaybeTypeArgs(csortargs?⟦ < ##csort* > ⟧) → text⟦<†⟨TextFold(Map((csort)->CppType(csort), #csort*), text⟦, ⟧)⟩>⟧

/* Extract sorts from the given optional list of arguments */
func CppGetSortsMaybeTerms(List<Core_cterms_sort>) -> List<Text4_text_sort>
rule CppGetSortsMaybeTerms(cterms?⟦ ( ##cterm* ) ⟧ ) → CppGetSortsTerms(#cterm*)
rule CppGetSortsMaybeTerms(#cterms?               ) → ()

func CppGetSortsTerms(#terms: List<Core_cterm_sort>) -> List<Text4_text_sort>
→ Map((term) -> IfPresent(TermSort(term), (sort)->CppType(sort), ()->Error("Internal Error: missing sort.")), #terms)
// --- Basic conversion functions

/* Convert data sort name to corresponding C++ class name */
func SortNameToCppClassName(#name: String) -> Text4_text_sort
→ text⟦_⟨STRING: #name⟩⟧

/* Convert data sort name to equivalent C++ class name reference */
func SortNameToCppClassNameRef(#name: String) -> Text4_text_sort
→ text⟦_⟨STRING: #name⟩&⟧

/* Convert data form to corresponding C++ constructor method name */
func CppConsMethodName(#name: String) -> Text4_text_sort
→ text⟦⟨STRING: #name⟩⟧

/* Convert data form to corresponding C++ 'as' method name */
func CppAsMethodName(#name: String) -> Text4_text_sort
→ text⟦as⟨STRING: #name⟩⟧

/* Convert data form to corresponding C++ class name */
func FormCppClassName(#name: String) -> Text4_text_sort
→ text⟦_⟨STRING: #name⟩⟧

/* Convert data form to corresponding C++ class name reference */
func FormCppClassNameRef(#name: String) -> Text4_text_sort
→ text⟦_⟨STRING: #name⟩&⟧

/* Convert TS function name to corresponding C++ function name  */
func CppFnName(#name: String) -> Text4_text_sort
→ text⟦⟨STRING: #name⟩⟧

// --- helper function

/* Whether to generate function body */
func GenBody(#csortvars? : List<Core_csortvars_sort>, #header : Bool, #forward: Bool) -> Bool
→ And(
    Not(#forward),
    Or(
      And(IsEmpty   (#csortvars?), Not(#header)),
      And(IsNotEmpty(#csortvars?), #header)))

/* Generate method qualifier, only for non-templated method in source file */
func CppQualifier(#sortname: String, #csortvars? : List<Core_csortvars_sort>, #header : Bool) -> Text4_text_sort
→ TextIf(And(IsEmpty<Core_csortvars_sort>(#csortvars?), Not(#header)),
    ()->text⟦†⟨SortNameToCppClassName(#sortname)⟩::⟧)

/* Generate method qualifier, only for non-templated method in source file */
func CppFormQualifier(#formname: String, #csortvars? : List<Core_csortvars_sort>, #header : Bool) -> Text4_text_sort
→ TextIf(And(IsEmpty<Core_csortvars_sort>(#csortvars?), Not(#header)),
    ()->text⟦†⟨FormCppClassName(#formname)⟩::⟧)
