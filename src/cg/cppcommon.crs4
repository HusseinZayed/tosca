// Copyright (c) 2016 IBM Corporation.

import Std::Core
import Std::String
import Std::Num
import Std::Listdef
import Std::Pairdef
import Std::Text
import Text::Text4
import Core::Core
import Core::Utils
import Cg::Cppenv
import Systemdef

// --- Data translation functions

/* Generate a constructor method for the given form. */
func CppMethodNew(String, List<Core_csortvars_sort>, Core_cform_sort, Bool) -> Text4_text_sort
  rule CppMethodNew(#sortname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧, #header)
  → text⟦
    †⟨CppTemplatePrefix(#csortvars?)⟩
    †⟨CppTypeName(#csortvars?, #sortname)⟩ †⟨CppConsMethodName(#CONSTRUCTOR)⟩ (Context context†⟨MaybeCppFormalParams(#csorts?, text⟦, ⟧, FALSE)⟩)†⟨
    If<Text4_text_sort>(GenBody(#csortvars?, #header), ()->text⟦{
       return (*new †⟨SortNameToCppClassName(#CONSTRUCTOR)⟩†⟨MaybeCppTypeArguments(#csortvars?)⟩(†⟨MaybeCppFormalParams(#csorts?, text⟦⟧, TRUE)⟩));
    }⟧, ()->text⟦;⟧)⟩
  ⟧
/*
  rule FormToCppMethodNew(#constructor, #csortvars?, cform⟦ allows-variable ⟧, #body)
  → text⟦
    static †⟨SortParamToTypeParam(#csortvars?, TRUE)⟩ Var⟨STRING: ToCppClassName(#constructor)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ †⟨CppFnName(ConcatString("var", #constructor))⟩ (Context ctx, String hint)
    {
      return new Var⟨STRING: ToCppClassName(#constructor)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩(ctx.makeGlobalName(hint));
    }⟧
*/

/* Generate base lookup method (the 'as' method) for the given form. */
func CppMethodAs(String, List<Core_csortvars_sort>, Core_cform_sort, Bool) -> Text4_text_sort
  rule CppMethodAs(#sortname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧, #header)
  → text⟦
    †⟨TextIf(#header, ()->text⟦virtual⟧)⟩ Optional<†⟨FormCppClassName(#CONSTRUCTOR)⟩†⟨MaybeCppTypeArguments(#csortvars?)⟩> †⟨CppFormQualifier(#sortname, #csortvars?, #header)⟩†⟨CppAsMethodName(#CONSTRUCTOR)⟩(Context context)†⟨
    If<Text4_text_sort>(GenBody(#csortvars?, #header), ()->text⟦{
       return Optional<†⟨FormCppClassName(#CONSTRUCTOR)⟩†⟨MaybeCppTypeArguments(#csortvars?)⟩>::nullopt;
    }⟧, ()->text⟦;⟧)⟩⟧

/*
func FormToMethodMemoAs(String, List<Core_csortvars_sort>, Core_cform_sort) -> Text4_text_sort
  rule FormToMethodMemoAs(#enumname, #csortvars?, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)
  → text⟦
   @Override
   final public †⟨EValueClassName(#CONSTRUCTOR)⟩†⟨SortParamToTypeParam(#csortvars?, FALSE)⟩ †⟨MethodNameAs(#CONSTRUCTOR)⟩(Context context)
   {
     return eval(context).†⟨MethodNameAs(#CONSTRUCTOR)⟩(context);
   }⟧

 rule FormToMethodMemoAs(#enumname, #csortvars?, cform⟦ allows-variable ⟧)
 → text⟦⟧
*/


/* Generate constructor. */
func CppFormConstructor(String, List<Core_csortvars_sort>, String, List<Core_csorts_sort>, Bool) -> Text4_text_sort
  rule CppFormConstructor(#sortname, #csortvars?, #formname, #csorts?, #header)
  → text⟦
    †⟨CppQualifier(#formname, #csortvars?, #header)⟩†⟨FormCppClassName(#formname)⟩(†⟨MaybeCppFormalParams(#csorts?, text⟦⟧, FALSE)⟩)†⟨
    If<Text4_text_sort>(GenBody(#csortvars?, #header),
      ()->text⟦†⟨TextIf(HasSorts(#csorts?),
        ()->text⟦: †⟨MaybeCppClassFields(#csorts?, (isvar type index subindex)->CppInitField(isvar, type, index, subindex))⟩⟧)⟩{}⟧,
      ()->text⟦;⟧)⟩⟧

/* Generate overridden lookup method (the 'as' method) for the given form. Generate body only if asked for. */
func CppFormMethodAs(String, List<Core_csortvars_sort>, String, Bool) -> Text4_text_sort
  rule CppFormMethodAs(#sortname, #csortvars?, #formname, #header)
  → text⟦
    Optional<†⟨FormCppClassName(#formname)⟩†⟨MaybeCppTypeArguments(#csortvars?)⟩> †⟨CppFormQualifier(#formname, #csortvars?, #header)⟩†⟨CppAsMethodName(#formname)⟩(Context context)†⟨
    If<Text4_text_sort>(GenBody(#csortvars?, #header), ()->text⟦{
       return make_optional<†⟨FormCppClassName(#formname)⟩†⟨MaybeCppTypeArguments(#csortvars?)⟩>(*this);
    }⟧, ()->text⟦;⟧)⟩⟧

/* Generate overridden copy method for the given form. Generate body only if asked for. */
func CppFormMethodCopy(String, List<Core_csortvars_sort>, String, Bool) -> Text4_text_sort
  rule CppFormMethodCopy(#sortname, #csortvars?, #formname, #header)
  → text⟦
    Term †⟨CppQualifier(#formname, #csortvars?, #header)⟩Copy(Context context)†⟨
    If<Text4_text_sort>(GenBody(#csortvars?, #header), ()->text⟦{
       return (*new †⟨FormCppClassName(#formname)⟩†⟨MaybeCppTypeArguments(#csortvars?)⟩());
    }⟧, ()->text⟦;⟧)⟩⟧


/* Generate getValue method for the given form. Generate body only if asked for. */
func CppFormGetValue(String, List<Core_csortvars_sort>, String,  List<Core_csorts_sort>, Bool) -> Text4_text_sort
  rule CppFormGetValue(#sortname, #csortvars?, #formname, #csorts?, #header)
  → MaybeCppClassFields(#csorts?, (isvar type index subindex)->CppGetValue(isvar, type, index, subindex, GenBody(#csortvars?, #header), CppFormQualifier(#formname, #csortvars?, #header)))

/* GetValue generator */
func CppGetValue(Bool, Text4_text_sort, Numeric, Numeric, Bool, Text4_text_sort) -> Text4_text_sort
  rule CppGetValue(FALSE, #type, #index, #subindex, #genbody, #qualifier)
  → text⟦†⟨#type⟩& †⟨#qualifier⟩getValue†⟨NumberToText(#index)⟩(Context ctx, bool mustforce)†⟨
      If<Text4_text_sort>(#genbody, ()->text⟦{
        if (mustforce)
         †⟨FieldName(#index)⟩ = force(ctx, †⟨FieldName(#index)⟩);
        return †⟨FieldName(#index)⟩;
      }⟧, ()->text⟦;⟧)⟩⟧

  rule CppGetValue(TRUE, #type, #index, #subindex, #genbody, #qualifier)
  → text⟦†⟨#type⟩& †⟨#qualifier⟩getVar†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩()†⟨
      If<Text4_text_sort>(#genbody, ()->text⟦{
        return †⟨VarFieldName(#index, #subindex)⟩;
      }⟧, ()->text⟦;⟧)⟩⟧

// --- Generate code for class field declarations, initialization, lookup, and update

/* Generic form sorts traversal */
func MaybeCppClassFields(List<Core_csorts_sort>, (Bool Text4_text_sort Numeric Numeric)->Text4_text_sort) -> Text4_text_sort
  rule MaybeCppClassFields(csorts?⟦⟧, #print)
  → text⟦⟧

  rule MaybeCppClassFields(csorts?⟦ ( ##csort* ) ⟧, #print)
  → CppClassFields(#csort*, 1, #print)

func CppClassFields(List<Core_csort_sort>, Numeric, (Bool Text4_text_sort Numeric Numeric)->Text4_text_sort) -> Text4_text_sort
  rule CppClassFields(csort*⟦⟧, #index, #print)
  → text⟦⟧

  rule CppClassFields(csort*⟦ ##csort ##csort* ⟧, #index, #print)
  → text⟦†⟨CppClassField(CppTypes(#csort), #index, 1, #print)⟩†⟨CppClassFields(#csort*, Plus(#index, 1), #print)⟩⟧

func CppClassField(List<Text4_text_sort>, Numeric, Numeric, (Bool Text4_text_sort Numeric Numeric)->Text4_text_sort) -> Text4_text_sort
  rule CppClassField(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex, #print)
  → #print(FALSE, #type, #index, #subindex)

  rule CppClassField(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex, #print)
  → text⟦†⟨#print(TRUE, #type, #index, #subindex)⟩†⟨CppClassField(#types, #index, Plus(#subindex, 1), #print)⟩⟧

func FieldName(#index: Numeric) -> Text4_text_sort
→ text⟦field†⟨NumberToText(#index)⟩⟧

func VarFieldName(#index: Numeric, #subindex: Numeric) -> Text4_text_sort
→ text⟦field†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩⟧

/* Print separator when not first field */
func FieldSep(#sep: Text4_text_sort, #index: Numeric, #subindex: Numeric) -> Text4_text_sort
→ TextIf(Not(And(NumberEqual(#index, 1), NumberEqual(#subindex, 1))), ()->#sep)

/* Field initialization helper */
func CppInitField(Bool, Text4_text_sort, Numeric, Numeric) -> Text4_text_sort
rule CppInitField(FALSE, #type, #index, #subindex) → text⟦†⟨FieldSep(text⟦, ⟧, #index, #subindex)⟩†⟨FieldName(#index)⟩(†⟨ParamName(#index)⟩)⟧
rule CppInitField(TRUE, #type, #index, #subindex)  → text⟦†⟨FieldSep(text⟦, ⟧, #index, #subindex)⟩†⟨VarFieldName(#index, #subindex)⟩(†⟨VarParamName(#index, #subindex)⟩)⟧

// --- Function translation functions

func CppFunctionDecl(#env: {String : EnvEntry}, #key: String, #header :Bool) -> Text4_text_sort
→ CppFunctionDecl2(#env, UnSOME<Core_cdecl_sort>(GetFuncSort(GetContent(#env), #key)), #header)

func CppFunctionDecl2({String : EnvEntry}, Core_cdecl_sort, Bool) -> Text4_text_sort
rule CppFunctionDecl2(#env, cdecl⟦ ##canno* ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧, #header)
→ Then<{String : EnvEntry} Text4_text_sort>(SetFnAnno(#env, #canno*), (env)->
  Then<{String : EnvEntry} Text4_text_sort>(SetContext(env, text⟦ctx⟧, 1), (env)->text⟦
   †⟨CppTemplatePrefix(#csortvars?)⟩
   †⟨CppTypeRef(#csort)⟩ †⟨CppFnName(#CONSTRUCTOR)⟩(Context ctx†⟨CppMaybeFunctionParams(env, #csorts?, (env) ->
      CppMaybeBody(env, #CONSTRUCTOR, GenBody(#csortvars?, #header)))⟩⟧ // missing )
  ))

func CppMaybeFunctionParams({String : EnvEntry}, List<Core_csorts_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
   rule CppMaybeFunctionParams(#env, csorts?⟦⟧, #cont)
   → #cont(#env)

   rule CppMaybeFunctionParams(#env, csorts?⟦ ( ##csort* ) ⟧, #cont)
   → CppFunctionParams(NewParams(#env), #csort*, #cont)

/* Generate method signature and record the argument names in the environment, keeping them in order */
func CppFunctionParams({String : EnvEntry}, List<Core_csort_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppFunctionParams(#env, csort*⟦ ⟧, #cont)
   → #cont(#env)

  rule CppFunctionParams(#env, csort*⟦ ##csort ##csort* ⟧, #cont)
  → CppFunctionParam(#env, CppTypes(#csort), #csort, (env) -> CppFunctionParams(env, #csort*, #cont))

func CppFunctionParam({String : EnvEntry}, List<Text4_text_sort>, Core_csort_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // Monomorphic sort
  rule CppFunctionParam(#env, Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), csort⟦ ##CONSTRUCTOR ##csorts? ⟧, #cont)
  → text⟦, †⟨#type⟩& ⟨STRING: value:String⟩†⟨#cont(AddParam(#env, text⟦⟨STRING: value⟩⟧, csort⟦ ##CONSTRUCTOR ##csorts? ⟧))⟩⟧

  // Sort variable
  rule CppFunctionParam(#env, Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), csort⟦ ##VARIABLE ⟧, #cont)
  → text⟦, †⟨#type⟩& ⟨STRING: value:String⟩†⟨#cont(AddParam(#env, text⟦⟨STRING: value⟩⟧, csort⟦ ##VARIABLE ⟧))⟩⟧

  // Syntactic variable sort
 rule CppFunctionParam(#env, Cons(#type:Text4_text_sort, #types: List<Text4_text_sort>), csort⟦ [ ##csort ] ##csort2 ⟧, #cont)
 → text⟦, †⟨#type⟩ ⟨STRING: var:String⟩†⟨
     CppFunctionParam(AddParam(#env, text⟦⟨STRING: var⟩⟧, #csort), #types, #csort2, #cont)⟩⟧

 // Formal parameter sort
 rule CppFunctionParam(#env, #types, csort⟦ ( ##csort ) ##csort2 ⟧, #cont)
 → CppFunctionParam(#env, #types, #csort2, #cont)

 rule CppFunctionParam(#env, Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), csort⟦ { ##cmapsort* } ⟧, #cont)
 → text⟦, †⟨#type⟩ ⟨STRING: map:String⟩†⟨
     #cont(AddParam(#env, text⟦⟨STRING: map⟩⟧, csort⟦ { ##cmapsort* } ⟧))⟩⟧

 rule CppFunctionParam(#env, #types, csort⟦ data ##csort ⟧, #cont)
 → CppFunctionParam(#env, #types, #csort, #cont)

 rule CppFunctionParam(#env, #types, csort⟦ thunk ##csort ⟧, #cont)
 → CppFunctionParam(#env, #types, #csort, #cont)

/* Generate function body */
func CppMaybeBody({String : EnvEntry}, String, Bool) -> Text4_text_sort
  rule CppMaybeBody(#env, #key, FALSE) → text⟦);⟧
  rule CppMaybeBody(#env, #key, TRUE)  → text⟦) {†⟨CppBody(#env, GetRulesForKeyC(GetContent(#env), #key))⟩}⟧


func CppBody({String : EnvEntry}, Option<List<Core_cdecl_sort>>) -> Text4_text_sort

// No rules: it must be an external function (not yet checked but should)
  rule CppBody(#env, NONE)
  → text⟦TODO EXTERN⟧

  // At least one rule: not external
  rule CppBody(#env, SOME(#rules:List<Core_cdecl_sort>))
  → text⟦
      †⟨TextMapFold<Core_cdecl_sort>((r) -> CppBodyRule(NewMetas(NewVars(#env)), r), #rules)⟩
      †⟨TextIf(Not(HasAnnotation("Fallback", GetFnAnno(#env))), ()->text⟦throw std::runtime_error("Missing case");⟧ )⟩⟧

// --- Start method body

func CppBodyRule({String : EnvEntry}, Core_cdecl_sort) -> Text4_text_sort

  rule CppBodyRule(#env, cdecl⟦ rule ##CONSTRUCTOR → ##cterm ⟧)
  → CppContractum(#env, #cterm)

  rule CppBodyRule(#env, cdecl⟦ rule ##CONSTRUCTOR ( ##cterm* ) → ##cterm2 ⟧)
  → CppPattern(#env, #cterm*, #cterm2)

// --- Pattern matching

func CppPattern({String : EnvEntry}, List<Core_cterm_sort>, Core_cterm_sort) -> Text4_text_sort
rule CppPattern(#env, #cterms, #contractum) → CppCasePattern(#env, #cterms, #contractum)

// Data sort helper indicating whether the current term is a method parameter, or an argument (local variable).
enum Storage | PARAMETER | ARGUMENT

// Iterate over top-level pattern arguments
func CppCasePattern({String : EnvEntry}, List<Core_cterm_sort>, Core_cterm_sort) -> Text4_text_sort

  rule CppCasePattern(#env, cterm*⟦ ⟧, #contractum)
  → CppContractum(#env, #contractum)

  rule CppCasePattern(#env, cterm*⟦ ##cterm ##cterm* ⟧, #contractum)
  → CppPatternTerm(NextParam(#env), #cterm, CurrentParam(#env), SOME(CurrentParamSort(#env)), PARAMETER,
    (env) -> CppCasePattern(env, #cterm*, #contractum))

// --- Term pattern matching

func CppPatternTerm({String : EnvEntry}, Core_cterm_sort, Text4_text_sort /* Current term */,
                       Option<Core_csort_sort> /* Sort when known */, Storage, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternTerm(#env, cterm⟦ ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #term, #csort, #storage, #cont)
  → text⟦
      †⟨ForceParameter(#env, #term, #storage)⟩
      auto ⟨STRING: value:String⟩ = †⟨#term⟩.†⟨CppAsMethodName(#CONSTRUCTOR)⟩(†⟨GetContext(#env)⟩);
      if (⟨STRING: value⟩) {
        †⟨CppPatternMaybeSubs(#env, #cterms?, text⟦⟨STRING: value⟩⟧, MaybeFindFormC(GetContent(#env), #csort, #CONSTRUCTOR), #cont)⟩
      }⟧

  // TODO: check literal
  rule CppPatternTerm(#env, cterm⟦ ##cliteral ⟧, #term, #csort, #storage, #cont)
  → #cont(#env)

  // REVISIT: bound variable reordering, ie. (x)(y)#(y, x)
  // For now only accepts patterns of the form (x)...(y)#(x, ... y)
  rule CppPatternTerm(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #term, #csort, #storage, #cont)
  → text⟦†⟨CppPatternMaybeMetaArgs(#env, #METAVAR, #csubst?, #term, #csort, #cont)⟩⟧

  rule CppPatternTerm(#env, cterm⟦ ##VARIABLE ⟧, #term, #csort, #storage, #cont)
  → CppPatternVariable(MaybeGetVar(#env, #VARIABLE), #env, #VARIABLE, #term, #cont)

  rule CppPatternTerm(#env, cterm⟦ [ v ##csortanno? ] ##cterm ⟧, #term, #csort, PARAMETER, #cont)
  //rule CppPatternTerm(#env, Core_cterm_A6(#csortanno?:List<Core_csortanno_sort>, [x] -> #cterm[x]: Core_cterm_sort), #term, #csort, PARAMETER, #cont)
  → CppPatternTerm(NextParam(AddVar(#env, var:String, Bound(#term, MaybeSortAnnoToSort(#csortanno?)))), #cterm[var], CurrentParam(#env), SOME(CurrentParamSort(#env)), PARAMETER, #cont)

  rule CppPatternTerm(#env, cterm⟦ [ v ##csortanno? ] ##cterm ⟧, #term, #csort, ARGUMENT, #cont)
  //rule CppPatternTerm(#env, Core_cterm_A6(#csortanno?:List<Core_csortanno_sort>, [x] -> #cterm[x]: Core_cterm_sort), #term,  #csort, ARGUMENT, #cont)
  → text⟦
      Variable ⟨STRING: boundvar:String⟩ = †⟨GetParent(#env)⟩.getVar†⟨NumberToText(GetSubIndex(#env))⟩_†⟨NumberToText(GetSubBinderIndex(#env))⟩();†⟨
      CppPatternTerm(IncSubBinderIndex(AddVar(#env, var:String, Bound(text⟦⟨STRING: boundvar⟩⟧, MaybeSortAnnoToSort(#csortanno?)))), #cterm[var], #term, #csort, ARGUMENT, #cont)⟩⟧

  //rule CppPatternTerm(#env, cterm⟦ ( ##VARIABLE ##csortanno? ) ##cterm ⟧, #term, #storage, #cont)
  rule CppPatternTerm(#env, Core_cterm_A7(#csortanno?:List<Core_csortanno_sort>, [x] -> #cterm[x]: Core_cterm_sort), #term, #csort, #storage, #cont)
  → CppPatternTerm(#env, #cterm[var:String], #term, #csort, #storage, #cont)

// Pattern matching on construction arguments.
func CppPatternMaybeSubs( {String : EnvEntry}, List<Core_cterms_sort>, Text4_text_sort, Option<Pair<Core_csort_sort Core_cform_sort>>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMaybeSubs(#env, cterms?⟦⟧, #term, #cform, #cont)
  → #cont(#env)

  rule CppPatternMaybeSubs(#env, cterms?⟦()⟧, #term, #cform, #cont)
  → #cont(#env)

  rule CppPatternMaybeSubs(#env, cterms?⟦ ( ##cterm* ) ⟧, #term, SOME(Pair<Core_csort_sort Core_cform_sort>::PairCons(#csort:Core_csort_sort, cform⟦ ##CONSTRUCTOR ( ##csort* ) ⟧)), #cont)
  → CppPatternSubs(#env, #cterm*, #term, 1, SOME(#csort*), #cont)

  rule CppPatternMaybeSubs(#env, cterms?⟦ ( ##cterm* ) ⟧, #term, NONE, #cont)
  → CppPatternSubs(#env, #cterm*, #term, 1, NONE, #cont)

  func CppPatternSubs( {String : EnvEntry}, List<Core_cterm_sort>,
                     Text4_text_sort /* parent term */, Numeric /* Current subindex */, Option<List<Core_csort_sort>>, /* sub sorts, if known */
                     ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternSubs(#env, cterm*⟦⟧,  #term, #index, #csort*, #cont)
  → #cont(#env)

  rule CppPatternSubs(#env, cterm*⟦ ##cterm ##cterm* ⟧, #term, #index, #csort*, #cont)
  → text⟦
      auto& ⟨STRING: sub:String⟩ = †⟨#term⟩.value().getValue†⟨NumberToText(#index)⟩(†⟨GetContext(#env)⟩, true);†⟨
      CppPatternTerm(SetSubBinderIndex(SetParent(SetSubIndex(#env, #index), #term), 1),
                  #cterm, text⟦⟨STRING: sub⟩⟧, SubSort(#env, #cterm, #csort*), ARGUMENT,
                  (x) -> CppPatternSubs(x, #cterm*, #term, NumberPlus(#index, 1), Maybe<List List>((x)->Tail<Core_csort_sort>(x), #csort*), #cont))⟩⟧


  // --- Variable pattern matching outside of meta

func CppPatternVariable(Option<VarEntry>, {String : EnvEntry}, String, Text4_text_sort /* Current term */, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // First variable occurrence: the term is a variable use.
  rule CppPatternVariable(NONE, #env, #variable, #term, #cont)
  → text⟦
      Variable ⟨STRING: var:String⟩ = †⟨#term⟩.variable();†⟨#cont(AddVar(#env, #variable, Free(text⟦⟨STRING: var⟩⟧, NONE)))⟩⟧

  // Bound variable
  // TODO: update term's parent with evaluated term.
  // TODO: release acquired references.
  rule CppPatternVariable(SOME(VarEntry::Bound(#Cppvar:Text4_text_sort)), #env, #variable, #term, #cont)
  → text⟦
      †⟨#term⟩ = force(context, †⟨#term⟩);
      if (isVariableUse(†⟨#term⟩) && †⟨#Cppvar⟩ != †⟨#term⟩.variable()) {
        †⟨#cont(#env)⟩
      }⟧

  // --- pattern matching inside meta

// Iterate over meta arguments and find corresponding bound variables, and update environment
func CppPatternMaybeMetaArgs({String : EnvEntry}, String, List<Core_csubst_sort>, Text4_text_sort /* Current term */, Option<Core_csort_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppPatternMaybeMetaArgs(#env, #metavar, csubst?⟦⟧, #term, #csort, #cont)
  → #cont(AddMeta(#env, #metavar, #term, ()))

  // meta substitution
  rule CppPatternMaybeMetaArgs(#env, #metavar, csubst?⟦ [ ##cterm* ] ⟧, #term, #csort, #cont)
  → #cont(AddMeta(#env, #metavar, #term, Map<Core_cterm_sort Text4_text_sort>((x) -> CppFindBoundVar(#env, x), #cterm*)))

  func CppFindBoundVar( {String : EnvEntry},Core_cterm_sort) -> Text4_text_sort

  rule CppFindBoundVar(#env, cterm⟦ ##VARIABLE ⟧)
  → GetVar(#env, #VARIABLE)

  // Interpreter does not handle Fallback
  //-(Fallback):
  //CppFindBoundVar(#env, #cterm)
  //→ $(Error, $(:, "Invalid argument in metavariable: ", $(Show, #cterm)))

  //  --------- Helper function for pattern matching

  /* Generate force call if term is a parameter */
  func ForceParameter({String : EnvEntry}, Text4_text_sort, Storage) -> Text4_text_sort
    rule ForceParameter(#env, #term, PARAMETER) →  text⟦†⟨#term⟩ = force(†⟨GetContext(#env)⟩, †⟨#term⟩);⟧
    rule ForceParameter(#env, #term, #storage)  →  text⟦⟧

  /* Get sub sort. Get it from term and if not available on sort */
  func SubSort(#env: {String : EnvEntry}, #cterm: Core_cterm_sort, #csorts?: Option<List<Core_csort_sort>>) -> Option<Core_csort_sort>
  → SubSort2(SubSortFromTerm(#env, #cterm), #csorts?)

  func SubSort2(Option<Core_csort_sort>, Option<List<Core_csort_sort>>) -> Option<Core_csort_sort>
    rule SubSort2(SOME(#csort:Core_csort_sort), #)       → SOME(#csort)
    rule SubSort2(NONE, NONE)                            → NONE
    rule SubSort2(NONE, SOME(csort*⟦ ##csort ##csort* ⟧)) → SOME(#csort)

  func SubSortFromTerm({String : EnvEntry}, Core_cterm_sort) -> Option<Core_csort_sort>

    // TODO: support for multiple sort qualifiers
    rule SubSortFromTerm(#env, cterm⟦ ##csort :: ##csortqualifier* ##CONSTRUCTOR ##csortargs?  ##cterms? ##csortanno? ⟧)
    → SOME(#csort)

    rule SubSortFromTerm(#env, cterm⟦ ##CONSTRUCTOR ##csortargs?  ##cterms? ##csortanno? ⟧)
    → NONE

    rule SubSortFromTerm(#env, cterm⟦ ##STRING ⟧)
    → SOME(csort⟦ String ⟧)

    rule SubSortFromTerm(#env, cterm⟦ ##NUMBER ⟧)
    → SOME(csort⟦ Numeric⟧)

    rule SubSortFromTerm(#env, cterm⟦ ##VARIABLE ⟧)
    → SubSortFromVar(MaybeGetVar(#env, #VARIABLE), #VARIABLE)

    rule SubSortFromTerm(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧)
    → MaybeSortAnnoToSort(#csortanno?)

    // TODO: maybe error?
    rule SubSortFromTerm(#env, cterm⟦ [ x ##csortanno? ] ##cterm ⟧)
    //rule SubSortFromTerm(#env, Core_cterm_A6(#csortanno?:List<Core_csortanno_sort>, [x] -> #cterm[x] : Core_cterm_sort))
    → SubSortFromTerm(#env, #cterm[var:String])

    // TODO: maybe error?
    rule SubSortFromTerm(#env, cterm⟦ ( f ##csortanno? ) ##cterm ⟧)
    //rule SubSortFromTerm(#env, Core_cterm_A7(#csortanno?:List<Core_csortanno_sort>, [x] -> #cterm[x] : Core_cterm_sort))
    → SubSortFromTerm(#env, #cterm[var:String])

  func SubSortFromVar(Option<VarEntry>, String) -> Option<Core_csort_sort>
    rule SubSortFromVar(NONE, #var)                      → NONE
    rule SubSortFromVar(SOME(#varEntry:VarEntry), #var)  → UnVarSort(#varEntry)

// ----- Contraction

func CppContractum(#env: {String : EnvEntry}, #term: Core_cterm_sort) -> Text4_text_sort
→ CppStatementTerm(SetTail(#env, TRUE), #term)

func CppStatementTerm(#env: {String : EnvEntry}, #cterm: Core_cterm_sort) -> Text4_text_sort
→ text⟦†⟨CppFreshesTerm(SetCounter(#env, 0), #cterm, (env) ->
     text⟦†⟨TextIf(GetTail(env), ()->text⟦return ⟧)⟩†⟨CppExprTerm(SetCounter(env, 0), #cterm, (env) -> text⟦⟧)⟩;⟧)⟩⟧

// ---- Generate fresh variable - Only in Cpp statement mode

func CppFreshesTerm({String : EnvEntry}, Core_cterm_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  rule CppFreshesTerm(#env, cterm⟦ ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #cont)
  → CppFreshesMaybeTerms(#env, #cterms?, #cont)

  rule CppFreshesTerm(#env, cterm⟦ ##VARIABLE ##csortanno? ⟧, #cont)
  → CppFreshesVariable(#env, MaybeGetVar(#env, #VARIABLE), #VARIABLE, #csortanno?, #cont)

  rule CppFreshesTerm(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #cont)
  → CppFreshesMaybeTerms(#env, #cterms?, (env) -> CppFreshesMaybeSubst(env, #csubst?, #cont))

  rule CppFreshesTerm(#env, cterm⟦ [ x ##csortanno? ] ##cterm⟧, #cont)
  → CppFreshesVariable(#env, NONE, var:String, #csortanno?, (env) -> CppFreshesTerm(env, #cterm[var], #cont))

  // TODO: track var to avoid generating dummy fresh variables
  rule CppFreshesTerm(#env, cterm⟦ ( f ##csortanno? ) ##cterm ⟧, #cont) → CppFreshesTerm(#env, #cterm[var:String], #cont)
  rule CppFreshesTerm(#env, cterm⟦ thunk ##cterm ⟧, #cont)              → CppFreshesTerm(#env, #cterm, #cont)
  rule CppFreshesTerm(#env, cterm⟦ ##cliteral ⟧, #cont)                 → #cont(#env)

func CppFreshesMaybeTerms({String : EnvEntry}, List<Core_cterms_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
  rule CppFreshesMaybeTerms(#env, cterms?⟦⟧, #cont)                      → #cont(#env)
  rule CppFreshesMaybeTerms(#env, cterms?⟦ () ⟧, #cont)                  → #cont(#env)
  rule CppFreshesMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧, #cont)        → CppFreshesTerms(#env, #cterm*, #cont)

func CppFreshesTerms({String : EnvEntry}, List<Core_cterm_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
  rule CppFreshesTerms(#env, cterm*⟦⟧, #cont)                   → #cont(#env)
  rule CppFreshesTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, #cont) → CppFreshesTerm(#env, #cterm, (env) -> CppFreshesTerms(env, #cterm*, #cont))

func CppFreshesMaybeSubst({String : EnvEntry}, List<Core_csubst_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
  rule CppFreshesMaybeSubst(#env, csubst?⟦⟧, #cont)               → #cont(#env)
  rule CppFreshesMaybeSubst(#env, csubst?⟦ [ ##cterm* ] ⟧, #cont) → CppFreshesTerms(#env, #cterm*, #cont)

func CppFreshesVariable({String : EnvEntry}, Option<VarEntry>, String, List<Core_csortanno_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // untyped fresh var
  rule CppFreshesVariable(#env, NONE, #var, csortanno?⟦  ⟧, #cont)
  → text⟦
   VarStringTerm& fresh†⟨NumberToText(GetCounter(#env))⟩ = varStringTerm(†⟨Text-QuoteEscape(Show<String>(#var))⟩);†⟨
     #cont(IncCounter(AddVar(#env, #var, Fresh(text⟦fresh†⟨NumberToText(GetCounter(#env))⟩⟧, NONE))))⟩⟧

  // New typed fresh variable
  rule CppFreshesVariable(#env, NONE, #var, csortanno?⟦ : ##csort ⟧, #cont)
  → text⟦
   Var†⟨CppType(#csort)⟩& fresh†⟨NumberToText(GetCounter(#env))⟩ = var†⟨CppType(#csort)⟩(†⟨GetContext(#env)⟩, †⟨Text-QuoteEscape(Show<String>(#var))⟩);⟨
     #cont(IncCounter(AddVar(#env, #var, Fresh(text⟦fresh†⟨NumberToText(GetCounter(#env))⟩⟧, SOME(#csort)))))⟩⟧

  // Variable already exists
  rule CppFreshesVariable(#env, SOME(#:VarEntry), #var, #csortanno?, #cont)
  → #cont(#env)

// ---- Generate term code - C++ expression mode

func CppExprTerm({String : EnvEntry}, Core_cterm_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 rule CppExprTerm(#env, cterm⟦ ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #cont)
 → CppExprConstruction(#env, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #cont)

 rule CppExprTerm(#env, cterm⟦ ##cliteral ⟧, #cont)
 → text⟦
     †⟨CppExprLiteral(#cliteral)⟩†⟨#cont(#env)⟩⟧

 rule CppExprTerm(#env, cterm⟦ ##VARIABLE ##csortanno? ⟧, #cont)
 → CppExprMaybeVar(#env, MaybeGetVar(#env, #VARIABLE), #VARIABLE, #cont)

 rule CppExprTerm(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #cont)
 → CppExprMeta(#env, #METAVAR, #cterms?, #csubst?, #cont)

 rule CppExprTerm(#env, cterm⟦ [ x ##csortanno? ] ##cterm ⟧, #cont)
 → text⟦
     fresh†⟨NumberToText(GetCounter(#env))⟩, †⟨CppExprTerm(AddVar(IncCounter(#env), var:String, Fresh(text⟦fresh†⟨NumberToText(GetCounter(#env))⟩⟧, MaybeSortAnnoToSort(#csortanno?))), #cterm[var], #cont)⟩⟧

 rule CppExprTerm(#env, cterm⟦ ( f ##csortanno? ) ##cterm ⟧, #cont)
 → text⟦closure(†⟨CppExprLambda(#env, cterm⟦ ( f ##csortanno? ) ##cterm ⟧, #cont)⟩⟧

 rule CppExprTerm(#env, cterm⟦ thunk ##cterm ⟧, #cont)
 → text⟦thunk(†⟨GetContext(NewContext(#env))⟩ -> ⟨CppExprTerm(NewContext(#env), #cterm, (env) -> text⟦)⟨#cont(env)⟩⟧)⟩⟧

// ---- construction expression

func CppExprConstruction({String : EnvEntry}, String,  List<Core_csortargs_sort>, List<Core_cterms_sort>, List<Core_csortanno_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 rule CppExprConstruction(#env, #constructor, #csortargs?, #cterms?, #csortanno?, #cont)
 → text⟦†⟨CppFnName(#constructor)⟩(†⟨GetContext(#env)⟩†⟨CppExprMaybeTerms(#env, #cterms?, #cont)⟩⟧

func CppExprMaybeTerms({String : EnvEntry}, List<Core_cterms_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 rule CppExprMaybeTerms(#env, cterms?⟦⟧, #cont)
 → text⟦)†⟨#cont(#env)⟩⟧

 rule CppExprMaybeTerms(#env, cterms?⟦()⟧, #cont)
 → text⟦)†⟨#cont(#env)⟩⟧

 rule CppExprMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧, #cont)
 → CppExprTerms(#env, #cterm*, #cont)

func CppExprTerms({String : EnvEntry}, List<Core_cterm_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort
 rule CppExprTerms(#env, cterm*⟦⟧, #cont)
 → text⟦)†⟨#cont(#env)⟩⟧

 rule CppExprTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, #cont)
 → text⟦, †⟨CppExprTerm(#env, #cterm, (env) -> CppExprTerms(env, #cterm*, #cont))⟩⟧

// --- Variable

func CppExprMaybeVar({String : EnvEntry}, Option<VarEntry>, String, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 rule CppExprMaybeVar(#env, NONE, #svar, #cont) // Fresh variable must have been declared
 → #cont(#env)

 rule CppExprMaybeVar(#env, SOME(VarEntry::Formal(#var:Text4_text_sort, #type:Option<Core_csort_sort>)), #svar, #cont)
 → text⟦†⟨#var⟩†⟨#cont(#env)⟩⟧

 // fallback
 rule CppExprMaybeVar(#env, SOME(#varEntry:VarEntry), #svar, #cont)
 → text⟦†⟨UnVarVar(#varEntry)⟩.use()†⟨#cont(#env)⟩⟧

// ----  metavar expression

func CppExprMeta({String : EnvEntry}, String, List<Core_cterms_sort>, List<Core_csubst_sort>, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

  // TODO: check that metavar is defined

 // No arguments -> just return the metavariable.
 rule CppExprMeta(#env, #metavar, cterms?⟦⟧, csubst?⟦⟧, #cont)
 → text⟦†⟨GetMetaVar(#env, #metavar)⟩†⟨#cont(#env)⟩⟧

 // No arguments in parenthesis -> call lambda with no param.
 rule CppExprMeta(#env, #metavar, cterms?⟦ () ⟧, csubst?⟦⟧, #cont)
 → text⟦†⟨GetMetaVar(#env, #metavar)⟩.eval(context)†⟨#cont(#env)⟩⟧

 // Apply arguments -> call lambda
 rule CppExprMeta(#env, #metavar, cterms?⟦ ( ##cterm* ) ⟧, csubst?⟦⟧, #cont)
 → text⟦†⟨GetMetaVar(#env, #metavar)⟩.eval(†⟨GetContext(#env)⟩†⟨CppExprTerms(#env, #cterm*, #cont)⟩⟧

 // Substitution
 rule CppExprMeta(#env, #metavar, cterms?⟦⟧, csubst?⟦ [ ##cterm* ] ⟧, #cont)
 → text⟦subst(†⟨GetContext(#env)⟩, †⟨GetMetaVar(#env, #metavar)⟩†⟨CppExprMetaArgs(#env, GetMetaArgs(#env, #metavar), #cterm*, #cont)⟩⟧

 // TODO: call and subsitution

func CppExprMetaArgs({String : EnvEntry}, List<Text4_text_sort> /* pattern args */, List<Core_cterm_sort> /* contraction args */,
                    ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 rule CppExprMetaArgs(#env, (), #args,  #cont)
 → text⟦)†⟨#cont(#env)⟩⟧

 rule CppExprMetaArgs(#env, Cons(#binder:Text4_text_sort,  #binders: List<Text4_text_sort>), Cons(#arg:Core_cterm_sort, #args:List<Core_cterm_sort>), #cont)
 → text⟦,†⟨#binder⟩,†⟨CppExprTerm(#env, #arg, (env) -> CppExprMetaArgs(env, #binders, #args, #cont))⟩⟧

// ---- lambda expression

func CppExprLambda({String : EnvEntry}, Core_cterm_sort, ({String : EnvEntry}) -> Text4_text_sort) -> Text4_text_sort

 rule CppExprLambda(#env, cterm⟦ ( f ##csortanno? ) ##cterm ⟧, #cont)
 → CppExprLambda(#env, #cterm[var], #cont)

 // TODO: captures
 rule CppExprLambda(#env, cterm⟦ ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #cont)
 → text⟦&†⟨CppConsMethodName(#CONSTRUCTOR)⟩)†⟨#cont(#env)⟩⟧

  rule CppExprLambda(#env, #cterm, #cont)
  → Error<Text4_text_sort>("Internal Error: Invalid lambda expression. Lambda must be of the form (x .. y) -> C(x .. y, #1 .. #n)")

// --- Literal

func CppExprLiteral(Core_cliteral_sort) -> Text4_text_sort
  rule CppExprLiteral(cliteral⟦ ##STRING ⟧) → text⟦stringTerm(†⟨Text-QuoteEscape(#STRING)⟩)⟧
  rule CppExprLiteral(cliteral⟦ ##NUMBER ⟧) → text⟦doubleTerm(⟨STRING: #NUMBER⟩)⟧

// --- Sort translation functions

/* Generate template prefix for given sort variables */
func CppTemplatePrefix(List<Core_csortvars_sort>) -> Text4_text_sort
  rule CppTemplatePrefix(csortvars?⟦⟧) → text⟦⟧

  rule CppTemplatePrefix(csortvars?⟦ ∀ ##variable_TOK+ . ⟧)
  → text⟦template <†⟨CppTypeParameters(#variable_TOK+)⟩>⟧

/* Generate comma-seperated list of type parameters */
func CppTypeParameters(#vars: List<String>) -> Text4_text_sort
→ TextFold(Map<String Text4_text_sort>((var) -> text⟦typename ⟨STRING: var⟩⟧, #vars), text⟦, ⟧)

/* Generate comma-separated list of type arguments from sort variables, if any*/
func MaybeCppTypeArguments(List<Core_csortvars_sort>) -> Text4_text_sort
  rule MaybeCppTypeArguments(csortvars?⟦⟧) → text⟦⟧
  rule MaybeCppTypeArguments(csortvars?⟦ ∀ ##variable_TOK+ . ⟧) → text⟦<†⟨CppTypeArguments(#variable_TOK+)⟩>⟧

/* Generate comma-separated list of type arguments from sort variables */
func CppTypeArguments(#vars: List<String>) -> Text4_text_sort
→ TextFold(Map<String Text4_text_sort>((var) -> text⟦⟨STRING: var⟩⟧, #vars), text⟦, ⟧)

/* Generate (possibility dependent) type name corresponding to the given data sort type */
func CppTypeName(List<Core_csortvars_sort>, String) -> Text4_text_sort
  rule CppTypeName(csortvars?⟦⟧, #sortname)
  → SortNameToCppClassNameRef(#sortname)

  //TODO: might need typename when occurs within a template class.
  rule CppTypeName(csortvars?⟦ ∀ ##variable_TOK+ . ⟧, #sortname)
  → text⟦†⟨SortNameToCppClassName(#sortname)⟩<†⟨CppTypeArguments(#variable_TOK+)⟩>&⟧

/* Generate arguments for template instantiation */
func MaybeCppTemplateArgs(List<Core_csorts_sort>) -> Text4_text_sort
    rule MaybeCppTemplateArgs(csorts?⟦ ⟧)
    → text⟦⟧

    rule MaybeCppTemplateArgs(csorts?⟦ ( ##csort* )⟧)
    → text⟦<†⟨TextFold(Map<Core_csort_sort Text4_text_sort>((csort) -> CppType(csort), #csort*), text⟦, ⟧)⟩>⟧

/* Convert list of sorts to a list of formal parameters or arguments. */
func MaybeCppFormalParams(List<Core_csorts_sort>, Text4_text_sort, Bool /* omit types */) -> Text4_text_sort
  rule MaybeCppFormalParams(csorts?⟦⟧, #sep, #isarg)
  → text⟦⟧

  rule MaybeCppFormalParams(csorts?⟦ ( ##csort*) ⟧, #sep, #isarg)
  → CppFormalParams(#csort*, 1, #sep, #isarg)

func CppFormalParams(List<Core_csort_sort>, Numeric, Text4_text_sort, Bool) -> Text4_text_sort
  rule CppFormalParams(csort*⟦⟧, #index, #sep, #isarg)
  → text⟦⟧

  rule CppFormalParams(csort*⟦ ##csort ##csort* ⟧, #index, #sep, #isarg)
  → text⟦†⟨#sep⟩†⟨CppFormalParam(CppTypes(#csort), #index, 1, #isarg)⟩†⟨CppFormalParams(#csort*, Plus(#index, 1), text⟦, ⟧, #isarg)⟩⟧

func CppFormalParam(List<Text4_text_sort>, Numeric, Numeric, Bool) -> Text4_text_sort
  rule CppFormalParam(Cons(#type:Text4_text_sort, List<Text4_text_sort>::Nil), #index, #subindex, #isarg)
  → text⟦†⟨If<Text4_text_sort>(#isarg, ()->text⟦⟧, ()->text⟦†⟨#type⟩& ⟧)⟩†⟨ParamName(#index)⟩⟧

  rule CppFormalParam(Cons(#type:Text4_text_sort, #types:List<Text4_text_sort>), #index, #subindex, #isarg)
  → text⟦†⟨If<Text4_text_sort>(#isarg, ()->text⟦⟧, ()->text⟦†⟨#type⟩& ⟧)⟩†⟨VarParamName(#index, #subindex)⟩, †⟨CppFormalParam(#types, #index, Plus(#subindex, 1), #isarg)⟩⟧

func ParamName(#index: Numeric) -> Text4_text_sort
→ text⟦param†⟨NumberToText(#index)⟩⟧

func VarParamName(#index: Numeric, #subindex: Numeric) -> Text4_text_sort
→ text⟦param†⟨NumberToText(#index)⟩_†⟨NumberToText(#subindex)⟩⟧

/* Translate TS sort to equivalent list of C++ types:
 * A list of types corresponding to syntactic variable sorts and a type for the last sort
 * Note: return a type, not a type reference
 */
func CppTypes(#csort: Core_csort_sort) -> List<Text4_text_sort>
→ CppTypes2(#csort, ())

func CppTypes2(Core_csort_sort, List<Text4_text_sort> /* formal params */) -> List<Text4_text_sort>

  rule CppTypes2(csort⟦ ##CONSTRUCTOR ##csorts? ⟧, ())
  → Cons(text⟦†⟨SortNameToCppClassName(CppFixupPrimitiveType(#CONSTRUCTOR))⟩†⟨MaybeCppTemplateArgs(#csorts?)⟩⟧, Nil)

  rule CppTypes2(csort⟦ ##CONSTRUCTOR ##csorts? ⟧, Cons(#formal:Text4_text_sort, #formals:List<Text4_text_sort>))
  → Cons(text⟦_Closure†⟨NumberToText(Plus(ListLength<Text4_text_sort>(#formals), 1))⟩<†⟨
       SortNameToCppClassName(CppFixupPrimitiveType(#CONSTRUCTOR))⟩&†⟨MaybeCppTemplateArgs(#csorts?) /* Return type */⟩, †⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* Formal params */⟩>⟧, Nil)

  rule CppTypes2(csort⟦ ##VARIABLE ⟧, ())
  → Cons(text⟦⟨STRING: #VARIABLE⟩⟧, Nil)

  rule CppTypes2(csort⟦ ##VARIABLE ⟧, Cons(#formal:Text4_text_sort, #formals:List<Text4_text_sort>))
  → Cons(text⟦_Closure†⟨NumberToText(Plus(ListLength<Text4_text_sort>(#formals), 1))⟩<⟨STRING: #VARIABLE /* Return type */⟩, †⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* Formal params */⟩>⟧, Nil)

  rule CppTypes2(csort⟦ [ ##csort ] ##csort2 ⟧, #formals)
  → Cons(text⟦_Var†⟨CppType(#csort)⟩⟧, CppTypes2(#csort2, #formals))

  rule CppTypes2(csort⟦ ( ##csort ) ##csort2 ⟧, #formals) // no higher-order csort for now.
  → CppTypes2(#csort2, Append<Text4_text_sort>(CppTypeRef(#csort), #formals))

  rule CppTypes2(csort⟦ { ##csort1 : ##csort2 } ⟧, ())
  → Cons(text⟦_MapTerm<†⟨CppType(#csort1)⟩,†⟨CppType(#csort2)⟩>⟧, Nil)

  rule CppTypes2(csort⟦ { ##cmapsort } ⟧, Cons(#formal:Text4_text_sort, #formals:List<Text4_text_sort>))
  → Cons(text⟦_Closure†⟨NumberToText(Plus(ListLength<Text4_text_sort>(#formals), 1))⟩<_MapTerm, †⟨
       TextFold(Cons(#formal, #formals), text⟦, ⟧) /* Formal params */⟩>⟧, Nil)

  rule CppTypes2(csort⟦ data ##csort ⟧, #formals)
  → CppTypes2(#csort, #formals)

  rule CppTypes2(csort⟦ thunk ##csort ⟧, #formals)
  → Cons(text⟦_LazyTerm<†⟨CppType(#csort)⟩>⟧, Nil)

/* Same as above, expect ignore syntactic variables */
func CppType(#csort: Core_csort_sort) -> Text4_text_sort
→ Last<Text4_text_sort>(CppTypes(#csort)) // TODO: could optimize

/* Same as above, but return a reference type */
func CppTypeRef(#csort: Core_csort_sort) -> Text4_text_sort
→ text⟦†⟨CppType(#csort)⟩&⟧

/* Same as above, expect maybe get a sort. Generate auto& when no type. */
func MaybeCppType(#csort?: Option<Core_csort_sort>) -> Text4_text_sort
→ IfPresent<Text4_text_sort Text4_text_sort>(Maybe<Core_csort_sort Text4_text_sort>((csort)->CppType(csort), #csort?),
    (type) -> type, () -> text⟦auto&⟧)

/* Rename builtin types to avoid conflict with C++ types */
func CppFixupPrimitiveType(#typename: String) -> String
→ If<String>(StringEqual(#typename, "String"), ()->"StringTerm",
    ()->If<String>(StringEqual(#typename, "Numeric"), ()->"DoubleTerm",
         ()->#typename))

// --- Basic conversion functions

/* Convert data sort name to corresponding C++ class name */
func SortNameToCppClassName(#name: String) -> Text4_text_sort
→ text⟦_⟨STRING: #name⟩⟧

/* Convert data sort name to equivalent C++ class name reference */
func SortNameToCppClassNameRef(#name: String) -> Text4_text_sort
→ text⟦_⟨STRING: #name⟩&⟧

/* Convert data form to corresponding C++ constructor method name */
func CppConsMethodName(#name: String) -> Text4_text_sort
→ text⟦⟨STRING: #name⟩⟧

/* Convert data form to corresponding C++ 'as' method name */
func CppAsMethodName(#name: String) -> Text4_text_sort
→ text⟦as⟨STRING: #name⟩⟧

/* Convert data form to corresponding C++ class name */
func FormCppClassName(#name: String) -> Text4_text_sort
→ text⟦_⟨STRING: #name⟩⟧

/* Convert data form to corresponding C++ class name reference */
func FormCppClassNameRef(#name: String) -> Text4_text_sort
→ text⟦_⟨STRING: #name⟩&⟧

/* Convert TS function name to corresponding C++ function name  */
func CppFnName(#name: String) -> Text4_text_sort
→ text⟦⟨STRING: #name⟩⟧

// --- helper function

/* Whether to generate function body */
func GenBody(#csortvars? : List<Core_csortvars_sort>, #header : Bool) -> Bool
→ Or(
    And(IsEmpty<Core_csortvars_sort>(#csortvars?), Not(#header)),
    And(IsNotEmpty<Core_csortvars_sort>(#csortvars?), #header))

/* Generate method qualifier, only for non-templated method in source file */
func CppQualifier(#sortname: String, #csortvars? : List<Core_csortvars_sort>, #header : Bool) -> Text4_text_sort
→ TextIf(And(IsEmpty<Core_csortvars_sort>(#csortvars?), Not(#header)),
    ()->text⟦†⟨SortNameToCppClassName(#sortname)⟩::⟧)

/* Generate method qualifier, only for non-templated method in source file */
func CppFormQualifier(#formname: String, #csortvars? : List<Core_csortvars_sort>, #header : Bool) -> Text4_text_sort
→ TextIf(And(IsEmpty<Core_csortvars_sort>(#csortvars?), Not(#header)),
    ()->text⟦†⟨FormCppClassName(#formname)⟩::⟧)
