// Copyright (c) 2015 IBM Corporation.
/*
 * Various utility rules related to CRSX terms.
 */
CrsxUtil[(

$Lax;
$Use["parser/Crsx.crs"];
$Use["std/core.crs"];
$Use["std/num.crs"];
$Use["std/string.crs"];
$Use["std/list.crs"];

// Get data/function arity
ArityArgumentsOpt[$List[Crsx_arguments_sort]] :: $Numeric;
ArityArgumentsOpt[%arguments?⟦             ⟧] → 0;
ArityArgumentsOpt[%arguments?⟦ ##arguments ⟧] → ArityArguments[#arguments];

ArityArguments[Crsx_arguments_sort] :: $Numeric;
ArityArguments[%arguments⟦ [         ] ⟧] → 0;
ArityArguments[%arguments⟦ [ ##terms ] ⟧] → ArityTerms[#terms];

ArityTerms[Crsx_terms_sort] :: $Numeric;
ArityTerms[%terms⟦ ##term* ⟧] → Length[#term*];

// Whether the constructor is potentially a CRSX3 directive (start with $)
IsDirective[Crsx_constructor_sort] :: Boolean;
IsDirective[%constructor⟦ ##CONSTRUCTOR ⟧] → StartsWith[#CONSTRUCTOR, "$"];
IsDirective[%constructor⟦ :            ⟧] → FALSE;

// 
// Whether the constructor is potentially a CRSX3 directive (start with $)
IsDirectiveUnwrap[Crsx_constructor_sort] :: $Boolean;
IsDirectiveUnwrap[%constructor⟦ ##CONSTRUCTOR ⟧] → $[StartsWith, #CONSTRUCTOR, "$"];
IsDirectiveUnwrap[%constructor⟦ :            ⟧] → $False;

// Whether the constructor is a CRSX3 primitive (is $)
IsPrimitive[Crsx_constructor_sort] :: Boolean;
IsPrimitive[%constructor⟦ ##CONSTRUCTOR ⟧] → StringEqual[#CONSTRUCTOR, "$"];
IsPrimitive[%constructor⟦ :             ⟧] → FALSE;
// 
// Whether all terms in pattern are meta. No argument means all meta.
AllMetaInPatternRule[Crsx_ruleDeclaration_sort] :: Boolean;
AllMetaInPatternRule[%ruleDeclaration⟦ ##option? ##properties? ##constructor ##arguments? → ##contractum ⟧]
→
AllMetaArgumentsOpt[#arguments?];

AllMetaArgumentsOpt[$List[Crsx_arguments_sort]] :: Boolean;
AllMetaArgumentsOpt[%arguments?⟦            ⟧] → TRUE;
AllMetaArgumentsOpt[%arguments?⟦ [        ] ⟧] → TRUE;
AllMetaArgumentsOpt[%arguments?⟦ [ ##terms ] ⟧] → AllMetaTerms[#terms];

AllMetaTerms[Crsx_terms_sort] :: Boolean;
AllMetaTerms[%terms⟦ ##term* ⟧] → AllMetaTermZOM[#term*];
-[Fallback] : AllMetaTerms[#terms]        → FALSE;

AllMetaTermZOM[$List[Crsx_term_sort]] :: Boolean;
AllMetaTermZOM[%term*⟦                   ⟧] → TRUE;
AllMetaTermZOM[%term*⟦ ##METAVAR ##term* ⟧] → AllMetaTermZOM[#term*];
-[Fallback] : AllMetaTermZOM[#term*]       → FALSE;

// --- Annotations

{$String:$List[Crsx_arguments_sort]} // Map annotation name to its argument
Annotations ::= ( ANNOTATIONS; );

// Index annotations
IndexAnnotations[$List[Crsx_annotations_sort]] ::  Annotations;

IndexAnnotations[%annotations?⟦               ⟧] → {}ANNOTATIONS;
IndexAnnotations[%annotations?⟦ ##annotation+ ⟧] → {}SeqMap[anno cont.IndexAnnotation[anno, cont], #annotation+, ok¹.Then[ok¹]];

Then[OK_SORT] ::  Annotations;
{#E}Then[OK] → {#E}ANNOTATIONS; 

IndexAnnotation[Crsx_annotation_sort, Cont[Annotations]] ::  Annotations;

{#A}IndexAnnotation[%annotation⟦ @ ##CONSTRUCTOR ##arguments? ⟧, CONT[ok¹.#[ok¹]]] → $[Trace, {#A; #CONSTRUCTOR: #arguments?}#[OK]];

// List expansion

DesugarList[Crsx_list_sort] :: Crsx_freeTerm_sort;
DesugarList[%list⟦ (               ) ⟧] → %freeTerm⟦ $Nil ⟧;
DesugarList[%list⟦ ( ##listItem*   ) ⟧] → DesugarListItem[#listItem*];
DesugarList[%list⟦ ( ##listItem* ; ) ⟧] → %freeTerm⟦ $Cons[ ⟨freeTerm: DesugarListItem[#listItem*]⟩, $Nil ] ⟧;  

DesugarListItem[$List[Crsx_listItem_sort]] :: Crsx_freeTerm_sort;
DesugarListItem[%listItem*⟦                    ⟧] → %freeTerm⟦ $Nil ⟧;
DesugarListItem[%listItem*⟦ ##term ##listItem* ⟧] → %freeTerm⟦ $Cons[ ⟨term: #term⟩, ⟨freeTerm: DesugarListItem[#listItem*]⟩ ] ⟧;

)]