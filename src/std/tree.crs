/*
 * @author : m schett
 * @date   : 2015/11/06
 */

Tree[(

$Use["std/list.crs"];
$Use["std/pair.crs"];

/*  Tree with nodes `n` and edge labels `l` */
∀ n l . Tree[n, l] ::= ( Branch[ n, $List [ Pair[ l, Tree[n, l]]]]; );

/*  Position to insert in with justification `l` */
∀ l . Pos[l] ::= ( Above[l];   
                   Below[l]; 
                   Parallel; 
                   UnInsertable;
                 );

/* `Root`
   @param a tree `t`
   @return the root of `t`
*/ 
∀ n l . Root[Tree[n,l]] :: n;
-[Discard[#_]]: 
Root[Branch[#rt, #_]] → #rt;


/* `Succs`
   @param a tree `t`
   @return the successors of `t` where the labels `l` are discarded
*/ 
∀ n l . Succs[Tree[n,l]] :: $List[Tree[n,l]];
-[Discard[#_]]: 
Succs[Branch[#_, #succs]] → Map[x.Snd[x], #succs];


/* `InsertNode[ n1 n2. #C[n1,n2], #n1, #ts]`
   @param `n1 n2. #C[n1,n2]` a Comparator which compares two nodes and returns a `Pos[l]`
   @param #n1                the node to insert
   @param #ts                a list of trees in which to insert `#n1`
   @return a list of trees, in which `#n1` is inserted with edge label `l` according to its Pos[l] computed by `#C`   
*/
∀ n l . InsertNode[x:: n y :: n . Pos[l], n, $List[Tree[n, l]]] :: $List[Tree[n, l]];// empty list of trees
InsertNode[n1 n2 . #C[n1, n2], #n1, ()]  
  → ( Branch[#n1, ()]; );
InsertNode[n1 n2 . #C[n1, n2], #n1, (#t; #ts)] →
  MatchInsertNode[ #C[#n1, Root[#t]], n1 n2. #C[n1, n2], #n1, #t, #ts];

  /* `MatchInsertNode[#pos, n1 n2.#C[n1,n2], #n1, #t, #ts]`
     @param #pos            indicates the position, i.e.,`Above`, `Below`, `Parallel`, or `UnInsertable`
                            in which `#n` should be inserted with respect to `#t`    
     @param n1 n2.#C[n1,n2] a Comparator which compares two nodes and returns a `Pos[l]` 
     @param #n1             the node to insert
     @param #t              the currently considered tree
     @param #ts             the remaining trees 
     @return                a list of trees, where `#n` is inserted according to `#pos`
  */
  ∀ n l . MatchInsertNode[Pos[l], x::n y::n.Pos[l], n, Tree[n,l], $List[Tree[n,l]]] :: $List[Tree[n,l]];  

  // insert `#n1` **ABOVE** `#t`
  MatchInsertNode[Above[#l], n1 n2 . #C[n1, n2], #n1, #t, #ts] → 
    //we have to collect other 'aboves' in the remaining #ts
     ConstructAboveParallel[#n1, 
                            FoldlP[t part.PartitionAboveParallel[#C[#n1, Root[t]], t, part], PairCons[(PairCons[#l, #t];), ()] , #ts]];
     /* `ConstructAboveParallel[#n1, PairCons[#belows, #parallels]]`
        @param `#n1`                           the node that is above `#belows`
        @param `PairCons[#belows, #parallels]` the successors of `#n1` in `#belows`, and the `parallels`
        @return a list of trees, where the first is the newly constructed "above" and then the remaining parallels 
        @note   to keep the original order of arguments `#belows` is reversed
     */
     ∀ n l. ConstructAboveParallel[n, Pair[$List[Pair[l, Tree[n,l]]], $List[Tree[n,l]]]] :: $List[Tree[n,l]];
     ConstructAboveParallel[#n1, PairCons[#belows, #parallels]] → (Branch[#n1, Reverse[#belows]]; #parallels);
     /* `PartitionAboveParallel[#l, #t, PairCons[#aboves, #parallels]]`
        @param `#l`                            label, which should only be `Above[l]` or `Parallel`
        @param `#t`                            the tree to insert
		@param `PairCons[#aboves, #parallels]` `#aboves`holds above a's
                                               `#parallels` holds parallel a's  
        @return a new Pair, where 
                        if `#l` is `Above`    then `PairCons[#l,#t]` is inserted in the first component, 
                        if `#l` is `Parallel` then `#t` is inserted in the second component
        @throws error if `#l` is `Below`
     */    
     ∀ l a . PartitionAboveParallel[Pos[l], a, Pair[$List[Pair[l, a]], $List[a]]] :: Pair[$List[Pair[l,a]], $List[a]];
     PartitionAboveParallel[Above[#l], #t, PairCons[#aboves, #parallels]] 
       → PairCons[(PairCons[#l, #t]; #aboves), #parallels];
     PartitionAboveParallel[Parallel, #t, PairCons[#aboves, #parallels]] 
       → PairCons[#aboves, (#t; #parallels)];
     PartitionAboveParallel[Below[#l], #t, #ts] 
       → $[Error, "PartitionAboveParallel: A node is below whereas is should be only parallel or above."];

  // insert `#n1` **BELOW** `#t`
  MatchInsertNode[Below[#l], n1 n2 . #C[n1, n2], #n1, Branch[#n2, #succs], #ts] →  
    ( Branch[#n2, InsertNodeSuccs[n1 n2 . #C[n1, n2], #l, #n1, #succs]]; #ts );
  
    /* `InsertNodeSuccs`
       @see InsertNode
       @note only difference: it works on a list of successors `#ss` (instead of trees)
             and keeps information of the computed label `#l`
    */
    ∀ l a. InsertNodeSuccs[x::n y::n.Pos[l], l, n, $List[Pair[l,Tree[n,l]]]] :: $List[Pair[l,Tree[n,l]]];
    // leaf case: no successors
    InsertNodeSuccs[n1 n2.#C[n1, n2], #l, #n1, ()]  
      → ( PairCons[ #l , Branch[#n1, ()]]; );
    // branch case: multiple successors
    InsertNodeSuccs[n1 n2. #C[n1, n2], #l1, #n1, (#s; #ss)]
      →  MatchInsertNodeSuccs[#C[#n1, Root[Snd[#s]]], n1 n2. #C[n1, n2], #n1, #l1, #s, #ss];

      /* `MatchInsertNodeSuccs`
         @see MatchInsertNode
         @note only difference: it works on a list of successors `#ss` (instead of trees)
               and keeps information of the computed label `#l`
      */
       ∀ n l . MatchInsertNodeSuccs[ Pos[l], x :: n y :: n . Pos[l], n, l, Pair[l,Tree[n,l]], $List[Pair[l,Tree[n, l]]]] :: $List[Pair[l,Tree[n, l]]]; 
      // insert `#n1` **above** `#s`
      MatchInsertNodeSuccs[ Above[#l1], n1 n2.#C[n1, n2], #n1, #l2, PairCons[#l, #s], #ss] 
        → ConstructAboveParallelSuccs[ #n1, #l2,
                                     FoldlP[s part.PartitionAboveParallelSuccs[#C[#n1, Root[Snd[s]]], s, part], PairCons[(PairCons[#l, #s];), ()] , #ss]];
        /* `ConstructAboveParallelSuccs`
            @see ConstructAboveParallel
            @note only difference: it works on a list of successors `#ss` (instead of trees)
        */
        ∀ n l . ConstructAboveParallelSuccs[n, l, Pair[$List[Pair[l,Tree[n, l]]], $List[Pair[l,Tree[n, l]]]]] ::  $List[Pair[l,Tree[n, l]]];
        ConstructAboveParallelSuccs[ #n1, #l2, PairCons[#belows, #parallels]] → ( PairCons[#l2, Branch[#n1, Reverse[#belows]]]; #parallels);
        /* `PartitionAboveParallelSuccs`
            @see PartitionAboveParallel
            @note only difference: it works on a list of successors (instead of trees)
        */
        ∀ l a . PartitionAboveParallelSuccs[Pos[l], Pair[l,a], Pair[$List[Pair[l, a]], $List[Pair[l,a]]]] :: Pair[$List[Pair[l,a]], $List[Pair[l,a]]];
        PartitionAboveParallelSuccs[Above[#l], PairCons[#_, #s], PairCons[#aboves, #parallels]] 
          → PairCons[( PairCons[#l, #s]; #aboves), #parallels];
        PartitionAboveParallelSuccs[Parallel, #s, PairCons[#aboves, #parallels]] 
          → PairCons[#aboves, (#s; #parallels)];
        PartitionAboveParallelSuccs[Below[#l], #s, #ss] 
          → $[Error, "PartitionAboveParallelSuccs: A node is below whereas is should be only parallel or above."];

     // insert `#n1` **below** `#s`
     MatchInsertNodeSuccs[Below[#l1], n1 n2.#C[n1, n2], #n1, #l2, PairCons[#l, #s], #ss] 
       → ( PairCons[#l, ProjectBelow[InsertNode[n1 n2 . #C[n1, n2], #n1, (#s;) ]]]; #ss);      
      // this projection is possible, as a node should only be inserted below exactly one tree
      ∀ a . ProjectBelow[$List[a]] :: a;
      ProjectBelow[(#s;)]→ #s;
      ProjectBelow[()]       → $[Error, "The node has not been inserted below."];
      ProjectBelow[(#s;#ss)] → $[Error, "There was more than one successor."]; 
    
      // try to insert `#n1` **parallel** to `#s`, i.e, in the remaining `#ss`
      MatchInsertNodeSuccs[ Parallel,  n1 n2 . #C[n1, n2], #n1, #l, #s, #ss] 
        → ( #s; InsertNodeSuccs[ n1 n2.#C[n1,n2], #l, #n1, #ss]);

      // try to insert `#n1` which is uninsertable
      MatchInsertNodeSuccs[UnInsertable, n1 n2 . #C[n1, n2], #n1, #l, #s, #ss] → 
        $[Error, "OVERLAP"];

  // try to insert `#n1` **PARALLEL** to `#t`, i.e., in the remaining `#ts`
  MatchInsertNode[Parallel, n1 n2.#C[n1,n2], #n1, #t, #ts] → (#t; InsertNode[n1 n2.#C[n1,n2], #n1, #ts]); 
  
  // try to insert `#n1` which is uninsertable
  MatchInsertNode[UnInsertable, n1 n2 . #C[n1, n2], #n1, #t, #ts] → 
    $[Error, "OVERLAP"];
  
)]