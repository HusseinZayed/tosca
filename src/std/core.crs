/* Copyright (c) 2014 IBM Corporation. */
/*
 * Core CRSX API.
 */
Core[(

$Lax;

OK_SORT ::= ( OK; );

// --- Builtin string entry

$StringEntry ::= ( STRING[$String];);

// --- Optional value

∀ a.Option[a] ::= ( SOME[a]; NONE; );

∀ a.UnSOME[Option[a]] :: a;
UnSOME[SOME[#]] → #;

// TODO: unable when not using interpreter (which is too strict)
//UnSOME[NONE]    → $[Error, "Error: no optional value."];

/* `HasOption[#option]`
   Whether #option is `SOME` value.
 */
∀ a.HasOption[Option[a]] :: Boolean;
HasOption[NONE]    → FALSE;
HasOption[SOME[#]] → TRUE;


// --- Boolean

Boolean ::=( TRUE; FALSE; );

∀ a . If[Boolean, a, a] :: a ;
If[TRUE,  #1, #2] → #1 ;
If[FALSE, #1, #2] → #2 ;

And[Boolean, Boolean] :: Boolean ;
And[TRUE, #]  → # ;
And[FALSE, #] → FALSE ;

Or[Boolean, Boolean] :: Boolean ;
Or[TRUE, #]  → TRUE;
Or[FALSE, #] → #;

Not[Boolean] :: Boolean;
Not[TRUE]  → FALSE;
Not[FALSE] → TRUE;

// forces evaluation of the arguments
∀ a. Eq[a,a] :: Boolean;
-[Data[#X, #Y]] : Eq[#X,#Y] → $[If, $[Equal,#X,#Y], TRUE, FALSE];

// Weird rule because crsx3 interpreter does not handle boolean equality properly
WrapBoolean[$Boolean] :: Boolean ;
-[Data[#]]: WrapBoolean[#]  → $[If, $[DeepEqual, $[Show, #], "$True"], TRUE, FALSE];

UnwrapBoolean[Boolean] :: $Boolean ;
UnwrapBoolean[TRUE]  → $True;
UnwrapBoolean[FALSE] → $False;

// --- Debugging

∀ a . Trace[a] :: a;
-[Data[#]]: Trace[#] → $[Trace, #];

// -- Error
∀ a . Error[$String] :: a;
Error[#X] → $[Error, #X];

∀ a . TextError[Text] :: a;
-[ Data[#X] ] : 
TextError[#X] → $[Error, TextToString[#X]] ; //TextToString not working

)]