/*
 * @author : m schett
 */

import Std::Core
import Std::List
import Std::Pair 

/*  Tree with nodes `n` and edge labels `l` */
enum Tree<n l> | Branch(n, List<Pair<l Tree<n l>>>)

/*  Position to insert in with justification `l` */
enum Pos<l> | Above(l)  | Below(l) | Parallel | UnInsertable

/* `Root`
   @param a tree `t`
   @return the root of `t`
*/ 
func Root(Tree<n l>) -> n
rule Root(Branch(#rt, #_)) → #rt


/* `Succs`
   @param a tree `t`
   @return the successors of `t` where the labels `l` are discarded
*/ 
func Succs(Tree<n l>) -> List<Tree<n l>>
rule Succs(Branch(#_, #succs)) → Map([x] -> Snd(x), #succs)

/* `PostOrder`
   @param a tree `t`
   @return the list representation of the nodes in `t` in post order
*/
func PostOrder(Tree<n l>) -> List<n>
rule PostOrder( Branch( #N , ()) ) → ( #N, )
rule PostOrder( Branch( #N, #succs)) → Concat(Foldr( [s ss] -> Concat(PostOrder(Snd(s)),ss), (), #succs), (#N,))

/* `InsertNode( [n1 n2] -> #C(n1,n2), #n1, #ts)`
   @param `[n1 n2] -> #C(n1,n2)` a Comparator which compares two nodes and returns a `Pos(l)`
   @param #n1                the node to insert
   @param #ts                a list of trees in which to insert `#n1`
   @return a list of trees, in which `#n1` is inserted with edge label `l` according to its Pos(l) computed by `#C`   
*/
func InsertNode([n n] -> Pos<l>, n, List<Tree<n l>>) -> List<Tree<n l>>
rule InsertNode([n1 n2] -> #C(n1, n2), #n1, ()) → ( Branch(#n1, ()), )
rule InsertNode([n1 n2] -> #C(n1, n2), #n1, (#t, #ts...)) → MatchInsertNode( #C(#n1, Root(#t)), [n1 n2] -> #C(n1, n2), #n1, #t, #ts)

  /* `MatchInsertNode(#pos, [n1 n2] -> #C(n1, n2), #n1, #t, #ts)`
     @param #pos            indicates the position, i.e.,`Above`, `Below`, `Parallel`, or `UnInsertable`
                            in which `#n` should be inserted with respect to `#t`    
     @param n1 n2.#C(n1,n2) a Comparator which compares two nodes and returns a `Pos(l)` 
     @param #n1             the node to insert
     @param #t              the currently considered tree
     @param #ts             the remaining trees 
     @return                a list of trees, where `#n` is inserted according to `#pos`
  */
  func MatchInsertNode(Pos<l>, [n n] -> Pos<l>, n, Tree<n l>, List<Tree<n l>>) -> List<Tree<n l>>  
  // insert `#n1` **ABOVE** `#t`
  rule MatchInsertNode(Above(#l), [n1 n2] -> #C(n1, n2), #n1, #t, #ts) → 
    //we have to collect other 'aboves' in the remaining #ts
     ConstructAboveParallel(#n1, 
                            FoldlP([t part] -> PartitionAboveParallel(#C(#n1, Root(t)), t, part), PairCons((PairCons(#l, #t),), ()) , #ts))
     /* `ConstructAboveParallel(#n1, PairCons(#belows, #parallels))`
        @param `#n1`                           the node that is above `#belows`
        @param `PairCons(#belows, #parallels)` the successors of `#n1` in `#belows`, and the `parallels`
        @return a list of trees, where the first is the newly constructed "above" and then the remaining parallels 
        @note   to keep the original order of arguments `#belows` is reversed
     */
     func ConstructAboveParallel(n, Pair<List<Pair<l Tree<n l>>> List<Tree<n l>>>) -> List<Tree<n l>>
     rule ConstructAboveParallel(#n1, PairCons(#belows, #parallels)) → (Branch(#n1, Reverse(#belows)), #parallels)
     /* `PartitionAboveParallel(#l, #t, PairCons(#aboves, #parallels))`
        @param `#l`                            label, which should only be `Above<l>` or `Parallel`
        @param `#t`                            the tree to insert
		@param `PairCons(#aboves, #parallels)` `#aboves`holds above a's
                                               `#parallels` holds parallel a's  
        @return a new Pair, where 
                        if `#l` is `Above`    then `PairCons(#l,#t)` is inserted in the first component, 
                        if `#l` is `Parallel` then `#t` is inserted in the second component
        @throws error if `#l` is `Below`
     */    
     func PartitionAboveParallel(Pos<l>, a, Pair<List<Pair<l a>> List<a>>) -> Pair<List<Pair<l a>> List<a>>
     rule PartitionAboveParallel(Above(#l), #t, PairCons(#aboves, #parallels)) 
       → PairCons((PairCons(#l, #t), #aboves), #parallels)
     /* boo */
     rule PartitionAboveParallel(Parallel, #t, PairCons(#aboves, #parallels)) 
       → PairCons(#aboves, Insert(#t, #parallels))
     rule PartitionAboveParallel(Below(#l), #t, #ts) 
       → Error("PartitionAboveParallel: A node is below whereas is should be only parallel or above.") 

  // insert `#n1` **BELOW** `#t`
  rule MatchInsertNode(Below(#l), [n1 n2] -> #C(n1, n2), #n1, Branch(#n2, #succs), #ts) →  
    ( Branch(#n2, InsertNodeSuccs([n1 n2] -> #C(n1, n2), #l, #n1, #succs)), #ts )
    
    /* `InsertNodeSuccs`
       @see InsertNode
       @note only difference: it works on a list of successors `#ss` (instead of trees)
             and keeps information of the computed label `#l`
    */
    func InsertNodeSuccs([n n] -> Pos<l>, l, n, List<Pair<l Tree<n l>>>) -> List<Pair<l Tree<n l>>>
    // leaf case: no successors
    rule InsertNodeSuccs([n1 n2] -> #C(n1, n2), #l, #n1, ())  
      → ( PairCons( #l , Branch(#n1, ())), )
    // branch case: multiple successors
    rule InsertNodeSuccs([n1 n2] -> #C(n1, n2), #l1, #n1, (#s, #ss...))
      →  MatchInsertNodeSuccs(#C(#n1, Root(Snd(#s))), [n1 n2] -> #C(n1, n2), #n1, #l1, #s, #ss)

      /* `MatchInsertNodeSuccs`
         @see MatchInsertNode
         @note only difference: it works on a list of successors `#ss` (instead of trees)
               and keeps information of the computed label `#l`
      */
      func MatchInsertNodeSuccs( Pos<l>, [n n] -> Pos<l>, n, l, Pair<l Tree<n l>>, List<Pair< l Tree<n l>>>) -> List<Pair<l Tree<n l>>> 
      // insert `#n1` **above** `#s`
      rule MatchInsertNodeSuccs( Above(#l1), [n1 n2] -> #C(n1, n2), #n1, #l2, PairCons(#l, #s), #ss) 
        → ConstructAboveParallelSuccs( #n1, #l2,
                                     FoldlP([s part] -> PartitionAboveParallelSuccs(#C(#n1, Root(Snd(s))), s, part), PairCons((PairCons(#l, #s),), ()) , #ss))
        /* `ConstructAboveParallelSuccs`
            @see ConstructAboveParallel
            @note only difference: it works on a list of successors `#ss` (instead of trees)
        */
        func ConstructAboveParallelSuccs(n, l, Pair<List<Pair<l Tree<n l>>> List<Pair<l Tree<n l>>>>) ->  List<Pair<l Tree<n l>>>
        rule ConstructAboveParallelSuccs( #n1, #l2, PairCons(#belows, #parallels)) → ( PairCons(#l2, Branch(#n1, Reverse(#belows))), #parallels)
        /* `PartitionAboveParallelSuccs`
            @see PartitionAboveParallel
            @note only difference: it works on a list of successors (instead of trees)
        */
        func PartitionAboveParallelSuccs(Pos<l>, Pair<l a>, Pair<List<Pair<l a>> List<Pair<l a>>>) -> Pair<List<Pair<l a>> List<Pair<l a>>>
        rule PartitionAboveParallelSuccs(Above(#l), PairCons(#_, #s), PairCons(#aboves, #parallels)) 
          → PairCons(( PairCons(#l, #s), #aboves), #parallels)
        rule PartitionAboveParallelSuccs(Parallel, #s, PairCons(#aboves, #parallels)) 
          → PairCons(#aboves, (#s, #parallels))
        rule PartitionAboveParallelSuccs(Below(#l), #s, #ss) 
          → Error("PartitionAboveParallelSuccs: A node is below whereas is should be only parallel or above.")

     // insert `#n1` **below** `#s`
     rule MatchInsertNodeSuccs(Below(#l1), [n1 n2] -> #C(n1, n2), #n1, #l2, PairCons(#l, #s), #ss) 
       → ( PairCons(#l, ProjectBelow(InsertNode([n1 n2] -> #C(n1, n2), #n1, (#s,) ))), #ss)      
      // this projection is possible, as a node should only be inserted below exactly one tree
      func ProjectBelow(List<a>) -> a
      rule ProjectBelow((#s,))       → #s
      rule ProjectBelow(())          → Error("The node has not been inserted below.")
      rule ProjectBelow((#s,#ss...)) → Error("There was more than one successor.") 
    
      // try to insert `#n1` **parallel** to `#s`, i.e, in the remaining `#ss`
      rule MatchInsertNodeSuccs( Parallel, [n1 n2] -> #C(n1, n2), #n1, #l, #s, #ss) 
        → ( #s, InsertNodeSuccs([n1 n2] -> #C(n1, n2), #l, #n1, #ss))

      // try to insert `#n1` which is uninsertable
      rule MatchInsertNodeSuccs(UnInsertable, [n1 n2] -> #C(n1, n2), #n1, #l, #s, #ss) → 
        Error("OVERLAP")

  // try to insert `#n1` **PARALLEL** to `#t`, i.e., in the remaining `#ts`
  rule MatchInsertNode(Parallel, [n1 n2] -> #C(n1, n2), #n1, #t, #ts) → (#t, InsertNode([n1 n2] -> #C(n1, n2), #n1, #ts)) 
  
  // try to insert `#n1` which is uninsertable
  rule MatchInsertNode(UnInsertable, [n1 n2] -> #C(n1, n2), #n1, #t, #ts) → 
    Error("OVERLAP")