// Copyright (c) 2015 IBM Corporation.
/*
 * Normalize CRSX programs to Core CRSX.
 *
 * Eliminate syntactic sugars and perform various checks.
 *
 * In particular:
 * - Gather rules with same constructor into a single rule. 
 * - Convert all patterns to be only meta-variables (including properties)
 * - Qualify sort names and forms. 
 * - Create unique binder names (not implemented yet)
 * - Expand sorted concrete syntax
 * - Desugar property lookup (not implemented yet)
 */
CrsxNormalizer[(

$Lax;

$AddGrammar["org.crsx.parser.CrsxMetaParser"];
$CheckGrammar["org.crsx.parser.CrsxMetaParser"];

$Use["parser/Crsx.crs"];
$Use["state.crs"];
$Use["crsxutils.crs"];
$Use["std/core.crs"];
$Use["std/string.crs"];
$Use["std/list.crs"];
$Use["std/num.crs"];
$Use["std/path.crs"];

// ----- API

// Normalize Crsx and produces a normalized Crsx
NormalizeToCrsx[$String, Crsx_crsx_sort] :: Crsx_crsx_sort;
NormalizeToCrsx[#filename, %crsx⟨ #declarations ⟩] → N1Declarations[BaseName[#filename], DesugarDeclarations[#declarations], ok¹.N2[ok¹, ok¹.OutputCrsx[ok¹]]];

// Normalize Crsx and produces a state
NormalizeToState[$String, Crsx_crsx_sort] :: ContentEntry;
NormalizeToState[#filename, %crsx⟨ #declarations ⟩] → N1Declarations[BaseName[#filename], DesugarDeclarations[#declarations], ok¹.N2[ok¹, ok¹.LOADED]];

// ----- Pass1
//  
// - Collect declarations into the environment (state).
// - Collect imported module file names
//
N1Declarations[$String, $List[Crsx_declarations_S1_sort], ok¹::OK_SORT.$Sort[a]] :: $Sort[a];

N1Declarations[#qualifier, #declarations, ok¹.#[ok¹]]
→
{"$qualifier": STR[#qualifier]; "$rulekeys": KEYS[()]; "$datakeys": KEYS[()]; "$funckeys": KEYS[()]; "$imported": IMPORTS[()]}
N1Declarations1[OK, #declarations, ok¹.#[ok¹]];

//
∀ a.{$String:ContentEntry} 
N1Declarations1[OK_SORT, $List[Crsx_declarations_S1_sort], ok¹::OK_SORT.$Sort[a]] :: $Sort[a];

{#E}N1Declarations1[OK, %declarations_S1*⟨                                  ⟩, ok¹.#[ok¹]] → {#E}#[OK];
{#E}N1Declarations1[OK, %declarations_S1*⟨ ;                                ⟩, ok¹.#[ok¹]] → {#E}#[OK];

{#E}N1Declarations1[OK, %declarations_S1*⟨ ; #declaration #declarations_S1* ⟩, ok¹.#[ok¹]] 
→ 
{#E}N1Declaration[#declaration, ok¹.N1Declarations1[ok¹, #declarations_S1*, ok¹.#[ok¹]]];

//
∀ a.{$String:ContentEntry} 
N1Declaration[Crsx_declaration_sort, ok¹::OK_SORT.$Sort[a]] :: $Sort[a];

{#E}N1Declaration[%declaration⟨ #constructor [( )] ⟩, ok¹.#[ok¹]]
→
//If[IsDirective[#constructor],
$[If, IsDirectiveUnwrap[#constructor], 
    {#E}N1DirectiveConstructor[#constructor, %directiveArguments?⟨⟩], // potential directive.
    {#E}#[OK]];  // Crsx 3 empty module


{#E}N1Declaration[%declaration⟨ #constructor [( #declarations )] ⟩, ok¹.#[ok¹]] 
→
//If[IsDirective[#constructor], 
$[If, IsDirectiveUnwrap[#constructor], 
    {#E}N1DirectiveConstructor[#constructor, %directiveArguments?⟨ [( ⟨declarations: #declarations⟩ )] ⟩], // potential directive.
    {#E}N1Declarations1[OK, DesugarDeclarations[#declarations], ok¹.#[ok¹]]]; // Crsx 3 module: no name mangling.

{#E}N1Declaration[%declaration⟨ #directive ⟩, ok¹.#[ok¹]] 
→
{#E}N1Directive[#directive, ok¹.#[ok¹]];

// Crsx 4 module: name mangling
{#E}N1Declaration[%declaration⟨ module #CONSTRUCTOR { #declarations } ⟩, ok¹.#[ok¹]] 
→ 
{#E}N1Declarations[DesugarDeclarations[#declarations], ok¹.#[ok¹]];

{#E}N1Declaration[%declaration⟨ #option? #properties? #constructor #arguments? → #contractum ⟩, ok¹.#[ok¹]]
→
{#E}AddRule[RulesKey[#constructor], %ruleDeclaration⟨ #option? #properties? #constructor #arguments? → #contractum ⟩, ok¹.#[ok¹]];

{#E}N1Declaration[%declaration⟨ #sortparams? #sortset #sortname ::= ( #forms ) ⟩, ok¹.#[ok¹]] 
→ 
{#E}AddDataSort[%sortDeclaration⟨ #sortparams? #sortset #sortname ::= ( #forms ) ⟩, ok¹.#[ok¹]];

{#E}N1Declaration[%declaration⟨ #sortparams? #sortset #constructor #arguments? :: #sortname ⟩, ok¹.#[ok¹]] 
→ 
{#E}AddFuncSort[%sortDeclaration⟨ #sortparams? #sortset #constructor #arguments? :: #sortname ⟩, ok¹.#[ok¹]];

//
∀ a.{$String:ContentEntry} 
N1Directive[Crsx_directive_sort, ok¹::OK_SORT.$Sort[a]] :: a;

{#E}N1Directive[%directive⟨ #CONSTRUCTOR #directiveArguments? ⟩, ok¹.#[ok¹]]
→
$[If, $[Equal, #CONSTRUCTOR, "$Use"], 
    {#E}N1Use[#directiveArguments?, ok¹.#[ok¹]],
    {#E}#[OK]]; // Just ignore unknown directives. We might want to output a warning.

{#E}N1Directive[#directive, ok¹.#[ok¹]] → {#E}#[OK];

//
∀ a.{$String:ContentEntry} 
N1DirectiveConstructor[Crsx_constructor_sort, ok¹::OK_SORT.$Sort[a]] :: a;
{#E}N1DirectiveConstructor[#constructor, ok¹.#[ok¹]] → {#E}#[OK];

// Import a module: at this level just record dependency.
∀ a.{$String:ContentEntry} 
N1Use[$List[Crsx_directiveArguments_sort], ok¹::OK_SORT.$Sort[a]] :: a;

{#E}N1Use[%directiveArguments?⟨                  ⟩, ok¹.#[ok¹]] → $[Error, "Error: missing filename argument in $Use directive."];
{#E}N1Use[%directiveArguments?⟨ [ #directives? ] ⟩, ok¹.#[ok¹]] → {#E}N1UseDirectives[#directives?, ok¹.#[ok¹]];

∀ a.{$String:ContentEntry} 
N1UseDirectives[$List[Crsx_directives_sort], ok¹::OK_SORT.$Sort[a]] :: a;

{#E}N1UseDirectives[%directives?⟨                                           ⟩, ok¹.#[ok¹]] → $[Error, "Error: missing filename argument in $Use directive."];
{#E}N1UseDirectives[%directives?⟨ #directive1 , #directive2 #directives_S1* ⟩, ok¹.#[ok¹]] → $[Error, "Error: extraneous argument in $Use directive."];
{#E}N1UseDirectives[%directives?⟨ #directive                                ⟩, ok¹.#[ok¹]] → {#E}N1UseDirective[#directive, ok¹.#[ok¹]];

∀ a.{$String:ContentEntry} 
N1UseDirective[Crsx_directive_sort, ok¹::OK_SORT.$Sort[a]] :: a;

{#E; "$imported": IMPORTS[#imported]}N1UseDirective[%directive⟨ #STRING ⟩, ok¹.#[ok¹]] 
→ 
{#E; "$imported": IMPORTS[Concat[#imported, (UnString[#STRING];)]]}#[OK];

{#E}N1UseDirective[#directive, ok¹.#[ok¹]] → $[Error, "Error: invalid argument in $Use directive."];

// ----- Pass2: normalize/check.

∀ a.{$String:ContentEntry} 
N2[OK_SORT, ok¹::OK_SORT.$Sort[a]] :: a;

{#E; "$rulekeys":KEYS[#keys]}N2[OK, ok¹.#[ok¹]] 
→ 
{#E}N2Rules[#keys, ok¹.#[ok¹]];

∀ a.{$String:ContentEntry} 
N2Rules[$List[$String], ok¹::OK_SORT.$Sort[a]] :: a;

{#E}N2Rules[#keys, ok¹.#[ok¹]]
→
{#E}SeqMap[x c.N2Rule[x,c], #keys, ok¹.#[ok¹]];

∀ a.{$String:ContentEntry} 
N2Rule[$String, Continuation[a]] :: a;

{#E}
N2Rule[#ruleKey, CONTINUATION[ok¹.#[ok¹]]]
→
//{#E}MayGroupRule[#ruleKey, ok¹.#[ok¹]];
{#E}MayGroupRule[#ruleKey, ok¹.
    NormalizeRuleKey[#ruleKey, ok¹.#[ok¹]]];

/*
 * Group Rules
 *
 * Create a single rule composing all the given rules 
 * using the dispatch core expression.
 * 
 * Basically do:
 *
 *   O₁:{#E₁}R₁[P₁¹ ... P₁ⁿ] → C₁ 
 *   ..
 *   Oᵢ:{#Eᵢ}Rᵢ[Pᵢ¹ ... Pᵢⁿ] → Cᵢ
 * 
 * becomes
 *
 *   {#$P$E}R[#¹ ... #ⁿ] →
 *      dispatch {#$P$E}R[#¹ ... #ⁿ]
 *        O₁:{#E₁}R[P₁¹ ... P₁ⁿ] → C₁
 *        ...
 *        Oᵢ:{#Eᵢ}R[Pᵢ¹ ... Pᵢⁿ] → Cᵢ
 *        delay
 */ 
∀ a.{$String:ContentEntry} 
MayGroupRule[$String, ok¹::OK_SORT.$Sort[a]] :: a;

{#E; #key: RULES[#rules]}
MayGroupRule[#key, ok¹.#[ok¹]] 
→ 
If[Or[IsEmpty[#rules], And[IsSingleton[#rules], AllMetaInPatternRule[Head[#rules]]]],
    {#E}#[OK],
    {#E}GroupRule[#key, #rules, ok¹.#[ok¹]]];

∀ a.{$String:ContentEntry} 
GroupRule[$String, $List[Crsx_ruleDeclaration_sort], ok¹::OK_SORT.$Sort[a]] :: a;
  
{#E}GroupRule[#key, #rules, ok¹.#[ok¹]] 
→ 
{#E; #key:RULES[(Dispatch[#rules];)]}#[OK];

// Create the dispatch rule.
Dispatch[$List[Crsx_ruleDeclaration_sort]] :: Crsx_ruleDeclaration_sort;
 
// Constructor must have at least one argument, otherwise GroupRule wouldn't be called.
Dispatch[(%ruleDeclaration⟨ #option? #properties? #constructor [ #terms ] → #contractum ⟩; #rules)]
→ 
%ruleDeclaration⟨ 
  ⟨properties?: DispatchProperties[#properties?]⟩ #constructor [ ⟨terms: SugarTerms[DispatchPatternArgs[DesugarTerms[#terms], 0]]⟩ ] 
  →
  dispatch ⟨properties?: DispatchProperties[#properties?]⟩ #constructor [ ⟨terms: SugarTerms[DispatchPatternArgs[DesugarTerms[#terms], 0]]⟩ ]  
    ⟨dispatchCases: SugarDispatchCases[DispatchCases[(%ruleDeclaration⟨ #option? #properties? #constructor [ #terms ] → #contractum ⟩; #rules)]]⟩
    delay
⟩;

// Output properties if any
DispatchProperties[$List[Crsx_properties_sort]] :: $List[Crsx_properties_sort];

DispatchProperties[%properties?⟨                   ⟩] → %properties?⟨         ⟩;
DispatchProperties[%properties?⟨ {               } ⟩] → %properties?⟨         ⟩;
DispatchProperties[%properties?⟨ { #propertyList } ⟩] → %properties?⟨ {#$P$E} ⟩; 

DispatchPatternArgs[$List[Crsx_terms_S1_sort], $Numeric] :: $List[Crsx_terms_S1_sort];

DispatchPatternArgs[%terms_S1*⟨                    ⟩, #count] → %terms_S1*⟨⟩;
  
DispatchPatternArgs[%terms_S1*⟨ , #term #terms_S1* ⟩, #count]
→
%terms_S1*⟨ , ⟨term: DispatchPatternTerm[#term, #count, %freeTerms_S1*⟨⟩]⟩ ⟨terms_S1*: DispatchPatternArgs[#terms_S1*, $[Plus, #count, 1]] ⟩ ⟩;
 
DispatchPatternTerm[Crsx_term_sort, $Numeric, $List[Crsx_freeTerms_S1_sort]] :: Crsx_term_sort;

DispatchPatternTerm[%term⟨ #freeTerm ⟩, #count, #freeTerms_S1*]
→
%term⟨ ⟨freeTerm: DispatchPatternFreeTerm[#freeTerm, #count, #freeTerms_S1*]⟩ ⟩;

DispatchPatternTerm[%term⟨ #binder #nextBinder ⟩, #count, #freeTerms_S1*]
→ 
DispatchPatternBinder[#binder, #nextBinder, #count, #freeTerms_S1*];

DispatchPatternFreeTerm[Crsx_freeTerm_sort, $Numeric, $List[Crsx_freeTerms_S1_sort]] :: Crsx_freeTerm_sort;

DispatchPatternFreeTerm[#freeTerm, #count, #freeTerms_S1*]
→
%freeTerm⟨ ⟨METAVAR: $[:, "#$P$", $[FormatNumber, #count]]⟩ ⟨freeArguments?: DispatchMetaArgsOpt[#freeTerms_S1*]⟩ ⟩;

DispatchPatternBinder[Crsx_binder_sort, Crsx_nextBinder_sort, $Numeric, $List[Crsx_freeTerms_S1_sort]] :: Crsx_term_sort;

DispatchPatternBinder[%binder⟨ #annotations? #VARIABLE #linear? #functional? #varsort?  ⟩, #nextBinder, #count, #freeTerms_S1*] 
→
%term⟨ #annotations? #VARIABLE #linear? #functional? #varsort? 
        ⟨nextBinder: DispatchPatternNextBinder[#nextBinder, #count, Concat[#freeTerms_S1*, (%freeTerms_S1⟨ , #VARIABLE #linear? #functional? ⟩; )]]⟩  ⟩;

DispatchPatternNextBinder[Crsx_nextBinder_sort, $Numeric, $List[Crsx_freeTerms_S1_sort]] :: Crsx_nextBinder_sort;

DispatchPatternNextBinder[%nextBinder⟨ . #freeTerm ⟩, #count, #freeTerms_S1*] → %nextBinder⟨ . ⟨freeTerm: DispatchPatternFreeTerm[#freeTerm, #count, #freeTerms_S1*] ⟩ ⟩;

DispatchPatternNextBinder[%nextBinder⟨ #annotations? #VARIABLE #linear? #functional? #varsort? #nextBinder ⟩, #count, #freeTerms_S1*]
→
%nextBinder⟨ #annotations? #VARIABLE #linear? #functional? #varsort? 
        ⟨nextBinder: DispatchPatternNextBinder[#nextBinder, #count, Concat[#freeTerms_S1*, (%freeTerms_S1⟨ , #annotations? #VARIABLE #linear? #functional? ⟩; )]]⟩  ⟩;

DispatchMetaArgsOpt[$List[Crsx_freeTerms_S1_sort]] :: $List[Crsx_freeArguments_sort];

DispatchMetaArgsOpt[%freeTerms_S1*⟨                            ⟩] → %freeArguments?⟨ ⟩;
DispatchMetaArgsOpt[%freeTerms_S1*⟨ , #freeTerm #freeTerms_S1* ⟩] → %freeArguments?⟨ [ ⟨freeTerms: %freeTerms⟨ #freeTerm #freeTerms_S1*⟩ ⟩ ] ⟩;

DispatchCases[$List[Crsx_ruleDeclaration_sort]] :: $List[Crsx_dispatchCases_S1_ZOM_sort];

DispatchCases[(             )] → %dispatchCases_S1*⟨ ⟩;
DispatchCases[(#rule; #rules)] → %dispatchCases_S1*⟨ ; ⟨ruleDeclaration: #rule⟩ ⟨dispatchCases_S1*: DispatchCases[#rules]⟩ ⟩;

/*
 * Normalize rule. 
 *
 * Performs the following simplifications:
 * - Expand concrete syntax. For now only support Crsx3 ways. In Crsx4, the category is replaced by the term sort which can (at some point) be inferred.
 *
 */
∀ a.{$String:ContentEntry} 
NormalizeRuleKey[$String /* Rule key */, ok¹::OK_SORT.$Sort[a]] :: a;

{#E; #key: RULES[#rules]}
NormalizeRuleKey[#key, ok¹.#[ok¹]] 
→ 
{#E; #key: RULES[{#E}NormalizeRules[#rules]]}#[OK];

{$String:ContentEntry} 
NormalizeRules[$List[Crsx_ruleDeclaration_sort]] :: $List[Crsx_ruleDeclaration_sort];

//{#E}NormalizeRules[(#rule1; #rule2; #rules)] → $[Error, "Internal error: only one rule allowed per function constructor in core."]; 

{#E}NormalizeRules[(#rule;)] → ({#E}NormalizeRule[#rule];);

{$String:ContentEntry} 
NormalizeRule[Crsx_ruleDeclaration_sort] :: Crsx_ruleDeclaration_sort;

{#E}NormalizeRule[%ruleDeclaration⟨ #option? #properties? #constructor #arguments? → #freeTerm ⟩]
→ 
%ruleDeclaration⟨ 
  #option? ⟨properties?: {#E}NormalizePropertiesOpt[#properties?]⟩ #constructor ⟨arguments?: {#E}NormalizeArgumentsOpt[#arguments?]⟩ 
  →
  ⟨freeTerm: {#E}NormalizeFreeTerm[#freeTerm]⟩
⟩;

{$String:ContentEntry} 
NormalizePropertiesOpt[$List[Crsx_properties_sort]] :: $List[Crsx_properties_sort];

{#E}NormalizePropertiesOpt[%properties?⟨                   ⟩]  → %properties?⟨⟩;
{#E}NormalizePropertiesOpt[%properties?⟨ {               } ⟩]  → %properties?⟨ {}⟩;
{#E}NormalizePropertiesOpt[%properties?⟨ { #propertyList } ⟩]  → %properties?⟨ { ⟨propertyList: SugarPropertyList[{#E}NormalizeProperties[DesugarPropertyList[#propertyList]]]⟩ } ⟩;

{$String:ContentEntry} 
NormalizeProperties[$List[Crsx_propertyList_S1_sort]] :: $List[Crsx_propertyList_S1_sort];


{$String:ContentEntry} 
NormalizeArgumentsOpt[$List[Crsx_arguments_sort]] :: $List[Crsx_arguments_sort];

{#E}NormalizeArgumentsOpt[%arguments?⟨            ⟩] → %arguments?⟨⟩;
{#E}NormalizeArgumentsOpt[%arguments?⟨ [        ] ⟩] → %arguments?⟨⟩;
{#E}NormalizeArgumentsOpt[%arguments?⟨ [ #terms ] ⟩] → %arguments?⟨ [ ⟨terms: SugarTerms[NormalizeTerms[DesugarTerms[#terms]]]⟩ ] ⟩;

{$String:ContentEntry} 
NormalizeTerms[$List[Crsx_terms_S1_sort]] :: $List[Crsx_terms_S1_sort];

{#E}NormalizeTerms[%terms_S1*⟨                    ⟩] → %terms_S1*⟨⟩;
{#E}NormalizeTerms[%terms_S1*⟨ , #term #terms_S1* ⟩] → %terms_S1*⟨ , ⟨term: {#E}NormalizeTerm[#term] ⟩ ⟨terms_S1*: {#E}NormalizeTerms[#terms_S1*]⟩ ⟩;
 
{$String:ContentEntry} 
NormalizeTerm[Crsx_term_sort] :: Crsx_term_sort;

{#E}NormalizeTerm[%term⟨ #freeTerm ⟩]           → %term⟨ ⟨freeTerm: {#E}NormalizeFreeTerm[#freeTerm] ⟩ ⟩;
{#E}NormalizeTerm[%term⟨ #binder #nextBinder ⟩] → %term⟨ #binder ⟨nextBinder: {#E}NormalizeNextBinder[#nextBinder]⟩ ⟩;

NormalizeFreeTerm[Crsx_freeTerm_sort] :: Crsx_freeTerm_sort;

// Construction     
{#E}NormalizeFreeTerm[%freeTerm⟨ #annotations? #properties? #constructor #arguments? ⟩] 
→ 
%freeTerm⟨ #annotations? ⟨properties?: {#E}NormalizePropertiesOpt[#properties?]⟩ #constructor 
                         ⟨arguments?: {#E}NormalizeArgumentsOpt[#arguments?]⟩ ⟩;

// Construction one argument     
{#E}NormalizeFreeTerm[%freeTerm⟨ #annotations? #properties? #constructor #term ⟩] 
→
{#E}NormalizeFreeTerm[%freeTerm⟨ #annotations? #properties? #constructor [ #term ] ⟩];

// Literal     
{#E}NormalizeFreeTerm[%freeTerm⟨ #annotations? #properties? #literal ⟩] 
→
%freeTerm⟨ #annotations? ⟨properties?: {#E}NormalizePropertiesOpt[#properties?]⟩ #literal ⟩;

// List     
{#E}NormalizeFreeTerm[%freeTerm⟨ #annotations? #list ⟩] 
→ 
{#E}NormalizeFreeTerm[DesugarList[#list]]; 

// variable     
{#E}NormalizeFreeTerm[%freeTerm⟨ #annotations? #variable ⟩] 
→
%freeTerm⟨ #annotations? #variable ⟩;

// struct     
{#E}NormalizeFreeTerm[%freeTerm⟨ #annotations? #properties ⟩] 
→
%freeTerm⟨ #annotations? ⟨properties: {#E}NormalizeProperties[#properties]⟩ ⟩; 

// Metavariable
{#E}NormalizeFreeTerm[%freeTerm⟨ #annotations? #properties? #METAVAR #freeArguments? ⟩] 
→
%freeTerm⟨ #annotations? ⟨properties?: {#E}NormalizePropertiesOpt[#properties?]⟩ #METAVAR 
                    ⟨freeArguments?: {#E}NormalizeFreeArgumentsOpt[#freeArguments?]⟩ ⟩; 

// Concrete
// TODO: preserve annotations
{#E}NormalizeFreeTerm[%freeTerm⟨ #annotations? #concrete ⟩] 
→
{#E}NormalizeConcrete[#concrete];

// dispatch expression
{#E}NormalizeFreeTerm[%freeTerm⟨ #annotations? #properties? #dispatch ⟩] 
→
%freeTerm⟨ #annotations? ⟨properties?: {#E}NormalizePropertiesOpt[#properties?]⟩ ⟨dispatch: {#E}NormalizeDispatch[#dispatch]⟩ ⟩;

{$String:ContentEntry} 
NormalizeFreeArgumentsOpt[$List[Crsx_freeArguments_sort]] :: $List[Crsx_freeArguments_sort];

{#E}NormalizeFreeArgumentsOpt[%freeArguments?⟨                ⟩] → %freeArguments?⟨⟩;
{#E}NormalizeFreeArgumentsOpt[%freeArguments?⟨ [            ] ⟩] → %freeArguments?⟨⟩;
{#E}NormalizeFreeArgumentsOpt[%freeArguments?⟨ [ #freeTerms ] ⟩] → %freeArguments?⟨ [ ⟨freeTerms: SugarFreeTerms[NormalizeFreeTerms[DesugarFreeTerms[#freeTerms]]]⟩ ] ⟩;

NormalizeConcrete[Crsx_concrete_sort] :: Crsx_freeTerm_sort;

{#E}NormalizeConcrete[%concrete⟨ #CATEGORY #CONCRETE ⟩] 
→ // TODO: Optimize!
ParseString["freeTerm", Show[ParseString[RemoveFirstChar[#CATEGORY], RemoveFirstChar[RemoveLastChar[#CONCRETE]]]]];
//{#E}NormalizeFreeTerm[ParseString["freeTerm", Show[ParseString[RemoveFirstChar[#CATEGORY], RemoveFirstChar[RemoveLastChar[#CONCRETE]]]]]];

NormalizeDispatch[Crsx_dispatch_sort] :: Crsx_dispatch_sort;

{#E}NormalizeDispatch[%dispatch⟨ dispatch #freeTerm #dispatchCases #delayCase?⟩]
→
%dispatch⟨ dispatch ⟨freeTerm: {#E}NormalizeFreeTerm[#freeTerm]⟩ ⟨dispatchCases: SugarDispatchCases[{#E}NormalizeDispatchCases[DesugarDispatchCases[#dispatchCases]]]⟩ #delayCase? ⟩;

NormalizeDispatchCases[$List[Crsx_dispatchCases_S1_sort]] :: $List[Crsx_dispatchCases_S1_sort];

{#E}NormalizeDispatchCases[%dispatchCases_S1*⟨⟩] → %dispatchCases_S1*⟨⟩;

{#E}NormalizeDispatchCases[%dispatchCases_S1*⟨ ; #ruleDeclaration #dispatchCases_S1* ⟩]
→
%dispatchCases_S1*⟨ ; ⟨ruleDeclaration: {#E}NormalizeRule[#ruleDeclaration]⟩ ⟨dispatchCases_S1*: {#E}NormalizeDispatchCases[#dispatchCases_S1*]⟩ ⟩;

)]