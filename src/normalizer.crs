// Copyright (c) 2015 IBM Corporation.
/*
 * Normalize CRSX programs to Core CRSX.
 *
 * Eliminate syntactic sugars and perform various checks.
 *
 * In particular:
 * - Gather rules with same constructor into a single rule. 
 * - Convert all patterns to be only meta-variables (including properties)
 * - Qualify sort names and forms. 
 * - Create unique binder names (not implemented yet)
 * - Expand sorted concrete syntax
 * - Desugar property lookup (not implemented yet)
 */
CrsxNormalizer[(

$Lax;

$AddGrammar["org.crsx.parser.CrsxMetaParser"];

$Use["parser/Crsx.crs"];
$Use["state.crs"];
$Use["crsxutils.crs"];
$Use["std/core.crs"];
$Use["std/string.crs"];
$Use["std/list.crs"];
$Use["std/num.crs"];
$Use["std/path.crs"];

// ----- API

// Normalize Crsx and produces a normalized Crsx
NormalizeToCrsx[$String, Crsx_crsx_sort] :: Crsx_crsx_sort;
NormalizeToCrsx[#filename, %crsx⟦ ##declarations ⟧] → N1DeclarationsInit[BaseName[#filename], DesugarDeclarations[#declarations], ok¹.N2[ok¹, ok¹.OutputCrsx[ok¹]]];

// Normalize Crsx and produces a state
NormalizeToState[$String, Crsx_crsx_sort] :: Content;
NormalizeToState[#filename, %crsx⟦ ##declarations ⟧] → $[Trace, $[:, "Normalize ", #filename], N1DeclarationsInit[BaseName[#filename], DesugarDeclarations[#declarations], ok¹.N2[ok¹, ok¹.LOADED]]];

// ----- Pass1
//  
// - Collect declarations into the environment (state).
// - Collect imported module file names
//
N1DeclarationsInit[$String, $List[Crsx_declarations_S1_sort], ok¹::OK_SORT.$sort[a]] :: a;

N1DeclarationsInit[#qualifier, #declarations, ok¹.#[ok¹]]
→
{"$qualifier": STR[#qualifier]; "$rulekeys": KEYS[()]; "$datakeys": KEYS[()]; 
 "$funckeys": KEYS[()]; "$imported": IMPORTS[()];"$grammars": IMPORTS[()]}
N1Declarations[#declarations, ok¹.#[ok¹]];

∀ a.{$String:ContentEntry} 
N1Declarations[$List[Crsx_declarations_S1_sort], ok¹::OK_SORT.$sort[a]] :: a;

{#E}N1Declarations[#declarations, ok¹.#[ok¹]]
→
{#E}N1Declarations1[OK, #declarations, ok¹.#[ok¹]];

//
∀ a.{$String:ContentEntry} 
N1Declarations1[OK_SORT, $List[Crsx_declarations_S1_sort], ok¹::OK_SORT.$sort[a]] :: a;

{#E}N1Declarations1[OK, %declarations_S1*⟦                                    ⟧, ok¹.#[ok¹]] → {#E}#[OK];
{#E}N1Declarations1[OK, %declarations_S1*⟦ ;                                  ⟧, ok¹.#[ok¹]] → {#E}#[OK];

{#E}N1Declarations1[OK, %declarations_S1*⟦ ; ##declaration ##declarations_S1* ⟧, ok¹.#[ok¹]] 
→ 
{#E}N1Declaration[#declaration, ok¹.N1Declarations1[ok¹, #declarations_S1*, ok¹.#[ok¹]]];

//
∀ a.{$String:ContentEntry} 
N1Declaration[Crsx_declaration_sort, ok¹::OK_SORT.$sort[a]] :: a;

{#E}N1Declaration[%declaration⟦ ##constructor [( )] ⟧, ok¹.#[ok¹]]
→
//If[IsDirective[#constructor],
$[If, IsDirectiveUnwrap[#constructor], 
    {#E}N1DirectiveConstructor[#constructor, ok¹.#[ok¹]], // potential directive.
    {#E}#[OK]];  // Crsx 3 empty module


{#E}N1Declaration[%declaration⟦ ##constructor [( ##declarations )] ⟧, ok¹.#[ok¹]] 
→
//If[IsDirective[#constructor], 
$[If, IsDirectiveUnwrap[#constructor], 
    {#E}N1DirectiveConstructor[#constructor, ok¹.#[ok¹]], // potential directive.
    {#E}N1Declarations1[OK, DesugarDeclarations[#declarations], ok¹.#[ok¹]]]; // Crsx 3 module: no name mangling.

{#E}N1Declaration[%declaration⟦ ##directive ⟧, ok¹.#[ok¹]] 
→
{#E}N1Directive[#directive, ok¹.#[ok¹]];

// Crsx 4 module: name mangling
{#E}N1Declaration[%declaration⟦ module ##CONSTRUCTOR { ##declarations } ⟧, ok¹.#[ok¹]] 
→ 
{#E}N1Declarations[DesugarDeclarations[#declarations], ok¹.#[ok¹]];

{#E}N1Declaration[%declaration⟦ ##option? ##properties? ##constructor ##arguments? → ##contractum ⟧, ok¹.#[ok¹]]
→
{#E}AddRule[RulesKey[#constructor], %ruleDeclaration⟦ ##option? ##properties? ##constructor ##arguments? → ##contractum ⟧, ok¹.#[ok¹]];

{#E}N1Declaration[%declaration⟦ ##sortparams? ##sortset ##sortname ::= ( ##forms ) ⟧, ok¹.#[ok¹]] 
→ 
{#E}AddDataSort[%sortDeclaration⟦ ##sortparams? ##sortset ##sortname ::= ( ##forms ) ⟧, ok¹.#[ok¹]];

{#E}N1Declaration[%declaration⟦ ##sortparams? ##sortset ##constructor ##arguments? :: ##sortname ⟧, ok¹.#[ok¹]] 
→ 
{#E}AddFuncSort[%sortDeclaration⟦ ##sortparams? ##sortset ##constructor ##arguments? :: ##sortname ⟧, ok¹.#[ok¹]];

//
∀ a.{$String:ContentEntry} 
N1Directive[Crsx_directive_sort, ok¹::OK_SORT.$sort[a]] :: a;

{#E}N1Directive[%directive⟦ ##CONSTRUCTOR ##directiveArguments? ⟧, ok¹.#[ok¹]]
→
$[If, $[StringEqual, #CONSTRUCTOR, "$Use"],        {#E}N1Import[#directiveArguments?, TRUE, ok¹.#[ok¹]],
$[If, $[StringEqual, #CONSTRUCTOR, "$AddGrammar"], {#E}N1Import[#directiveArguments?, FALSE, ok¹.#[ok¹]],
   {#E}#[OK]]]; // Just ignore unknown directives. We might want to output a warning.

{#E}N1Directive[#directive, ok¹.#[ok¹]] → {#E}#[OK];

//
∀ a.{$String:ContentEntry} 
N1DirectiveConstructor[Crsx_constructor_sort, ok¹::OK_SORT.$sort[a]] :: a;
{#E}N1DirectiveConstructor[#constructor, ok¹.#[ok¹]] → {#E}#[OK];

// Import a module or grammar: at this level just record dependency.
∀ a.{$String:ContentEntry} 
N1Import[$List[Crsx_directiveArguments_sort], Boolean /* TRUE: module, FALSE: grammar */, ok¹::OK_SORT.$sort[a]] :: a;

{#E}N1Import[%directiveArguments?⟦                   ⟧, #kind, ok¹.#[ok¹]] → $[Error, "Error: missing filename argument in import directive."];
{#E}N1Import[%directiveArguments?⟦ [ ##directives? ] ⟧, #kind, ok¹.#[ok¹]] → {#E}N1ImportDirectives[#directives?, #kind, ok¹.#[ok¹]];

∀ a.{$String:ContentEntry} 
N1ImportDirectives[$List[Crsx_directives_sort], Boolean, ok¹::OK_SORT.$sort[a]] :: a;

{#E}N1ImportDirectives[%directives?⟦                                              ⟧, #kind, ok¹.#[ok¹]] → $[Error, "Error: missing filename argument in import directive."];
{#E}N1ImportDirectives[%directives?⟦ ##directive1 , ##directive2 ##directives_S1* ⟧, #kind, ok¹.#[ok¹]] → $[Error, "Error: extraneous argument in import directive."];
{#E}N1ImportDirectives[%directives?⟦ ##directive                                  ⟧, #kind, ok¹.#[ok¹]] → {#E}N1ImportDirective[#directive, #kind, ok¹.#[ok¹]];

∀ a.{$String:ContentEntry} 
N1ImportDirective[Crsx_directive_sort, Boolean, ok¹::OK_SORT.$sort[a]] :: a;

{#E; "$imported": IMPORTS[#imported]}N1ImportDirective[%directive⟦ ##STRING ⟧, TRUE, ok¹.#[ok¹]] 
→ 
{#E; "$imported": IMPORTS[Concat[#imported, (UnString[#STRING];)]]}#[OK];

{#E; "$grammars": IMPORTS[#imported]}N1ImportDirective[%directive⟦ ##STRING ⟧, FALSE, ok¹.#[ok¹]] 
→ 
{#E; "$grammars": IMPORTS[Concat[#imported, (Replace[UnString[#STRING], ".", "/"];)]]}#[OK];

{#E}N1ImportDirective[#directive, #kind, ok¹.#[ok¹]] → $[Error, "Error: invalid argument in import directive."];

// ----- Pass2: normalize/check.

∀ a.{$String:ContentEntry} 
N2[OK_SORT, ok¹::OK_SORT.$sort[a]] :: a;

{#E; "$rulekeys":KEYS[#keys]}N2[OK, ok¹.#[ok¹]] 
→ 
{#E}N2Rules[#keys, ok¹.#[ok¹]];

∀ a.{$String:ContentEntry} 
N2Rules[$List[$String], ok¹::OK_SORT.$sort[a]] :: a;

{#E}N2Rules[#keys, ok¹.#[ok¹]]
→
{#E}SeqMap[x c.N2Rule[x,c], #keys, ok¹.#[ok¹]];

∀ a.{$String:ContentEntry} 
N2Rule[$String, Continuation[a]] :: a;

{#E}
N2Rule[#ruleKey, CONTINUATION[ok¹.#[ok¹]]]
→
//{#E}MayGroupRule[#ruleKey, ok¹.#[ok¹]];
{#E}MayGroupRule[#ruleKey, ok¹.
    NormalizeRuleKey[ok¹, #ruleKey, ok¹.#[ok¹]]];
//{#E}NormalizeRuleKey[#ruleKey, ok¹.#[ok¹]];

/*
 * Group Rules
 *
 * Create a single rule composing all the given rules 
 * using the dispatch core expression.
 * 
 * Basically do:
 *
 *   O₁:{#E₁}R₁[P₁¹ ... P₁ⁿ] → C₁ 
 *   ..
 *   Oᵢ:{#Eᵢ}Rᵢ[Pᵢ¹ ... Pᵢⁿ] → Cᵢ
 * 
 * becomes
 *
 *   {#$P$E}R[#¹ ... #ⁿ] →
 *      dispatch {#$P$E}R[#¹ ... #ⁿ]
 *        O₁:{#E₁}R[P₁¹ ... P₁ⁿ] → C₁
 *        ...
 *        Oᵢ:{#Eᵢ}R[Pᵢ¹ ... Pᵢⁿ] → Cᵢ
 *        delay
 */ 
∀ a.{$String:ContentEntry} 
MayGroupRule[$String, ok¹::OK_SORT.$sort[a]] :: a;

{#E}MayGroupRule[#key, ok¹.#[ok¹]] 
→ 
{#E}MayGroupRule1[$[{#E}Get, #key], #key,  ok¹.#[ok¹]];

∀ a.{$String:ContentEntry} 
MayGroupRule1[ContentEntry, $String, ok¹::OK_SORT.$sort[a]] :: a;

{#E}MayGroupRule1[RULES[#rules], #key, ok¹.#[ok¹]]
→ 
// TODO: crsx3 interpreter does not lazily evaluate the arguments... 
//If[Or[IsEmpty[#rules], And[IsSingleton[#rules], AllMetaInPatternRule[Head[#rules]]]],
//   {#E}#[OK],
//   {#E}GroupRule[#key, #rules, ok¹.#[ok¹]]];
{#E}MayGroupRule2[Or[IsEmpty[#rules], And[IsSingleton[#rules], AllMetaInPatternRule[Head[#rules]]]], #key, #rules, ok¹.#[ok¹]];

∀ a.{$String:ContentEntry} 
MayGroupRule2[Boolean, $String, $List[Crsx_ruleDeclaration_sort], ok¹::OK_SORT.$sort[a]] :: a;

{#E}MayGroupRule2[TRUE , #key, #rules, ok¹.#[ok¹]] → {#E}#[OK];
{#E}MayGroupRule2[FALSE, #key, #rules, ok¹.#[ok¹]] → {#E}GroupRule[#key, #rules, ok¹.#[ok¹]];

∀ a.{$String:ContentEntry} 
GroupRule[$String, $List[Crsx_ruleDeclaration_sort], ok¹::OK_SORT.$sort[a]] :: a;
  
{#E}GroupRule[#key, #rules, ok¹.#[ok¹]] 
→ 
{#E; #key:RULES[(Dispatch[#rules];)]}#[OK];

// Create the dispatch rule.
Dispatch[$List[Crsx_ruleDeclaration_sort]] :: Crsx_ruleDeclaration_sort;
 
// Constructor must have at least one argument, otherwise GroupRule wouldn't be called.
Dispatch[(%ruleDeclaration⟦ ##option? ##properties? ##constructor [ ##terms ] → ##contractum ⟧; #rules)]
→ 
%ruleDeclaration⟦ 
  ⟨properties?: DispatchProperties[#properties?]⟩ ##constructor [ ⟨terms: SugarTerms[DispatchPatternArgs[DesugarTerms[#terms], 0]]⟩ ] 
  →
  dispatch ⟨properties?: DispatchProperties[#properties?]⟩ ##constructor [ ⟨terms: SugarTerms[DispatchPatternArgs[DesugarTerms[#terms], 0]]⟩ ]  
    ⟨dispatchCases: SugarDispatchCases[DispatchCases[(%ruleDeclaration⟦ ##option? ##properties? ##constructor [ ##terms ] → ##contractum ⟧; #rules)]]⟩
    delay
⟧;

// Output properties if any
DispatchProperties[$List[Crsx_properties_sort]] :: $List[Crsx_properties_sort];

DispatchProperties[%properties?⟦                   ⟧] → %properties?⟦         ⟧;
DispatchProperties[%properties?⟦ {               } ⟧] → %properties?⟦         ⟧;
DispatchProperties[%properties?⟦ { ##propertyList } ⟧] → %properties?⟦ {#$P$E} ⟧; 

DispatchPatternArgs[$List[Crsx_terms_S1_sort], $Numeric] :: $List[Crsx_terms_S1_sort];

DispatchPatternArgs[%terms_S1*⟦                    ⟧, #count] → %terms_S1*⟦⟧;
  
DispatchPatternArgs[%terms_S1*⟦ , ##term ##terms_S1* ⟧, #count]
→
%terms_S1*⟦ , ⟨term: DispatchPatternTerm[#term, #count, %freeTerms_S1*⟦⟧]⟩ ⟨terms_S1*: DispatchPatternArgs[#terms_S1*, $[Plus, #count, 1]] ⟩ ⟧;
 
DispatchPatternTerm[Crsx_term_sort, $Numeric, $List[Crsx_freeTerms_S1_sort]] :: Crsx_term_sort;

DispatchPatternTerm[%term⟦ ##freeTerm ⟧, #count, #freeTerms_S1*]
→
%term⟦ ⟨freeTerm: DispatchPatternFreeTerm[#freeTerm, #count, #freeTerms_S1*]⟩ ⟧;

DispatchPatternTerm[%term⟦ ##binder ##nextBinder ⟧, #count, #freeTerms_S1*]
→ 
DispatchPatternBinder[#binder, #nextBinder, #count, #freeTerms_S1*];

DispatchPatternFreeTerm[Crsx_freeTerm_sort, $Numeric, $List[Crsx_freeTerms_S1_sort]] :: Crsx_freeTerm_sort;

DispatchPatternFreeTerm[#freeTerm, #count, #freeTerms_S1*]
→
%freeTerm⟦ ⟨METAVAR: $[:, "#$P$", $[FormatNumber, #count]]⟩ ⟨freeArguments?: DispatchMetaArgsOpt[#freeTerms_S1*]⟩ ⟧;

DispatchPatternBinder[Crsx_binder_sort, Crsx_nextBinder_sort, $Numeric, $List[Crsx_freeTerms_S1_sort]] :: Crsx_term_sort;

DispatchPatternBinder[%binder⟦ ##annotations? ##VARIABLE ##linear? ##functional? ##varsort?  ⟧, #nextBinder, #count, #freeTerms_S1*] 
→
%term⟦ ##annotations? ##VARIABLE ##linear? ##functional? ##varsort? 
        ⟨nextBinder: DispatchPatternNextBinder[#nextBinder, #count, Concat[#freeTerms_S1*, (%freeTerms_S1⟦ , ##VARIABLE ##linear? ##functional? ⟧; )]]⟩ ⟧;

DispatchPatternNextBinder[Crsx_nextBinder_sort, $Numeric, $List[Crsx_freeTerms_S1_sort]] :: Crsx_nextBinder_sort;

DispatchPatternNextBinder[%nextBinder⟦ . ##freeTerm ⟧, #count, #freeTerms_S1*] → %nextBinder⟦ . ⟨freeTerm: DispatchPatternFreeTerm[#freeTerm, #count, #freeTerms_S1*] ⟩ ⟧;

DispatchPatternNextBinder[%nextBinder⟦ ##annotations? ##VARIABLE ##linear? ##functional? ##varsort? ##nextBinder ⟧, #count, #freeTerms_S1*]
→
%nextBinder⟦ ##annotations? ##VARIABLE ##linear? ##functional? ##varsort? 
        ⟨nextBinder: DispatchPatternNextBinder[#nextBinder, #count, Concat[#freeTerms_S1*, (%freeTerms_S1⟦ , ##annotations? ##VARIABLE ##linear? ##functional? ⟧; )]]⟩  ⟧;

DispatchMetaArgsOpt[$List[Crsx_freeTerms_S1_sort]] :: $List[Crsx_freeArguments_sort];

DispatchMetaArgsOpt[%freeTerms_S1*⟦                              ⟧] → %freeArguments?⟦ ⟧;
DispatchMetaArgsOpt[%freeTerms_S1*⟦ , ##freeTerm ##freeTerms_S1* ⟧] → %freeArguments?⟦ [ ⟨freeTerms: %freeTerms⟦ ##freeTerm ##freeTerms_S1* ⟧ ⟩ ] ⟧;

DispatchCases[$List[Crsx_ruleDeclaration_sort]] :: $List[Crsx_dispatchCases_S1_sort];

DispatchCases[(             )] → %dispatchCases_S1*⟦ ⟧;
DispatchCases[(#rule; #rules)] → %dispatchCases_S1*⟦ ; ⟨ruleDeclaration: #rule⟩ ⟨dispatchCases_S1*: DispatchCases[#rules]⟩ ⟧;

/*
 * Normalize rule. 
 *
 * Performs the following simplifications:
 * - Expand concrete syntax. For now only support Crsx3 ways. In Crsx4, the category is replaced by the term sort which can (at some point) be inferred.
 * - Rewrite primitives to external function call.
 */
∀ a.{$String:ContentEntry} 
NormalizeRuleKey[OK_SORT, $String /* Rule key */, ok¹::OK_SORT.$sort[a]] :: a;

{#E}NormalizeRuleKey[OK, #key, ok¹.#[ok¹]] → {#E}NormalizeRuleKey1[$[{#E}Get, #key], #key, ok¹.#[ok¹]];
 
∀ a.{$String:ContentEntry} 
NormalizeRuleKey1[ContentEntry, $String /* Rule key */, ok¹::OK_SORT.$sort[a]] :: a;

{#E}NormalizeRuleKey1[RULES[#rules], #key, ok¹.#[ok¹]] 
→ 
$[Trace, $[:, "Normalize rules: ", #key],
{#E; #key: RULES[{#E}NormalizeRules[#rules]]}#[OK]];

{$String:ContentEntry} 
NormalizeRules[$List[Crsx_ruleDeclaration_sort]] :: $List[Crsx_ruleDeclaration_sort];

//{#E}NormalizeRules[(#rule1; #rule2; #rules)] → $[Error, "Internal error: only one rule allowed per function constructor in core."]; 

{#E}NormalizeRules[(#rule;)] → ({#E}NormalizeRule[#rule];);

{$String:ContentEntry} 
NormalizeRule[Crsx_ruleDeclaration_sort] :: Crsx_ruleDeclaration_sort;

{#E}NormalizeRule[%ruleDeclaration⟦ ##option? ##properties? ##constructor ##arguments? → ##freeTerm ⟧]
→ 
%ruleDeclaration⟦ 
  ##option? ⟨properties?: {#E}NormalizePropertiesOpt[#properties?]⟩ ##constructor ⟨arguments?: {#E}NormalizeArgumentsOpt[#arguments?]⟩ 
  →
  ⟨freeTerm: {#E}NormalizeFreeTerm[#freeTerm]⟩
⟧;

{$String:ContentEntry} 
NormalizePropertiesOpt[$List[Crsx_properties_sort]] :: $List[Crsx_properties_sort];

{#E}NormalizePropertiesOpt[%properties?⟦                    ⟧]  → %properties?⟦    ⟧;
{#E}NormalizePropertiesOpt[%properties?⟦ {                } ⟧]  → %properties?⟦ {} ⟧;
{#E}NormalizePropertiesOpt[%properties?⟦ { ##propertyList } ⟧]  → %properties?⟦ { ⟨propertyList: SugarPropertyList[{#E}NormalizeProperties[DesugarPropertyList[#propertyList]]]⟩ } ⟧;

{$String:ContentEntry} 
NormalizeProperties[$List[Crsx_propertyList_S1_sort]] :: $List[Crsx_propertyList_S1_sort];

// TODO: traverse properties
{#E}NormalizeProperties[#properties] → #properties;

{$String:ContentEntry} 
NormalizeArgumentsOpt[$List[Crsx_arguments_sort]] :: $List[Crsx_arguments_sort];

{#E}NormalizeArgumentsOpt[%arguments?⟦            ⟧] → %arguments?⟦⟧;
{#E}NormalizeArgumentsOpt[%arguments?⟦ [        ] ⟧] → %arguments?⟦⟧;
{#E}NormalizeArgumentsOpt[%arguments?⟦ [ ##terms ] ⟧] → %arguments?⟦ [ ⟨terms: SugarTerms[NormalizeTerms[DesugarTerms[#terms]]]⟩ ] ⟧;

{$String:ContentEntry} 
NormalizeTerms[$List[Crsx_terms_S1_sort]] :: $List[Crsx_terms_S1_sort];

{#E}NormalizeTerms[%terms_S1*⟦                      ⟧] → %terms_S1*⟦⟧;
{#E}NormalizeTerms[%terms_S1*⟦ , ##term ##terms_S1* ⟧] → %terms_S1*⟦ , ⟨term: {#E}NormalizeTerm[#term] ⟩ ⟨terms_S1*: {#E}NormalizeTerms[#terms_S1*]⟩ ⟧;
 
{$String:ContentEntry} 
NormalizeTerm[Crsx_term_sort] :: Crsx_term_sort;

{#E}NormalizeTerm[%term⟦ ##freeTerm            ⟧] → %term⟦ ⟨freeTerm: {#E}NormalizeFreeTerm[#freeTerm] ⟩ ⟧;
{#E}NormalizeTerm[%term⟦ ##binder ##nextBinder ⟧] → %term⟦ ##binder ⟨nextBinder: {#E}NormalizeNextBinder[#nextBinder]⟩ ⟧;

{$String:ContentEntry}
NormalizeNextBinder[Crsx_nextBinder_sort] :: Crsx_nextBinder_sort;

{#E}NormalizeNextBinder[%nextBinder⟦ ##binder ##nextBinder ⟧] →  %nextBinder⟦ ##binder ⟨nextBinder: {#E}NormalizeNextBinder[#nextBinder]⟩ ⟧;
{#E}NormalizeNextBinder[%nextBinder⟦ . ##freeTerm          ⟧] →  %nextBinder⟦ . ⟨freeTerm: {#E}NormalizeFreeTerm[#freeTerm]⟩ ⟧;

{$String:ContentEntry}
NormalizeFreeTerm[Crsx_freeTerm_sort] :: Crsx_freeTerm_sort;

// Construction     
{#E}NormalizeFreeTerm[%freeTerm⟦ ##annotations? ##properties? ##constructor ##arguments? ⟧] 
→
{#E}NormalizeConstructor[IsPrimitive[#constructor], #annotations?, #properties?, #constructor, #arguments?]; 

// Construction one argument     
{#E}NormalizeFreeTerm[%freeTerm⟦ ##annotations? ##properties? ##constructor ##term ⟧] 
→
{#E}NormalizeFreeTerm[%freeTerm⟦ ##annotations? ##properties? ##constructor [ ##term ] ⟧];

// Literal     
{#E}NormalizeFreeTerm[%freeTerm⟦ ##annotations? ##properties? ##literal ⟧] 
→
%freeTerm⟦ ##annotations? ⟨properties?: {#E}NormalizePropertiesOpt[#properties?]⟩ ##literal ⟧;

// List     
{#E}NormalizeFreeTerm[%freeTerm⟦ ##annotations? ##list ⟧] 
→ 
{#E}NormalizeFreeTerm[DesugarList[#list]]; 

// variable     
{#E}NormalizeFreeTerm[%freeTerm⟦ ##annotations? ##variable ⟧] 
→
%freeTerm⟦ ##annotations? ##variable ⟧;

// struct     
{#E}NormalizeFreeTerm[%freeTerm⟦ ##annotations? { ##propertyList } ⟧] 
→
%freeTerm⟦ ##annotations? { ⟨propertyList: SugarPropertyList[{#E}NormalizeProperties[DesugarPropertyList[#propertyList]]]⟩ } ⟧; 

// Metavariable
{#E}NormalizeFreeTerm[%freeTerm⟦ ##annotations? ##properties? ##METAVAR ##freeArguments? ⟧] 
→
%freeTerm⟦ ##annotations? ⟨properties?: {#E}NormalizePropertiesOpt[#properties?]⟩ ##METAVAR 
                    ⟨freeArguments?: {#E}NormalizeFreeArgumentsOpt[#freeArguments?]⟩ ⟧; 

// Concrete
// TODO: preserve annotations
{#E}NormalizeFreeTerm[%freeTerm⟦ ##annotations? ##concrete ⟧] 
→
{#E}NormalizeConcrete[#concrete];

// dispatch expression
{#E}NormalizeFreeTerm[%freeTerm⟦ ##annotations? ##properties? ##dispatch ⟧] 
→
%freeTerm⟦ ##annotations? ⟨properties?: {#E}NormalizePropertiesOpt[#properties?]⟩ ⟨dispatch: {#E}NormalizeDispatch[#dispatch]⟩ ⟧;

{$String:ContentEntry}
NormalizeConstructor[Boolean, $List[Crsx_annotations_sort], $List[Crsx_properties_sort], Crsx_constructor_sort, $List[Crsx_arguments_sort]] :: Crsx_freeTerm_sort;

{#E}NormalizeConstructor[TRUE, #annotations?, #properties?2, #constructor, %arguments?⟦ [ ##properties? ##constructor2 ##terms_S1* ] ⟧]
→
{#E}NormalizeConstructor[FALSE, #annotations?, #properties?2, #constructor, %arguments?⟦ [ ##properties? ⟨constructor: MakeBuiltin[#constructor2]⟩ ##terms_S1* ]⟧];

{#E}NormalizeConstructor[FALSE, #annotations?, #properties?, #constructor, #arguments?]
→
%freeTerm⟦ ##annotations? ⟨properties?: {#E}NormalizePropertiesOpt[#properties?]⟩ ##constructor 
                          ⟨arguments?: {#E}NormalizeArgumentsOpt[#arguments?]⟩ ⟧;

MakeBuiltin[Crsx_constructor_sort] :: Crsx_constructor_sort;

MakeBuiltin[%constructor⟦ ##CONSTRUCTOR ⟧] → %constructor⟦ ⟨CONSTRUCTOR: $[:, "Builtin$", #CONSTRUCTOR]⟩ ⟧;
MakeBuiltin[%constructor⟦ :             ⟧] → %constructor⟦ Builtin$Colon ⟧;


{$String:ContentEntry} 
NormalizeFreeArgumentsOpt[$List[Crsx_freeArguments_sort]] :: $List[Crsx_freeArguments_sort];

{#E}NormalizeFreeArgumentsOpt[%freeArguments?⟦                 ⟧] → %freeArguments?⟦⟧;
{#E}NormalizeFreeArgumentsOpt[%freeArguments?⟦ [             ] ⟧] → %freeArguments?⟦⟧;
{#E}NormalizeFreeArgumentsOpt[%freeArguments?⟦ [ ##freeTerms ] ⟧] → %freeArguments?⟦ [ ⟨freeTerms: SugarFreeTerms[NormalizeFreeTerms[DesugarFreeTerms[#freeTerms]]]⟩ ] ⟧;

{$String:ContentEntry}
NormalizeFreeTerms[$List[Crsx_freeTerms_S1_sort]] :: $List[Crsx_freeTerms_S1_sort];

{#E}NormalizeFreeTerms[%freeTerms_S1*⟦                              ⟧] → %freeTerms_S1*⟦⟧;
{#E}NormalizeFreeTerms[%freeTerms_S1*⟦ , ##freeTerm ##freeTerms_S1* ⟧] → %freeTerms_S1*⟦ , ⟨freeTerm: {#E}NormalizeFreeTerm[#freeTerm] ⟩ ⟨freeTerms_S1*: {#E}NormalizeFreeTerms[#freeTerms_S1*]⟩ ⟧;

NormalizeConcrete[Crsx_concrete_sort] :: Crsx_freeTerm_sort;

{#E}NormalizeConcrete[%concrete⟦ ##CATEGORY ##CONCRETE ⟧]    
→ // TODO: Optimize!
$[Trace, $[:, "Parse concrete1 ", #CONCRETE], {#E}NormalizeFreeTerm[ParseToTerm["freeTerm", ParseToString[RemoveFirstChar[#CATEGORY], RemoveFirstChar[RemoveLastChar[#CONCRETE]]]]]];
//{#E}NormalizeFreeTerm[ParseString["freeTerm", Show[ParseString[RemoveFirstChar[#CATEGORY], RemoveFirstChar[RemoveLastChar[#CONCRETE]]]]]];
//
//{#E}NormalizeConcrete[%concrete⟦ ##CATEGORY ##CONCRETE2 ⟧] 
//→ // TODO: Optimize!
//$[Trace, $[:, "Parse concrete2 ", #CONCRETE2], {#E}NormalizeFreeTerm[ParseToTerm["freeTerm", ParseToString[RemoveFirstChar[#CATEGORY], RemoveFirstChar[RemoveLastChar[#CONCRETE2]]]]]];
////{#E}NormalizeFreeTerm[ParseString["freeTerm", Show[ParseString[RemoveFirstChar[#CATEGORY], RemoveFirstChar[RemoveLastChar[#CONCRETE]]]]]];


NormalizeDispatch[Crsx_dispatch_sort] :: Crsx_dispatch_sort;

{#E}NormalizeDispatch[%dispatch⟦ dispatch ##freeTerm ##dispatchCases ##delayCase?⟧]
→
%dispatch⟦ dispatch ⟨freeTerm: {#E}NormalizeFreeTerm[#freeTerm]⟩ ⟨dispatchCases: SugarDispatchCases[{#E}NormalizeDispatchCases[DesugarDispatchCases[#dispatchCases]]]⟩ ##delayCase? ⟧;

NormalizeDispatchCases[$List[Crsx_dispatchCases_S1_sort]] :: $List[Crsx_dispatchCases_S1_sort];

{#E}NormalizeDispatchCases[%dispatchCases_S1*⟦⟧] → %dispatchCases_S1*⟦⟧;

{#E}NormalizeDispatchCases[%dispatchCases_S1*⟦ ; ##ruleDeclaration ##dispatchCases_S1* ⟧]
→
%dispatchCases_S1*⟦ ; ⟨ruleDeclaration: {#E}NormalizeRule[#ruleDeclaration]⟩ ⟨dispatchCases_S1*: {#E}NormalizeDispatchCases[#dispatchCases_S1*]⟩ ⟧;

)]