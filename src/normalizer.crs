// Copyright (c) 2015 IBM Corporation.
/*
 * Normalize CRSX programs to Core CRSX.
 *
 * Eliminate syntactic sugars and perform various checks.
 *
 * In particular:
 * - Expand sorted concrete syntax
 */
CrsxNormalizer[(

$Lax;

$AddGrammar["org.crsx.parser.CrsxMetaParser"];
$AddGrammar["org.crsx.core.CoreMetaParser"];

$Use["parser/Crsx.crs"];
$Use["core/Core.crs"];
$Use["std/core.crs"];
$Use["std/string.crs"];
$Use["std/list.crs"];
$Use["std/num.crs"];

// ----- API

// Convert Crsx to Core
ToCore[$String, Crsx_crsx_sort] :: Core_ccrsx_sort;
ToCore[#filename, %crsx⟦ ##decl+ ⟧] 
→ %ccrsx⟦ ⟨cdecl+: NDecls[#decl+]⟩ ⟧;

// ----- Declarations

NDecls[$List[Crsx_decl_sort]] :: $List[Core_cdecl_sort];
NDecls[#cdecl+] 
→ Flatten[Map[x.NDecl[x], #cdecl+]];

NDecl[Crsx_decl_sort] :: $List[Core_cdecl_sort];

/* Convert import module */
NDecl[%decl⟦ import ##constructor ⟧]
→ %cdecl+⟦ import module ⟨CONSTRUCTOR: NConstructor[#constructor]⟩ ⟧;

/* Convert import module */
NDecl[%decl⟦ import module ##constructor ⟧]
→ %cdecl+⟦ import module ⟨CONSTRUCTOR: NConstructor[#constructor]⟩ ⟧; 

/* Convert enum to data sort */
NDecl[%decl⟦ enum ##constructor ##sortParams? ##variant+ ⟧]
→ %cdecl+⟦ data ⟨CONSTRUCTOR: NConstructor[#constructor]⟩ ( ⟨cform*: NVariants[#variant+]⟩ ) ⟧; 

/* Convert function.
   Fixity is only used by the parser and can be eliminated. Still need to access the constructor
*/
NDecl[%decl⟦ func ##fnFixity ##sortParams? ##fnParamDecls? -> ##sort ##fnBody? ⟧]
→ %cdecl+⟦ 
  func ⟨csortvars?: NMaybeSortParams[#sortParams?]⟩ ⟨csort: NSort[#sort]⟩ ⟨CONSTRUCTOR: NConstructor[GetConstructor[#fnFixity]]⟩  ⟨csorts?: NMaybeParamDecls[#fnParamDecls?]⟩ 
  ⟨cdecl+: NMaybeBody[#fnBody?, GetConstructor[#fnFixity], #fnParamDecls?]⟩ 
⟧; 

/* Convert rule */
NDecl[%decl⟦ rule ##constructor ##args? → ##term* ⟧]
→ %cdecl+⟦ rule ⟨CONSTRUCTOR: NConstructor[#constructor]⟩ ⟨cterms?: NMaybeArgs[#args?]⟩ → ⟨cterm: NContractum[#term*]⟩ ⟧;
 
// ---- Enum

NVariants[$List[Crsx_variant_sort]] :: $List[Core_cform_sort];

NVariants[%variant+⟦   ⟧]                   
→ %cform*⟦ ⟧; 

NVariants[%variant+⟦ | ##constructor ##variantArgs? ##variant+ ⟧]
→ %cform*⟦ ⟨CONSTRUCTOR: NConstructor[#constructor]⟩ ⟨csorts?: NMaybeVariantArgs[#variantArgs?]⟩ ⟨cform*: NVariants[#variant+]⟩ ⟧; 

NVariants[%variant+⟦ | var ##variant+ ⟧]
→ %cform*⟦ allows-variable ⟨cform*: NVariants[#variant+]⟩ ⟧; 

NMaybeVariantArgs[$List[Crsx_variantArgs_sort]] :: $List[Core_csorts_sort];
NMaybeVariantArgs[%variantArgs?⟦   ⟧]           → %csorts?⟦ ⟧; 
NMaybeVariantArgs[%variantArgs?⟦ ( ##sort* ) ⟧] → %csorts?⟦ ( ⟨csort*: NSorts[#sort*]⟩ ) ⟧; 

// ---- Sort reference

NSorts[$List[Crsx_sort_sort]] :: $List[Core_csort_sort];
NSorts[#sorts] → Map[sort.NSort[sort], #sorts];

NSort[Crsx_sort_sort] :: Core_csort_sort;
NSort[%sort⟦ ##sortScope? ##constructor ##sortArgs? ⟧] 
→ NMaybeSortScope[#sortScope?, NParamSort[#constructor, #sortArgs?]];

NSort[%sort⟦ ##sortScope? ##VARIABLE ⟧] 
→ NMaybeSortScope[#sortScope?, %csort⟦ ##VARIABLE ⟧];

NMaybeSortScope[$List[Crsx_sortScope_sort], Core_csort_sort] :: Core_csort_sort;
NMaybeSortScope[%sortScope?⟦ ⟧, #csort] 
→ #csort;

NMaybeSortScope[%sortScope?⟦ [ ##sort* ] -> ⟧, #csort] 
→ NSortScope[#sort*, #csort];

NSortScope[$List[Crsx_sort_sort], Core_csort_sort] :: Core_csort_sort;
NSortScope[%sort*⟦ ⟧, #csort]
→ #csort;

NSortScope[%sort*⟦ ##sort ##sort* ⟧, #csort]
→ %csort⟦ [ ⟨csort: NSort[#sort]⟩ ] ⟨csort: NSortScope[#sort*, #csort]⟩ ⟧;

NParamSort[Crsx_constructor_sort, $List[Crsx_sortArgs_sort]] :: Core_csort_sort;

// TODO: the code gen for now generated untyped code so ignore #sortArgs? here
NParamSort[#constructor, #sortArgs?] 
→ %csort⟦ ⟨CONSTRUCTOR: NConstructor[#constructor]⟩ ⟧;

NMaybeSortParams[$List[Crsx_sortParams_sort]] :: $List[Core_csortvars_sort];
NMaybeSortParams[%sortParams?⟦                  ⟧]    → %csortvars?⟦ ⟧; 
NMaybeSortParams[%sortParams?⟦ < ##variable_TOK+ > ⟧] → %csortvars?⟦ ∀ ##variable_TOK+ . ⟧; // TODO: fix metaparser ugly _TOK

// ---- Function declaration

/* Extract constructor from fixity */
GetConstructor[Crsx_fnFixity_sort] :: Crsx_constructor_sort;
GetConstructor[%fnFixity⟦ ##FIXITY ##NUMBER ##constructor ⟧] → #constructor;
GetConstructor[%fnFixity⟦ ##constructor ⟧]                   → #constructor;

NMaybeParamDecls[$List[Crsx_fnParamDecls_sort]] :: $List[Core_csorts_sort];
NMaybeParamDecls[%fnParamDecls?⟦                ⟧] → %csorts?⟦⟧;
NMaybeParamDecls[%fnParamDecls?⟦ (            ) ⟧] → %csorts?⟦⟧;
NMaybeParamDecls[%fnParamDecls?⟦ ( ##fnParam* ) ⟧] → %csorts?⟦ ( ⟨csort*: Map[param.NParam[param], #fnParam*]⟩ ) ⟧;

NParam[Crsx_fnParam_sort] :: Core_csort_sort;
NParam[%fnParam⟦ ##METAVAR : ##eager_TOK? ##sort ⟧] → NSort[#sort];
NParam[%fnParam⟦ ##eager_TOK? ##sort             ⟧] → NSort[#sort];

NMaybeBody[$List[Crsx_fnBody_sort], Crsx_constructor_sort, $List[Crsx_fnParamDecls_sort]] :: $List[Core_cdecl_sort];

NMaybeBody[%fnBody?⟦           ⟧, #constructor, #paramDecls?] 
→ %cdecl+⟦⟧;

NMaybeBody[%fnBody?⟦ → ##term* ⟧, #constructor, #paramDecls?] 
→ %cdecl+⟦ rule ⟨CONSTRUCTOR: NConstructor[#constructor]⟩ ⟨cterms?: NMaybePatternArgs[#paramDecls?]⟩ → ⟨cterm: NContractum[#term*]⟩ ⟧;

NMaybePatternArgs[$List[Crsx_fnParamDecls_sort]] :: $List[Core_cterms_sort];
NMaybePatternArgs[%fnParamDecls?⟦                ⟧]  → %cterms?⟦⟧;
NMaybePatternArgs[%fnParamDecls?⟦ (            ) ⟧]  → %cterms?⟦⟧;
NMaybePatternArgs[%fnParamDecls?⟦ ( ##fnParam* ) ⟧]  → %cterms?⟦ ( ⟨cterm*: Map[param.NPatternArg[param], #fnParam*]⟩ ) ⟧;

NPatternArg[Crsx_fnParam_sort] :: Core_cterm_sort;
NPatternArg[%fnParam⟦ ##METAVAR : ##sort ⟧] → %cterm⟦ ##METAVAR ⟧;
//NPatternArg[%fnParam⟦ ##sort             ⟧] → %cterm⟦ ##METAVAR ⟧;

// ---- Terms

NContractum[$List[Crsx_term_sort]] :: Core_cterm_sort;

// Just a single term
NContractum[%term*⟦ ##term                   ⟧] → NTerm[#term]; 

// This is a list... TODO
NContractum[%term*⟦ ##term , ##term2 ##term* ⟧] → NTerm[#term];

NTerm[Crsx_term_sort] :: Core_cterm_sort;

NTerm[%term⟦ ##constructor ##args? ⟧]
→ %cterm⟦ ⟨CONSTRUCTOR: NConstructor[#constructor]⟩ ⟨cterms?: NMaybeArgs[#args?]⟩ ⟧;

NTerm[%term⟦ ##STRING ⟧]
→ %cterm⟦ ##STRING ⟧;

NTerm[%term⟦ ##NUMBER ⟧]
→ %cterm⟦ ##NUMBER ⟧;

NTerm[%term⟦ ##groupOrList ⟧]
→ NGroupOrList[#groupOrList];

NTerm[%term⟦ ##VARIABLE ⟧]
→ %cterm⟦ ##VARIABLE ⟧;

NTerm[%term⟦ ##METAVAR ##apply? ⟧] 
→ %cterm⟦ ##METAVAR ⟨cterms?: NMaybeApply[#apply?]⟩ ⟧;

NTerm[%term⟦ ##CONCRETE ⟧] 
→ NConcrete[BeforeFirst[#CONCRETE, "⟦"], BeforeLast[AfterFirst[#CONCRETE, "⟦"], "⟧"]];

NMaybeArgs[$List[Crsx_args_sort]] :: $List[Core_cterms_sort];
NMaybeArgs[%args?⟦              ⟧] → %cterms?⟦⟧;
NMaybeArgs[%args?⟦ (          ) ⟧] → %cterms?⟦⟧;
NMaybeArgs[%args?⟦ ( ##scope* ) ⟧] → %cterms?⟦ ( ⟨cterm*: Map[scope.NScope[scope], #scope*]⟩ ) ⟧;

NScope[Crsx_scope_sort] :: Core_cterm_sort;
NScope[%scope⟦ ##term      ⟧] → NTerm[#term];
NScope[%scope⟦ [ ##binders ⟧] → NBinders[#binders];

NBinders[Crsx_binders_sort] :: Core_cterm_sort;
NBinders[%binders⟦ ##VARIABLE ##binders ⟧] → %cterm⟦ [ x ] ⟨cterm: NBinders[#binders[x]]⟩ ⟧;
NBinders[%binders⟦ ] -> ##term          ⟧] → NTerm[#term];

NMaybeApply[$List[Crsx_apply_sort]] :: $List[Core_cterms_sort];
NMaybeApply[%apply?⟦             ⟧] → %cterms?⟦⟧;
NMaybeApply[%apply?⟦ (         ) ⟧] → %cterms?⟦⟧;
NMaybeApply[%apply?⟦ ( ##term* ) ⟧] → %cterms?⟦ ( ⟨cterm*: Map[term.NTerm[term], #term*]⟩ ) ⟧;

NGroupOrList[Crsx_groupOrList_sort] :: Core_cterm_sort;
NGroupOrList[%groupOrList⟦ ()                           ⟧] → %cterm⟦ $Nil ⟧;
NGroupOrList[%groupOrList⟦ ( ##term )                   ⟧] → NTerm[#term];
NGroupOrList[%groupOrList⟦ ( ##term , )                 ⟧] → %cterm⟦ $Cons( ⟨cterm: NTerm[#term]⟩, $Nil) ⟧;
NGroupOrList[%groupOrList⟦ ( ##term , ##term2 ##term* ) ⟧] → NList[%term*⟦ ##term , ##term2 ##term* ⟧];

NList[$List[Crsx_term_sort]] :: Core_cterm_sort;
// TODO: fix meta parser to handle (+) properly. For now cannot match against one item.
// TODO: robustness
NList[%term*⟦                 ⟧] → %cterm⟦ $Nil ⟧;
NList[%term*⟦ ##aterm ... ⟧] → NTerm[%term⟦ ⟨aterm: #aterm⟩ ⟧];
NList[%term*⟦ ##term ##term*  ⟧] → %cterm⟦ $Cons( ⟨cterm: NTerm[#term]⟩, ⟨cterm: NList[#term*]⟩ ) ⟧;

// Big hack to get it working until bootstrapping.
// parse-locations=0 must be specified when running crsx3
NConcrete[$String, $String] :: Core_cterm_sort;
NConcrete[#category, #text] → ParseToTerm["cterm", Trace[Replace[Replace[Replace[Replace[ParseToString[#category, #text], "[", "("], "]", ")"], "¹", " "], "x .", "[x]"]]];

// ----- Tokens

NConstructor[Crsx_constructor_sort] :: $String;
NConstructor[%constructor⟦ ##CONSTRUCTOR ⟧] → #CONSTRUCTOR;

)]