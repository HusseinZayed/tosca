// Copyright (c) 2016 IBM Corporation.

import std::core
import std::listdef
import std::mapdef
import std::pairdef
import std::string
import std::num

import systemdef
import core::Core
import core::utils

// -- API

/*
   Perform various analysis on the given `#module`

   Most specifically:
   - Add @Fallback annotation on function sort with a fallback rule.
   - Add @Keep and @Discard annotation on metavariables
   - TODO: Add @Reuse annotation on binders.
 */
func AnalyzeM(#system: TSystem, #module: Module) -> Module
→ Debug(ConcatString("Analyze ", GetModuleURL(#module)),
         ()->SetModuleContent(#module, AnalyzeC(GetModuleContent(#module))))

/* Module content analysis */
func AnalyzeC(Content) -> Content
rule AnalyzeC(Content(#imports, #rules, #datasorts, #alias, #funcsorts))
→ Content(#imports, AnalyzeRules(#rules), #datasorts, #alias,
            FoldlP((name sorts) -> AnalyzeFallbackFunc(sorts, UnSOME(MapGet(#funcsorts, name)), HasFallback(MapGet(#rules, name))), #funcsorts, MapKeys(#funcsorts)))

// --- Fallback analysis

func AnalyzeFallbackFunc(#funcsorts: {String:Core_cdecl_sort},  #sort: Core_cdecl_sort, #fallback: Bool) -> {String:Core_cdecl_sort}
rule AnalyzeFallbackFunc(#funcsorts,
                        cdecl⟦ ##canno* ##EXTERN? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧, #fallback)
→ PutFuncSort(#funcsorts, cdecl⟦ ⟨canno*: AnalyzeFallbackAnno(#canno*, #fallback, HasAnnotation("Fallback", #canno*))⟩ ##EXTERN? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧, TRUE)

func AnalyzeFallbackAnno(List<Core_canno_sort>, Bool /* Fallback */, Bool /* Has Fallback */) -> List<Core_canno_sort>
rule AnalyzeFallbackAnno(#anno*, TRUE, TRUE)   → #anno*
rule AnalyzeFallbackAnno(#anno*, TRUE, FALSE)  → AddAnnotation("Fallback", #anno*)
rule AnalyzeFallbackAnno(#anno*, FALSE, TRUE)  → Error("Invalid @Fallback annotation: function declaration does not have a fallback rule.")
rule AnalyzeFallbackAnno(#anno*, FALSE, FALSE) → #anno*

/* @return `TRUE` if at least one of the given rule is a fallback. */
func HasFallback(#orules: Option<List<Core_cdecl_sort>>) -> Bool
→ IfPresent(#orules,
    (rs) -> IsNotEmpty(Filter((rr)->IsFallbackRule(rr), rs)),
    () -> FALSE)

func IsFallbackRule(Core_cdecl_sort) -> Bool

  rule IsFallbackRule(cdecl⟦ rule ##cqconstructor ##csortargs? ##csortanno? → ##cterm ⟧)
  → TRUE

  rule IsFallbackRule(cdecl⟦ rule ##cqconstructor ##csortargs? ( ) ##csortanno? → ##cterm ⟧)
  → TRUE

  rule IsFallbackRule(cdecl⟦ rule ##cqconstructor ##csortargs? ( ##cterm* ) ##csortanno? → ##cterm ⟧ )
  → Not(HasOption(PickFirst(#cterm*, (term) -> Not(IsMeta(term)))))


// --- Lifetime analysis (bottom up tree traversal)

func AnalyzeRules(#rules: {String:List<Core_cdecl_sort>}) -> {String:List<Core_cdecl_sort>}
→ FoldlP((key rules)->MapPut(rules, key, Map((rule)->AnalyzeRule(rule), UnSOME(MapGet(#rules, key)))), #rules, MapKeys(#rules))

func AnalyzeRule(Core_cdecl_sort) -> Core_cdecl_sort
rule AnalyzeRule(cdecl⟦ ##canno* rule ##cterm1 → ##cterm2 ⟧)
→ UnPair(AnalyzeVarUse(LEnvNew, #cterm2), (env term)->cdecl⟦ ⟨canno*: AnalyzeRuleAnno(env, #canno*)⟩ rule ##cterm1 → ⟨cterm: term⟩ ⟧)

// -- Analyze rule contraction: annotate metavariable and variables and record their use in the environment

func AnalyzeVarUse(LEnv, Core_cterm_sort) -> PPair<LEnv Core_cterm_sort>

  rule AnalyzeVarUse(#env, cterm⟦ ##canno* ##cqconstructor ##csortargs? ##cterms? ##csortanno? ⟧)
  → UnPair(AnalyzeVarUseMaybeTerms(#env, #cterms?), (env terms)->PairCons(env, cterm⟦ ##canno* ##cqconstructor ##csortargs? ⟨cterms?: terms⟩ ##csortanno? ⟧))

  rule AnalyzeVarUse(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno?  ⟧)
  → AnalyzeVarUseMeta(#canno*, #METAVAR, #cterms?, AnalyzeVarUseMaybeSubst(#env, #csubst?), #csortanno?)
// Eclipse does not like this:
  /*→ UnPair(AnalyzeVarUseMaybeSubst(#env, #csubst?), (env substs)->
      UnPair(AnalyzeVarUseMaybeTerms(env, #cterms?), (env terms)->
        PairCons(env, cterm⟦ ⟨canno*: AnalyzeMayKeep(LEnvGetMetaCount(env, #METAVAR), #canno*)⟩ ##METAVAR ⟨cterms?: terms⟩ ⟨csubst?: substs⟩ : ##csort ⟧)))*/

  rule AnalyzeVarUse(#env, cterm⟦ ##canno* ##VARIABLE ##csortanno? ⟧)
  → PairCons(LEnvIncVarCount(#env, #VARIABLE), cterm⟦ ⟨canno*: AnalyzeMayKeep(LEnvGetVarCount(#env, #VARIABLE), #canno*)⟩ ##VARIABLE ##csortanno? ⟧)

  rule AnalyzeVarUse(#env, cterm⟦ ##canno* [ x : ##csort ] ##cterm[x] ⟧)
  → AnalyzeVarUseBound(#canno*, [x]->AnalyzeVarUse(#env, #cterm[x]), #csort)

  rule AnalyzeVarUse(#env, cterm⟦ ##canno* ( f : ##csort ) ##cterm[f] ⟧)
  → AnalyzeVarUseFormal(#env, cterm⟦ ##canno* ( f : ##csort ) ##cterm[f] ⟧, ())

  rule AnalyzeVarUse(#env, cterm⟦ ##canno* { ##cmapentries? } : ##csort ⟧)
  → Error("Internal Error: Map cannot occur in contraction. See normalizer.")

  rule AnalyzeVarUse(#env, cterm⟦ ##canno* thunk ##cterm ⟧)
  //→ UnPair(AnalyzeVarUse(#env, #cterm), (env term)->PairCons(env, cterm⟦ ##canno* thunk ⟨cterm: term⟩ ⟧))
  → AnalyzeVarUseThunk(#env, #canno*, AnalyzeVarUse(LEnvNew, #cterm))

  rule AnalyzeVarUse(#env, cterm⟦ ##canno* ##METAVAR ##csortanno? = ##cterm ⟧)
  → Error("Internal Error: Named terms cannot occur in contraction")

  rule AnalyzeVarUse(#env, #cterm) → PairCons(#env, #cterm)

func AnalyzeVarUseMaybeTerms(LEnv, List<Core_cterms_sort>) -> PPair<LEnv List<Core_cterms_sort>>

  rule AnalyzeVarUseMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧)
  → UnPair(AnalyzeVarUseTerms(#env, #cterm*), (env terms)->PairCons(env, cterms?⟦ ( ⟨cterm*: terms⟩ ) ⟧))

  rule AnalyzeVarUseMaybeTerms(#env, #cterms?)
  → PairCons(#env, #cterms?)

func AnalyzeVarUseTerms(LEnv, List<Core_cterm_sort>) -> PPair<LEnv List<Core_cterm_sort>>

  rule AnalyzeVarUseTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧)
  → AnalyzeVarUseTerms2(#cterm, AnalyzeVarUseTerms(#env, #cterm*))

  // Eclise does not like this
  /*→ UnPair(AnalyzeVarUseTerms(#env, #cterm*), (env terms)->
      UnPair(AnalyzeVarUse(env, #cterm), (env term)->
        PairCons(env, cterm*⟦ ⟨cterm: term⟩ ⟨cterm*: terms⟩ ⟧)))*/

  rule AnalyzeVarUseTerms(#env, #cterm*)
  → PairCons(#env, #cterm*)

func AnalyzeVarUseTerms2(Core_cterm_sort, PPair<LEnv List<Core_cterm_sort>>) -> PPair<LEnv List<Core_cterm_sort>>
rule AnalyzeVarUseTerms2(#cterm, PairCons(#env, #cterm*))
→ UnPair(AnalyzeVarUse(#env, #cterm), (env term)->PairCons(env, cterm*⟦ ⟨cterm: term⟩ ##cterm* ⟧))

func AnalyzeVarUseMaybeSubst(LEnv, List<Core_csubst_sort>) -> PPair<LEnv List<Core_csubst_sort>>

  rule AnalyzeVarUseMaybeSubst(#env, csubst?⟦ [ ##cterm* ] ⟧)
  → UnPair(AnalyzeVarUseTerms(#env, #cterm*), (env terms)->PairCons(env, csubst?⟦ [ ⟨cterm*: terms⟩ ] ⟧))

  rule AnalyzeVarUseMaybeSubst(#env, #csubst?)
  → PairCons(#env, #csubst?)

func AnalyzeVarUseMeta(List<Core_canno_sort>, String, List<Core_cterms_sort>, PPair<LEnv List<Core_csubst_sort>>, List<Core_csortanno_sort>) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeVarUseMeta(#canno*, #METAVAR, #cterms?, PairCons(#env, #csubst?), #csortanno)
→  AnalyzeVarUseMeta2(#canno*, #METAVAR, AnalyzeVarUseMaybeTerms(#env, #cterms?), #csubst?, #csortanno)

func AnalyzeVarUseMeta2(List<Core_canno_sort>, String, PPair<LEnv List<Core_cterms_sort>>, List<Core_csubst_sort>, List<Core_csortanno_sort>) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeVarUseMeta2(#canno*, #METAVAR, PairCons(#env, #cterms?), #csubst?, #csortanno?)
→  PairCons(LEnvIncMetaCount(#env, #METAVAR), cterm⟦ ⟨canno*: AnalyzeMayKeep(LEnvGetMetaCount(#env, #METAVAR), #canno*)⟩ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧)

func AnalyzeVarUseBound(List<Core_canno_sort>, [String]->PPair<LEnv Core_cterm_sort>, Core_csort_sort) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeVarUseBound(#canno*, [x]->PairCons(#env, #cterm[x]), #csort) → PairCons(#env, cterm⟦ ##canno* [ x : ##csort ] ##cterm[x] ⟧)

// Skip formal parameters. Then analyze the lambda expression using a fresh new environment
// and consolidate the 2 environments on the way up
func AnalyzeVarUseFormal(LEnv, Core_cterm_sort, List<String>) -> PPair<LEnv Core_cterm_sort>

  rule AnalyzeVarUseFormal(#env, cterm⟦ ##canno* ( f : ##csort ) ##cterm[f] ⟧, #params)
  → AnalyzeVarUseFormalUp(#canno*, [f]->AnalyzeVarUseFormal(#env, #cterm[f], (f, #params...)), #csort)

  rule AnalyzeVarUseFormal(#env, #cterm, #params)
  → AnalyzeVarUseFormalUp2(#env, AnalyzeVarUse(LEnvNew, #cterm), #params)

func AnalyzeVarUseFormalUp(List<Core_canno_sort>, [String]->PPair<LEnv Core_cterm_sort>, Core_csort_sort) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeVarUseFormalUp(#canno*, [x]->PairCons(#env, #cterm[x]), #csort)
→ PairCons(#env, cterm⟦ ##canno* ( f : ##csort ) ##cterm[f] ⟧)

func AnalyzeVarUseFormalUp2(LEnv, PPair<LEnv Core_cterm_sort>, List<String>) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeVarUseFormalUp2(#env, PairCons(#ienv, #cterm), #params)
→ PairCons(AnalyzeCaptured(#env, #ienv, #params), AnnotateTerm(#cterm, AnalyzeCapturedAll(#env, LEnvMetaKeys(#ienv), LEnvVarKeys(#ienv), ())))

func AnalyzeVarUseThunk(LEnv, List<Core_canno_sort>, PPair<LEnv Core_cterm_sort>) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeVarUseThunk(#env, #canno*, PairCons(#ienv, #cterm))
→ PairCons(AnalyzeCaptured(#env, #ienv, ()), cterm⟦ ⟨canno*: AnalyzeCapturedAll(#env, LEnvMetaKeys(#ienv), LEnvVarKeys(#ienv), #canno*)⟩ thunk ##cterm ⟧)

// Add @Keep annotation only when a metavariable or variable occurs more than once.
func AnalyzeMayKeep(Option<Numeric>, List<Core_canno_sort>) -> List<Core_canno_sort>

  rule AnalyzeMayKeep(NONE, #canno*)
  → #canno*

  rule AnalyzeMayKeep(SOME(#count), #canno*)
  → If(GreaterThanOrEqual(#count, 1),
      ()->canno*⟦ @Keep ##canno* ⟧,
      ()->#canno*)

/*func AnalyzeMayKeepAll(#env: LEnv, #metas: List<String>, #canno*: List<Core_canno_sort>) -> List<Core_canno_sort>
→ AnalyzeKeepAllFiltered(Map((meta)->cterm⟦ ⟨canno*: AnalyzeMayKeep(LEnvGetMetaCount(#env, meta), ())⟩ ⟨METAVAR: meta⟩ ⟧, AnalyzeFilterMeta(#env, #metas)), #canno*)*/
/*
func AnalyzeFilterMeta(#env: LEnv, #metas: List<String>) -> List<String>
→ Filter((meta)->IfPresent(LEnvGetMeta(#env, meta), (count)->Equal(count, 1), ()->TRUE), #metas)*/

// Add @Captured(#...) annotation for meta-variables and variables occuring inside a lambda
func AnalyzeCapturedAll(LEnv, List<String>, List<String>, List<Core_canno_sort>) -> List<Core_canno_sort>

  rule AnalyzeCapturedAll(#env, (), (), #canno*)
  → #canno*

  rule AnalyzeCapturedAll(#env, #metas, #vars, #canno*)
  → canno*⟦ @Captured( ⟨cterm*: Concat(AnalyzeCapturedAllVar(#env, #vars), AnalyzeCapturedAllMeta(#env, #metas)) ⟩ ) ##canno* ⟧

func AnalyzeCapturedAllMeta(#env: LEnv, #metas: List<String>) -> List<Core_cterm_sort>
→ Map((meta)->cterm⟦ ⟨canno*: AnalyzeMayKeep(LEnvGetMetaCount(#env, meta), ())⟩ ⟨METAVAR: meta⟩ ⟧, #metas)

func AnalyzeCapturedAllVar(#env: LEnv, #vars: List<String>) -> List<Core_cterm_sort>
→ Map((var)->AnalyzeCapturedAllVar2(AnalyzeMayKeep(LEnvGetVarCount(#env, var), ()), var), #vars)
//→ Map((var)->cterm⟦ ⟨canno*: AnalyzeMayKeep(LEnvGetVarCount(#env, var), ())⟩ ⟨cvariable: var⟩ ⟧, #vars)

// TODO: inline Bug probably in the Tosca sort inference
func AnalyzeCapturedAllVar2(#canno*: List<Core_canno_sort>, #VARIABLE: String) -> Core_cterm_sort
→ cterm⟦ ##canno* ##VARIABLE ⟧

// Account for captured metavars and free variables in `#ienv`
// Skip parameters as they go out of scope.
func AnalyzeCaptured(#env: LEnv, #ienv: LEnv, #params: List<String>) -> LEnv
→ FoldlP((meta env)->LEnvIncMetaCount(env, meta),
         FoldlP((var env)->If(HasOption(PickFirst(#params, (param)->Equal(param, var))),
                      ()->env,
                      ()->LEnvIncVarCount(env, var)),
                #env, LEnvVarKeys(#ienv)),
         LEnvMetaKeys(#ienv))

// Annotate rule with metavariables used in the contraction.
// Don't include free variables, as reference counting is handled differently
func AnalyzeRuleAnno(#env: LEnv, #canno*: List<Core_canno_sort>) -> List<Core_canno_sort>
→ AnalyzeKeepAll(Map((meta)->cterm⟦ ⟨METAVAR: meta⟩ ⟧, LEnvMetaKeys(#env)), #canno*)

// Add @KeepAll(#...) annotation for metavariables and variables occuring more than once.
func AnalyzeKeepAll(List<Core_cterm_sort>, List<Core_canno_sort>) -> List<Core_canno_sort>
rule AnalyzeKeepAll(cterm*⟦⟧, #canno*) → #canno*
rule AnalyzeKeepAll(#cterm*, #canno*) → canno*⟦ @KeepAll( ##cterm* ) ##canno* ⟧

// --- Lifetime analysis environment

enum LEnv | LEnv({String:Numeric}, // Map meta-variable name to number of times they are being used.
                 {String:Numeric}) // Map -variable name to number of times they are being used.

func LEnvNew -> LEnv → LEnv({},{})

func LEnvMetas(LEnv) -> {String:Numeric}
rule LEnvMetas(LEnv(#metas, #vars)) → #metas

func LEnvVars(LEnv) -> {String:Numeric}
rule LEnvVars(LEnv(#metas, #vars)) → #vars

func LEnvMetaKeys(LEnv) -> List<String>
rule LEnvMetaKeys(LEnv(#metas, #vars)) → MapKeys(#metas)

func LEnvVarKeys(LEnv) ->  List<String>
rule LEnvVarKeys(LEnv(#metas, #vars)) → MapKeys(#vars)

func LEnvGetMetaCount(#env: LEnv, #metavar: String) -> Option<Numeric>
→ MapGet(LEnvMetas(#env), #metavar)

func LEnvIncMetaCount(#env: LEnv, #metavar: String) -> LEnv
→ LEnv(MapPut(LEnvMetas(#env), #metavar, IfPresent(LEnvGetMetaCount(#env, #metavar), (count)->Plus(count, 1), ()->1)), LEnvVars(#env))

func LEnvGetVarCount(#env: LEnv, #var: String) -> Option<Numeric>
→ MapGet(LEnvVars(#env), #var)

func LEnvIncVarCount(#env: LEnv, #var: String) -> LEnv
→ LEnv(LEnvMetas(#env), MapPut(LEnvVars(#env), #var, IfPresent(LEnvGetVarCount(#env, #var), (count)->Plus(count, 1), ()->1)))
