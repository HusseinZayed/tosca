// Copyright (c) 2016 IBM Corporation.

import std::core
import std::listdef
import std::mapdef
import std::pairdef
import std::num

import systemdef
import core::Core
import core::utils

// -- API

/*
   Perform various analysis on the given `#module`

   Most specifically:
   - Add @Fallback annotation on function sort with a fallback rule.
   - Add @Keep and @Discard annotation on metavariables
   - TODO: Add @Reuse annotation on binders.
 */
func AnalyzeM(#env: TSystem, #module: Module) -> Module
→ SetModuleContent(#module, AnalyzeC(GetModuleContent(#module)))

/* Module content analysis */
func AnalyzeC(Content) -> Content
rule AnalyzeC(Content(#imports, #rules, #datasorts, #alias, #funcsorts))
→ Content(#imports, AnalyzeRules(#rules), #datasorts, #alias,
            FoldlP((name sorts) -> AnalyzeFallbackFunc(sorts, UnSOME(MapGet(#funcsorts, name)), HasFallback(MapGet(#rules, name))), #funcsorts, MapKeys(#funcsorts)))

// --- Fallback analysis

func AnalyzeFallbackFunc(#funcsorts: {String:Core_cdecl_sort},  #sort: Core_cdecl_sort, #fallback: Bool) -> {String:Core_cdecl_sort}
rule AnalyzeFallbackFunc(#funcsorts,
                        cdecl⟦ ##canno* ##EXTERN? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧, #fallback)
→ PutFuncSort(#funcsorts, cdecl⟦ ⟨canno*: AnalyzeFallbackAnno(#canno*, #fallback, HasAnnotation("Fallback", #canno*))⟩ ##EXTERN? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧, TRUE)

func AnalyzeFallbackAnno(List<Core_canno_sort>, Bool /* Fallback */, Bool /* Has Fallback */) -> List<Core_canno_sort>
rule AnalyzeFallbackAnno(#anno*, TRUE, TRUE)   → #anno*
rule AnalyzeFallbackAnno(#anno*, TRUE, FALSE)  → AddAnnotation("Fallback", #anno*)
rule AnalyzeFallbackAnno(#anno*, FALSE, TRUE)  → Error("Invalid @Fallback annotation: function declaration does not have a fallback rule.")
rule AnalyzeFallbackAnno(#anno*, FALSE, FALSE) → #anno*

/* @return `TRUE` if at least one of the given rule is a fallback. */
func HasFallback(#orules: Option<List<Core_cdecl_sort>>) -> Bool
→ IfPresent(#orules,
    (rs) -> IsNotEmpty(Filter((rr)->IsFallbackRule(rr), rs)),
    () -> FALSE)

func IsFallbackRule(Core_cdecl_sort) -> Bool

  rule IsFallbackRule(cdecl⟦ rule ##cqconstructor ##csortargs? ##csortanno? → ##cterm ⟧)
  → TRUE

  rule IsFallbackRule(cdecl⟦ rule ##cqconstructor ##csortargs? ( ) ##csortanno? → ##cterm ⟧)
  → TRUE

  rule IsFallbackRule(cdecl⟦ rule ##cqconstructor ##csortargs? ( ##cterm* ) ##csortanno? → ##cterm ⟧ )
  → Not(HasOption(PickFirst(#cterm*, (term) -> Not(IsMeta(term)))))


// --- Lifetime analysis (bottom up tree traversal)

func AnalyzeRules(#rules: {String:List<Core_cdecl_sort>}) -> {String:List<Core_cdecl_sort>}
→ FoldlP((key rules)->MapPut(rules, key, Map((rule)->AnalyzeRule(rule), UnSOME(MapGet(#rules, key)))), #rules, MapKeys(#rules))

func AnalyzeRule(Core_cdecl_sort) -> Core_cdecl_sort
rule AnalyzeRule(cdecl⟦ ##canno* rule ##cterm1 → ##cterm2 ⟧)
→ UnPair(AnalyzeMetaUse(LEnvNew, #cterm2), (env term)->cdecl⟦ ⟨canno*: AnalyzeRuleAnno(env, #canno*)⟩ rule ##cterm1 → ⟨cterm: term⟩ ⟧)

// -- Analyze rule contraction: annotate metavariable and record their use in the environment

func AnalyzeMetaUse(LEnv, Core_cterm_sort) -> PPair<LEnv Core_cterm_sort>

  rule AnalyzeMetaUse(#env, cterm⟦ ##canno* ##cqconstructor ##csortargs? ##cterms? ##csortanno? ⟧)
  → UnPair(AnalyzeMetaUseMaybeTerms(#env, #cterms?), (env terms)->PairCons(env, cterm⟦ ##canno* ##cqconstructor ##csortargs? ⟨cterms?: terms⟩ ##csortanno? ⟧))

  rule AnalyzeMetaUse(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? : ##csort ⟧)
  → AnalyzeMetaUseMeta(#canno*, #METAVAR, #cterms?, AnalyzeMetaUseMaybeSubst(#env, #csubst?), #csort)
// Eclipse does not like this:
  /*→ UnPair(AnalyzeMetaUseMaybeSubst(#env, #csubst?), (env substs)->
      UnPair(AnalyzeMetaUseMaybeTerms(env, #cterms?), (env terms)->
        PairCons(env, cterm⟦ ⟨canno*: AnalyzeMayKeep(LEnvGetMetaCount(env, #METAVAR), #canno*)⟩ ##METAVAR ⟨cterms?: terms⟩ ⟨csubst?: substs⟩ : ##csort ⟧)))*/

  rule AnalyzeMetaUse(#env, cterm⟦ ##canno* [ x : ##csort ] ##cterm[x] ⟧)
  → AnalyzeMetaUseBound(#canno*, [x]->AnalyzeMetaUse(#env, #cterm[x]), #csort)

  rule AnalyzeMetaUse(#env, cterm⟦ ##canno* ( f : ##csort ) ##cterm[f] ⟧)
  → AnalyzeMetaUseFormal(#env, cterm⟦ ##canno* ( f : ##csort ) ##cterm[f] ⟧)

  rule AnalyzeMetaUse(#env, cterm⟦ ##canno* { ##cmapentries? } : ##csort ⟧)
  → Error("Internal Error: Map cannot occur in contraction. See normalizer.")

  rule AnalyzeMetaUse(#env, cterm⟦ ##canno* thunk ##cterm ⟧)
  //→ UnPair(AnalyzeMetaUse(#env, #cterm), (env term)->PairCons(env, cterm⟦ ##canno* thunk ⟨cterm: term⟩ ⟧))
  → AnalyzeMetaUseThunk(#env, #canno*, AnalyzeMetaUse(LEnvNew, #cterm))

  rule AnalyzeMetaUse(#env, cterm⟦ ##canno* ##METAVAR ##csortanno? = ##cterm ⟧)
  → Error("Internal Error: Named terms cannot occur in contraction")

  rule AnalyzeMetaUse(#env, #cterm) → PairCons(#env, #cterm)

func AnalyzeMetaUseMaybeTerms(LEnv, List<Core_cterms_sort>) -> PPair<LEnv List<Core_cterms_sort>>

  rule AnalyzeMetaUseMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧)
  → UnPair(AnalyzeMetaUseTerms(#env, #cterm*), (env terms)->PairCons(env, cterms?⟦ ( ⟨cterm*: terms⟩ ) ⟧))

  rule AnalyzeMetaUseMaybeTerms(#env, #cterms?)
  → PairCons(#env, #cterms?)

func AnalyzeMetaUseTerms(LEnv, List<Core_cterm_sort>) -> PPair<LEnv List<Core_cterm_sort>>

  rule AnalyzeMetaUseTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧)
  → AnalyzeMetaUseTerms2(#cterm, AnalyzeMetaUseTerms(#env, #cterm*))

  // Eclise does not like this
  /*→ UnPair(AnalyzeMetaUseTerms(#env, #cterm*), (env terms)->
      UnPair(AnalyzeMetaUse(env, #cterm), (env term)->
        PairCons(env, cterm*⟦ ⟨cterm: term⟩ ⟨cterm*: terms⟩ ⟧)))*/

  rule AnalyzeMetaUseTerms(#env, #cterm*)
  → PairCons(#env, #cterm*)

func AnalyzeMetaUseTerms2(Core_cterm_sort, PPair<LEnv List<Core_cterm_sort>>) -> PPair<LEnv List<Core_cterm_sort>>
rule AnalyzeMetaUseTerms2(#cterm, PairCons(#env, #cterm*))
→ UnPair(AnalyzeMetaUse(#env, #cterm), (env term)->PairCons(env, cterm*⟦ ⟨cterm: term⟩ ##cterm* ⟧))

func AnalyzeMetaUseMaybeSubst(LEnv, List<Core_csubst_sort>) -> PPair<LEnv List<Core_csubst_sort>>

  rule AnalyzeMetaUseMaybeSubst(#env, csubst?⟦ [ ##cterm* ] ⟧)
  → UnPair(AnalyzeMetaUseTerms(#env, #cterm*), (env terms)->PairCons(env, csubst?⟦ [ ⟨cterm*: terms⟩ ] ⟧))

  rule AnalyzeMetaUseMaybeSubst(#env, #csubst?)
  → PairCons(#env, #csubst?)

func AnalyzeMetaUseMeta(List<Core_canno_sort>, String, List<Core_cterms_sort>, PPair<LEnv List<Core_csubst_sort>>, Core_csort_sort) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeMetaUseMeta(#canno*, #METAVAR, #cterms?, PairCons(#env, #csubst?), #csort)
→  AnalyzeMetaUseMeta2(#canno*, #METAVAR, AnalyzeMetaUseMaybeTerms(#env, #cterms?), #csubst?, #csort)

func AnalyzeMetaUseMeta2(List<Core_canno_sort>, String, PPair<LEnv List<Core_cterms_sort>>, List<Core_csubst_sort>, Core_csort_sort) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeMetaUseMeta2(#canno*, #METAVAR, PairCons(#env, #cterms?), #csubst?, #csort)
→  PairCons(LEnvIncMetaCount(#env, #METAVAR), cterm⟦ ⟨canno*: AnalyzeMayKeep(LEnvGetMetaCount(#env, #METAVAR), #canno*)⟩ ##METAVAR ##cterms? ##csubst? : ##csort ⟧)

func AnalyzeMetaUseBound(List<Core_canno_sort>, [String]->PPair<LEnv Core_cterm_sort>, Core_csort_sort) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeMetaUseBound(#canno*, [x]->PairCons(#env, #cterm[x]), #csort) → PairCons(#env, cterm⟦ ##canno* [ x : ##csort ] ##cterm[x] ⟧)

func AnalyzeMetaUseFormal(LEnv, Core_cterm_sort) -> PPair<LEnv Core_cterm_sort>

  rule AnalyzeMetaUseFormal(#env, cterm⟦ ##canno* ( f : ##csort ) ##cterm[f] ⟧)
  → AnalyzeMetaUseFormalUp(#canno*, [f]->AnalyzeMetaUseFormal(#env, #cterm[f]), #csort)

  rule AnalyzeMetaUseFormal(#env, #cterm)
  → AnalyzeMetaUseFormalUp2(#env, AnalyzeMetaUse(LEnvNew, #cterm))

func AnalyzeMetaUseFormalUp(List<Core_canno_sort>, [String]->PPair<LEnv Core_cterm_sort>, Core_csort_sort) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeMetaUseFormalUp(#canno*, [x]->PairCons(#env, #cterm[x]), #csort)
→ PairCons(#env, cterm⟦ ##canno* ( f : ##csort ) ##cterm[f] ⟧)

func AnalyzeMetaUseFormalUp2(LEnv, PPair<LEnv Core_cterm_sort>) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeMetaUseFormalUp2(#env, PairCons(#ienv, #cterm))
→ PairCons(AnalyzeCaptured(#env, #ienv), AnnotateTerm(#cterm, AnalyzeMayKeepAll(#env, MapKeys(#ienv), ())))

func AnalyzeMetaUseThunk(LEnv, List<Core_canno_sort>, PPair<LEnv Core_cterm_sort>) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeMetaUseThunk(#env, #canno*, PairCons(#ienv, #cterm))
→ PairCons(AnalyzeCaptured(#env, #ienv), cterm⟦ ⟨canno*: AnalyzeMayKeepAll(#env, MapKeys(#ienv), #canno*)⟩ thunk ##cterm ⟧)

// Add @Keep annotation only when metavar occurs more than once.
func AnalyzeMayKeep(Option<Numeric>, List<Core_canno_sort>) -> List<Core_canno_sort>

  rule AnalyzeMayKeep(NONE, #canno*)
  → #canno*

  rule AnalyzeMayKeep(SOME(#count), #canno*)
  → If(GreaterThanOrEqual(#count, 1),
      ()->canno*⟦ @Keep ##canno* ⟧,
      ()->#canno*)

// Add @KeepAll(#...) annotation for metavars occuring more than once.
func AnalyzeMayKeepAll(#env: LEnv, #metas: List<String>, #canno*: List<Core_canno_sort>) -> List<Core_canno_sort>
→ AnalyzeKeepAllFiltered(Map((meta)->cterm⟦ ⟨canno*: AnalyzeMayKeep(LEnvGetMetaCount(#env, meta), ())⟩ ⟨METAVAR: meta⟩ ⟧, AnalyzeFilterMeta(#env, #metas)), #canno*)

func AnalyzeKeepAllFiltered(List<Core_cterm_sort>, List<Core_canno_sort>) -> List<Core_canno_sort>
rule AnalyzeKeepAllFiltered(cterm*⟦⟧, #canno*) → #canno*
rule AnalyzeKeepAllFiltered(#cterm*, #canno*) → canno*⟦ @KeepAll( ##cterm* ) ##canno* ⟧

func AnalyzeFilterMeta(#env: LEnv, #metas: List<String>) -> List<String>
→ Filter((meta)->IfPresent(MapGet(#env, meta), (count)->Equal(count, 1), ()->TRUE), #metas)

// Account for captured metavars `#ienv`
func AnalyzeCaptured(#env: LEnv, #ienv:LEnv) -> LEnv
→ FoldlP((meta env)->LEnvIncMetaCount(env, meta), #env, MapKeys(#ienv))

// Annotate rule with metavariables used in the contraction

func AnalyzeRuleAnno(#env: LEnv, #canno*: List<Core_canno_sort>) -> List<Core_canno_sort>
→ AnalyzeKeepAllFiltered(Map((meta)->cterm⟦ ⟨METAVAR: meta⟩ ⟧, MapKeys(#env)), #canno*)

// --- Lifetime analysis environment

type LEnv = {String:Numeric} // Map metavariable name to number of times it's being used.

func LEnvNew -> LEnv → {}

func LEnvGetMetaCount(#env: LEnv, #metavar: String) -> Option<Numeric>
→ MapGet(#env, #metavar)

func LEnvIncMetaCount(#env: LEnv, #metavar: String) -> LEnv
→ MapPut(#env, #metavar, IfPresent(LEnvGetMetaCount(#env, #metavar), (count)->Plus(count, 1), ()->1))
