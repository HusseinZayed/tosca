// Copyright (c) 2016 IBM Corporation.

import std::core
import std::listdef
import std::mapdef
import std::pairdef
import std::string
import std::num

import systemdef
import core::Core
import core::utils

// -- API

/*
   Perform various analysis on the given `#module`

   More specifically:
   - Add @Fallback annotation on function sort with a fallback rule.
   - Add @Keep, @KeepAll and @Captured annotations on meta variables and variables
   - Add @Reuse annotation on binders.
 */
func AnalyzeM(#system: TSystem, #module: Module) -> Module
→ Debug(ConcatString("Analyze ", GetModuleURL(#module)),
         ()->SetModuleContent(#module, AnalyzeC(GetModuleContent(#module))))

/* Module content analysis */
func AnalyzeC(Content) -> Content
rule AnalyzeC(Content(#imports, #rules, #datasorts, #alias, #funcsorts))
→ Content(#imports, AnalyzeRules(#rules), #datasorts, #alias,
            FoldlP((name sorts) -> AnalyzeFallbackFunc(sorts, UnSOME(MapGet(#funcsorts, name)), HasFallback(MapGet(#rules, name))), #funcsorts, MapKeys(#funcsorts)))

// --- Fallback analysis

func AnalyzeFallbackFunc(#funcsorts: {String:Core_cdecl_sort},  #sort: Core_cdecl_sort, #fallback: Bool) -> {String:Core_cdecl_sort}
rule AnalyzeFallbackFunc(#funcsorts,
                        cdecl⟦ ##canno* ##EXTERN? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧, #fallback)
→ PutFuncSort(#funcsorts, cdecl⟦ ⟨canno*: AnalyzeFallbackAnno(#canno*, #fallback, HasAnnotation("Fallback", #canno*))⟩ ##EXTERN? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧, TRUE)

func AnalyzeFallbackAnno(List<Core_canno_sort>, Bool /* Fallback */, Bool /* Has Fallback */) -> List<Core_canno_sort>
rule AnalyzeFallbackAnno(#anno*, TRUE, TRUE)   → #anno*
rule AnalyzeFallbackAnno(#anno*, TRUE, FALSE)  → AddAnnotation("Fallback", #anno*)
rule AnalyzeFallbackAnno(#anno*, FALSE, TRUE)  → Error("Invalid @Fallback annotation: function declaration does not have a fallback rule.")
rule AnalyzeFallbackAnno(#anno*, FALSE, FALSE) → #anno*

/* @return `TRUE` if at least one of the given rule is a fallback. */
func HasFallback(#orules: Option<List<Core_cdecl_sort>>) -> Bool
→ IfPresent(#orules,
    (rs) -> IsNotEmpty(Filter((rr)->IsFallbackRule(rr), rs)),
    () -> FALSE)

func IsFallbackRule(Core_cdecl_sort) -> Bool

  rule IsFallbackRule(cdecl⟦ rule ##cqconstructor ##csortargs? ##csortanno? → ##cterm ⟧)
  → TRUE

  rule IsFallbackRule(cdecl⟦ rule ##cqconstructor ##csortargs? ( ) ##csortanno? → ##cterm ⟧)
  → TRUE

  rule IsFallbackRule(cdecl⟦ rule ##cqconstructor ##csortargs? ( ##cterm* ) ##csortanno? → ##cterm ⟧ )
  → Not(HasOption(PickFirst(#cterm*, (term) -> Not(IsMeta(term)))))


// --- Lifetime analysis (bottom up tree traversal)

func AnalyzeRules(#rules: {String:List<Core_cdecl_sort>}) -> {String:List<Core_cdecl_sort>}
→ FoldlP((key rules)->MapPut(rules, key, Map((rule)->AnalyzeRule(rule), UnSOME(MapGet(#rules, key)))), #rules, MapKeys(#rules))

func AnalyzeRule(Core_cdecl_sort) -> Core_cdecl_sort
rule AnalyzeRule(cdecl⟦ ##canno* rule ##cterm1 → ##cterm2 ⟧)
→ UnPair(AnalyzeVar(AnalyzePattern(LEnvNew, #cterm1), #cterm2), (env term)->cdecl⟦ ⟨canno*: AnalyzeRuleAnno(env, #canno*)⟩ rule ##cterm1 → ⟨cterm: term⟩ ⟧)

// -- Analyze rule pattern: record metavariable arguments

func AnalyzePattern(LEnv, Core_cterm_sort) -> LEnv

  rule AnalyzePattern(#env, cterm⟦ ##canno* ##cqconstructor ##csortargs? ##cterms? ##csortanno? ⟧)
  → AnalyzePatternTerms(#env, MaybeTermsToTerms(#cterms?))

  rule AnalyzePattern(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno?  ⟧)
  → LEnvSetMetaArgs(#env, #METAVAR, MaybeTermsToTerms(#cterms?), MaybeSubstToTerms(#csubst?))

  rule AnalyzePattern(#env, cterm⟦ ##canno* [ x : ##csort ] ##cterm[x] ⟧) // Check code gen for reuse x.
  → AnalyzePattern(#env, #cterm[x])

  rule AnalyzePattern(#env, cterm⟦ ##canno* ( f : ##csort ) ##cterm[f] ⟧)
  → AnalyzePattern(#env, #cterm[f])

  rule AnalyzePattern(#env, cterm⟦ ##canno* { ##cmapentries? } ##csortanno? ⟧)
  → AnalyzePatternMap(#env, MaybeMapEntriestToMapEntries(#cmapentries?))

  rule AnalyzePattern(#env, cterm⟦ ##canno* thunk ##cterm ⟧)
  → AnalyzePattern(#env, #cterm)

  rule AnalyzePattern(#env, cterm⟦ ##canno* ##METAVAR ##csortanno? = ##cterm ⟧)
  → AnalyzePattern(#env, #cterm)

  rule AnalyzePattern(#env, cterm⟦ ##canno* let ##METAVAR ##csortanno? = ##cterm ##cterm2 ⟧)
  →  Error("Internal Error: let expression cannot occur in pattern.")

  rule AnalyzePattern(#env, #cterm)
  → #env

func AnalyzePatternTerms(#env: LEnv, #terms: List<Core_cterm_sort>) -> LEnv
→ FoldlP((term env)->AnalyzePattern(env, term), #env, #terms)

func AnalyzePatternMap(#env: LEnv, #entries: List<Core_cmapentry_sort>) -> LEnv
→ FoldlP((entry env)->AnalyzePatternEntry(env, entry), #env, #entries)

func AnalyzePatternEntry(LEnv, Core_cmapentry_sort) -> LEnv
rule AnalyzePatternEntry(#env, cmapentry⟦ ##METAVAR : ##cterm  ⟧) → AnalyzePattern(#env, #cterm)
rule AnalyzePatternEntry(#env, cmapentry⟦ ##VARIABLE : ##cterm ⟧) → AnalyzePattern(#env, #cterm)
rule AnalyzePatternEntry(#env, cmapentry⟦ ##STRING : ##cterm   ⟧) → AnalyzePattern(#env, #cterm)
rule AnalyzePatternEntry(#env, #cmapentry                      ) → #env


// -- Analyze rule contraction: annotate metavariable and variables and record their use in the environment

func AnalyzeVar(LEnv, Core_cterm_sort) -> PPair<LEnv Core_cterm_sort>

  rule AnalyzeVar(#env, cterm⟦ ##canno* ##cqconstructor ##csortargs? ##cterms? ##csortanno? ⟧)
  → UnPair(AnalyzeVarMaybeTerms(#env, #cterms?), (env terms)->PairCons(env, cterm⟦ ##canno* ##cqconstructor ##csortargs? ⟨cterms?: terms⟩ ##csortanno? ⟧))

  rule AnalyzeVar(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno?  ⟧)
  → AnalyzeVarMeta(#canno*, #METAVAR, #cterms?, AnalyzeVarMaybeSubst(#env, #csubst?), #csortanno?)
// Eclipse does not like this:
  /*→ UnPair(AnalyzeVarMaybeSubst(#env, #csubst?), (env substs)->
      UnPair(AnalyzeVarMaybeTerms(env, #cterms?), (env terms)->
        PairCons(env, cterm⟦ ⟨canno*: AnalyzeMayKeep(LEnvGetMetaCount(env, #METAVAR), #canno*)⟩ ##METAVAR ⟨cterms?: terms⟩ ⟨csubst?: substs⟩ : ##csort ⟧)))*/

  rule AnalyzeVar(#env, cterm⟦ ##canno* ##VARIABLE ##csortanno? ⟧)
  → PairCons(LEnvIncVarCount(#env, #VARIABLE), cterm⟦ ⟨canno*: AnalyzeMayKeep(LEnvGetVarCount(#env, #VARIABLE), #canno*)⟩ ##VARIABLE ##csortanno? ⟧)

  rule AnalyzeVar(#env, cterm⟦ ##canno* [ x : ##csort ] ##cterm[x] ⟧)
  → AnalyzeVarBound(#canno*, [x]->AnalyzeVar(#env, #cterm[x]), #csort)

  rule AnalyzeVar(#env, cterm⟦ ##canno* ( f : ##csort ) ##cterm[f] ⟧)
  → AnalyzeVarFormal(#env, cterm⟦ ⟨canno*: AnalyzeMayReuseLambda(#env, #cterm[f], (f,), #canno*)⟩ ( f : ##csort ) ##cterm[f] ⟧, ())

  rule AnalyzeVar(#env, cterm⟦ ##canno* { ##cmapentries? } ##csortanno? ⟧)
  → Error("Internal Error: Map cannot occur in contraction. See normalizer.")

  rule AnalyzeVar(#env, cterm⟦ ##canno* thunk ##cterm ⟧)
  //→ UnPair(AnalyzeVar(#env, #cterm), (env term)->PairCons(env, cterm⟦ ##canno* thunk ⟨cterm: term⟩ ⟧))
  → AnalyzeVarThunk(#env, #canno*, AnalyzeVar(LEnvNew, #cterm))

  rule AnalyzeVar(#env, cterm⟦ ##canno* ##METAVAR ##csortanno? = ##cterm ⟧)
  → Error("Internal Error: Named terms cannot occur in contraction")

  rule AnalyzeVar(#env, cterm⟦ ##canno* let ##METAVAR ##csortanno? = ##cterm ##cterm2 ⟧)
  → AnalyzeVarLet(#canno*, #METAVAR, #csortanno?, #cterm, AnalyzeVar(LEnvRemoveMeta(#env, #METAVAR), #cterm2), LEnvGetMetaCount(#env, #METAVAR))

  rule AnalyzeVar(#env, #cterm) → PairCons(#env, #cterm)

func AnalyzeVarMaybeTerms(LEnv, List<Core_cterms_sort>) -> PPair<LEnv List<Core_cterms_sort>>

  rule AnalyzeVarMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧)
  → UnPair(AnalyzeVarTerms(#env, #cterm*), (env terms)->PairCons(env, cterms?⟦ ( ⟨cterm*: terms⟩ ) ⟧))

  rule AnalyzeVarMaybeTerms(#env, #cterms?)
  → PairCons(#env, #cterms?)

func AnalyzeVarTerms(LEnv, List<Core_cterm_sort>) -> PPair<LEnv List<Core_cterm_sort>>

  rule AnalyzeVarTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧)
  → AnalyzeVarTerms2(#cterm, AnalyzeVarTerms(#env, #cterm*))

  // Eclise does not like this
  /*→ UnPair(AnalyzeVarTerms(#env, #cterm*), (env terms)->
      UnPair(AnalyzeVar(env, #cterm), (env term)->
        PairCons(env, cterm*⟦ ⟨cterm: term⟩ ⟨cterm*: terms⟩ ⟧)))*/

  rule AnalyzeVarTerms(#env, #cterm*)
  → PairCons(#env, #cterm*)

func AnalyzeVarTerms2(Core_cterm_sort, PPair<LEnv List<Core_cterm_sort>>) -> PPair<LEnv List<Core_cterm_sort>>
rule AnalyzeVarTerms2(#cterm, PairCons(#env, #cterm*))
→ UnPair(AnalyzeVar(#env, #cterm), (env term)->PairCons(env, cterm*⟦ ⟨cterm: term⟩ ##cterm* ⟧))

func AnalyzeVarMaybeSubst(LEnv, List<Core_csubst_sort>) -> PPair<LEnv List<Core_csubst_sort>>

  rule AnalyzeVarMaybeSubst(#env, csubst?⟦ [ ##cterm* ] ⟧)
  → UnPair(AnalyzeVarTerms(#env, #cterm*), (env terms)->PairCons(env, csubst?⟦ [ ⟨cterm*: terms⟩ ] ⟧))

  rule AnalyzeVarMaybeSubst(#env, #csubst?)
  → PairCons(#env, #csubst?)

func AnalyzeVarMeta(List<Core_canno_sort>, String, List<Core_cterms_sort>, PPair<LEnv List<Core_csubst_sort>>, List<Core_csortanno_sort>) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeVarMeta(#canno*, #METAVAR, #cterms?, PairCons(#env, #csubst?), #csortanno)
→  AnalyzeVarMeta2(#canno*, #METAVAR, AnalyzeVarMaybeTerms(#env, #cterms?), #csubst?, #csortanno)

func AnalyzeVarMeta2(List<Core_canno_sort>, String, PPair<LEnv List<Core_cterms_sort>>, List<Core_csubst_sort>, List<Core_csortanno_sort>) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeVarMeta2(#canno*, #METAVAR, PairCons(#env, #cterms?), #csubst?, #csortanno?)
→  PairCons(LEnvIncMetaCount(#env, #METAVAR), cterm⟦ ⟨canno*: AnalyzeMayKeep(LEnvGetMetaCount(#env, #METAVAR), #canno*)⟩ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧)

func AnalyzeVarBound(List<Core_canno_sort>, [String]->PPair<LEnv Core_cterm_sort>, Core_csort_sort) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeVarBound(#canno*, [x]->PairCons(#env, #cterm[x]), #csort) → PairCons(#env, cterm⟦ ##canno* [ x : ##csort ] ##cterm[x] ⟧)

// Skip formal parameters. Then analyze the lambda expression using a fresh new environment
// and consolidate the current and new environments on the way up
func AnalyzeVarFormal(LEnv, Core_cterm_sort, List<String>) -> PPair<LEnv Core_cterm_sort>

  rule AnalyzeVarFormal(#env, cterm⟦ ##canno* ( f : ##csort ) ##cterm[f] ⟧, #params)
  → AnalyzeVarFormalUp(#canno*, [f]->AnalyzeVarFormal(#env, #cterm[f], (f, #params...)), #csort)

  rule AnalyzeVarFormal(#env, #cterm, #params)
  → AnalyzeVarFormalUp2(#env, AnalyzeVar(LEnvNew, #cterm), #params)

func AnalyzeVarFormalUp(List<Core_canno_sort>, [String]->PPair<LEnv Core_cterm_sort>, Core_csort_sort) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeVarFormalUp(#canno*, [x]->PairCons(#env, #cterm[x]), #csort)
→ PairCons(#env, cterm⟦ ##canno* ( f : ##csort ) ##cterm[f] ⟧)

func AnalyzeVarFormalUp2(LEnv, PPair<LEnv Core_cterm_sort>, List<String>) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeVarFormalUp2(#env, PairCons(#ienv, #cterm), #params)
→ PairCons(AnalyzeCaptured(#env, #ienv, #params), AnnotateTerm(#cterm, AnalyzeCapturedAll(#env, LEnvMetaKeys(#ienv), LEnvVarKeys(#ienv), ())))

func AnalyzeVarThunk(LEnv, List<Core_canno_sort>, PPair<LEnv Core_cterm_sort>) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeVarThunk(#env, #canno*, PairCons(#ienv, #cterm))
→ PairCons(AnalyzeCaptured(#env, #ienv, ()), cterm⟦ ⟨canno*: AnalyzeCapturedAll(#env, LEnvMetaKeys(#ienv), LEnvVarKeys(#ienv), #canno*)⟩ thunk ##cterm ⟧)

func AnalyzeVarLet(List<Core_canno_sort>, String, List<Core_csortanno_sort>, Core_cterm_sort, PPair<LEnv Core_cterm_sort>, Option<Numeric>) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeVarLet(#canno*, #METAVAR, #csortanno?, #cterm, PairCons(#env, #cterm2), #shadowed)
→ If(HasOption(LEnvGetMetaCount(#env, #METAVAR)), // Check let variable is used.
    ()->AnalyzeVarLet2(#canno*, #METAVAR, #csortanno?, AnalyzeVar(LEnvSetMetaCountO(#env, #METAVAR, #shadowed), #cterm), #cterm2),
    ()->AnalyzeVar(#env, #cterm))

func AnalyzeVarLet2(List<Core_canno_sort>, String, List<Core_csortanno_sort>, PPair<LEnv Core_cterm_sort>, Core_cterm_sort) -> PPair<LEnv Core_cterm_sort>
rule AnalyzeVarLet2(#canno*, #METAVAR, #csortanno?, PairCons(#env, #cterm), #cterm2)
→ PairCons(#env, cterm⟦ ##canno* let ##METAVAR ##csortanno? = ##cterm ##cterm2 ⟧)

// Add @Keep annotation only when a metavariable or variable occurs more than once.
func AnalyzeMayKeep(Option<Numeric>, List<Core_canno_sort>) -> List<Core_canno_sort>

  rule AnalyzeMayKeep(NONE, #canno*)
  → #canno*

  rule AnalyzeMayKeep(SOME(#count), #canno*)
  → If(GreaterThanOrEqual(#count, 1),
      ()->canno*⟦ @Keep ##canno* ⟧,
      ()->#canno*)

// Add @Captured(#...) annotation for meta-variables and variables occuring inside a lambda
func AnalyzeCapturedAll(LEnv, List<String>, List<String>, List<Core_canno_sort>) -> List<Core_canno_sort>

  rule AnalyzeCapturedAll(#env, (), (), #canno*)
  → #canno*

  rule AnalyzeCapturedAll(#env, #metas, #vars, #canno*)
  → canno*⟦ @Captured( ⟨cterm*: Concat(AnalyzeCapturedAllVar(#env, #vars), AnalyzeCapturedAllMeta(#env, #metas)) ⟩ ) ##canno* ⟧

func AnalyzeCapturedAllMeta(#env: LEnv, #metas: List<String>) -> List<Core_cterm_sort>
→ Map((meta)->cterm⟦ ⟨canno*: AnalyzeMayKeep(LEnvGetMetaCount(#env, meta), ())⟩ ⟨METAVAR: meta⟩ ⟧, #metas)

func AnalyzeCapturedAllVar(#env: LEnv, #vars: List<String>) -> List<Core_cterm_sort>
→ Map((var)->AnalyzeCapturedAllVar2(AnalyzeMayKeep(LEnvGetVarCount(#env, var), ()), var), #vars)
//→ Map((var)->cterm⟦ ⟨canno*: AnalyzeMayKeep(LEnvGetVarCount(#env, var), ())⟩ ⟨cvariable: var⟩ ⟧, #vars)

// TODO: inline Bug probably in the Tosca sort inference
// TODO: should not capture formal parameters.
func AnalyzeCapturedAllVar2(#canno*: List<Core_canno_sort>, #VARIABLE: String) -> Core_cterm_sort
→ cterm⟦ ##canno* ##VARIABLE ⟧

// Account for captured metavars and free variables in `#ienv`
// Skip parameters as they go out of scope.
func AnalyzeCaptured(#env: LEnv, #ienv: LEnv, #params: List<String>) -> LEnv
→ FoldlP((meta env)->LEnvIncMetaCount(env, meta),
         FoldlP((var env)->If(HasOption(PickFirst(#params, (param)->Equal(param, var))),
                      ()->env,
                      ()->LEnvIncVarCount(env, var)),
                #env, LEnvVarKeys(#ienv)),
         LEnvMetaKeys(#ienv))

// Annotate rule with metavariables used in the contraction.
// Don't include free variables, as reference counting is handled differently
func AnalyzeRuleAnno(#env: LEnv, #canno*: List<Core_canno_sort>) -> List<Core_canno_sort>
→ AnalyzeKeepAll(Map((meta)->cterm⟦ ⟨METAVAR: meta⟩ ⟧, LEnvMetaKeys(#env)), #canno*)

// Add @KeepAll(#...) annotation for metavariables and variables occuring more than once.
func AnalyzeKeepAll(List<Core_cterm_sort>, List<Core_canno_sort>) -> List<Core_canno_sort>
rule AnalyzeKeepAll(cterm*⟦⟧, #canno*) → #canno*
rule AnalyzeKeepAll(#cterm*, #canno*) → canno*⟦ @KeepAll( ##cterm* ) ##canno* ⟧

// Add @Reuse annotation when the given `#lamdda` expression is not fully or partially evaluated
func AnalyzeMayReuseLambda(LEnv, Core_cterm_sort, List<String>, List<Core_canno_sort>) -> List<Core_canno_sort>

  rule AnalyzeMayReuseLambda(#env, cterm⟦ ##canno* ( f : ##csort ) ##cterm[f] ⟧, #params, #canno*)
  → AnalyzeMayReuseLambda(#env, #cterm[f], Append(f, #params), #canno*)

  rule AnalyzeMayReuseLambda(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #params, #canno*)
  → let #patternParams = LEnvGetMetaParams(#env, #METAVAR)
    let #args = MaybeTermsToTerms(#cterms?)
      AnalyzeMayReuseLambdaArity(NumberEqual(ListLength(#patternParams), ListLength(#params)), #params, #args, #canno*)

  rule AnalyzeMayReuseLambda(#env, #cterm, #params, #canno*)
  → #canno*

func AnalyzeMayReuseLambdaArity(Bool, List<String>, List<Core_cterm_sort>, List<Core_canno_sort>) -> List<Core_canno_sort>

  rule AnalyzeMayReuseLambdaArity(TRUE, #params, #args, #canno*)
  → If(CheckSameVariables(#params, #args),
      ()->canno*⟦ @Reuse ##canno* ⟧,
      ()->#canno*)

  rule AnalyzeMayReuseLambdaArity(FALSE, #params, #args, #canno*)
  → #canno*

// --- Meta-variable and variables lifetime analysis environment

type LArguments = PPair<List<Core_cterm_sort> List<Core_cterm_sort>>

enum LEnv | LEnv({String:Numeric}, // Map meta-variable name to number of times they are being used
                 {String:Numeric}, // Map -variable name to number of times they are being used.
                 {String:LArguments}) // Meta-variable parameters and bound variables

func LEnvNew -> LEnv → LEnv({},{},{})

func LEnvMetas(LEnv) -> {String:Numeric}
rule LEnvMetas(LEnv(#metas, #vars, #args)) → #metas

func LEnvVars(LEnv) -> {String:Numeric}
rule LEnvVars(LEnv(#metas, #vars, #args)) → #vars

// TODO: can't use alias due to issue #33
func LEnvArgs(LEnv) -> {String:PPair<List<Core_cterm_sort> List<Core_cterm_sort>>}
rule LEnvArgs(LEnv(#metas, #vars, #args)) → #args

func LEnvMetaKeys(LEnv) -> List<String>
rule LEnvMetaKeys(LEnv(#metas, #vars, #args)) → MapKeys(#metas)

func LEnvVarKeys(LEnv) ->  List<String>
rule LEnvVarKeys(LEnv(#metas, #vars, #args)) → MapKeys(#vars)

func LEnvGetMetaCount(#env: LEnv, #metavar: String) -> Option<Numeric>
→ MapGet(LEnvMetas(#env), #metavar)

func LEnvSetMetaCountO(LEnv, String, Option<Numeric>) -> LEnv

  rule LEnvSetMetaCountO(#env, #metavar, NONE)
  → LEnvRemoveMeta(#env, #metavar)

  rule LEnvSetMetaCountO(LEnv(#metas, #vars, #args), #metavar, SOME(#count))
  → LEnv(MapPut(#metas, #metavar, #count), #vars, #args)

func LEnvRemoveMeta(LEnv, String) -> LEnv
rule LEnvRemoveMeta(LEnv(#metas, #vars, #args), #metavar: String)
→ LEnv(MapRemove(#metas, #metavar), #vars, #args)

func LEnvIncMetaCount(#env: LEnv, #metavar: String) -> LEnv
→ LEnv(MapPut(LEnvMetas(#env), #metavar, IfPresent(LEnvGetMetaCount(#env, #metavar), (count)->Plus(count, 1), ()->1)), LEnvVars(#env), LEnvArgs(#env))

func LEnvGetVarCount(#env: LEnv, #var: String) -> Option<Numeric>
→ MapGet(LEnvVars(#env), #var)

func LEnvIncVarCount(#env: LEnv, #var: String) -> LEnv
→ LEnv(LEnvMetas(#env), MapPut(LEnvVars(#env), #var, IfPresent(LEnvGetVarCount(#env, #var), (count)->Plus(count, 1), ()->1)), LEnvArgs(#env))

func LEnvSetMetaArgs(#env: LEnv, #metavar: String, #params: List<Core_cterm_sort>, #bounds: List<Core_cterm_sort>) -> LEnv
→ LEnv(LEnvMetas(#env), LEnvVars(#env), MapPut(LEnvArgs(#env), #metavar, PairCons(#params, #bounds)))

func LEnvGetMetaParams(#env: LEnv, #metavar:String) -> List<Core_cterm_sort>
→ IfPresent(MapGet(LEnvArgs(#env), #metavar), (args)->Fst(args), ()->())
