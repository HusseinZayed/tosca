// Copyright (c) 2015 IBM Corporation.
/*
   Represent a complete Crsx system.
 
   A system is composed of modules. 
   Each module is composed of a set of data, functions and rules
 */
System[(

$Lax;

$Use["std/core.crs"];
$Use["std/env.crs"];
$Use["std/list.crs"];
$Use["std/map.crs"];
$Use["core/Core.crs"];

// --- System representation. 

/* A Crsx system as a list of modules */
System ::= ( System[$String /* Initial url */, MAP[$String, Module]]; ); 

/* Initialize system with main module */
InitSystem[$String] :: System;
InitSystem[#url] → System[#url, MapPut[MAP, #url, Module[#url, NOTLOADED]]];
  
/* A Crsx module  */
Module ::= ( Module[$String /* filename/module id */, Content /* of module */]; ); 

// --- module representation

/* Module content */
Content ::= ( 

    // Module not loaded yet.
    NOTLOADED;      

    // Module has been fully loaded into ContentEntry 
    Loaded[LoadedContent];       

    /*, STUB (might need a stub for fast compilation) */
);

/* The actual module content. Sorts and rules are indexed for fast lookup. */
LoadedContent ::= (
    LoadedContent[
           MAP[$String /* Constructor */, $List[Core_cdecl_sort]], /* Rules */
           MAP[$String /* Constructor */, Core_cdecl_sort],        /* DataSorts */ 
           MAP[$String /* Constructor */, Core_cdecl_sort]         /* FuncSorts */];
);

// --- System lookup functions.

/* 
  Gets module for given url.
  @return A module or NONE 
 */
LookupModule[System, $String /* url */] :: Option[Module];
LookupModule[System[#mainurl, #modules], #url] 
→ MapGet[#modules, #url];

/* Pick an not loaded module.
  @return A unloaded module or NONE 
 */
PickNotLoaded[System] :: Option[Module];
PickNotLoaded[System[#mainurl, #modules]] 
→ PickFirst[MapValues[#modules], x.IsNotLoaded[x]];

/* @return $True if module is not loaded */
IsNotLoaded[Module] :: $Boolean;
IsNotLoaded[Module[#url, NOTLOADED]]  → $True;
IsNotLoaded[Module[#url, Loaded[#c]]] → $False;

// --- System mutation functions.

/* 
  Put module for given url into system.
 */
PutModule[System, $String, Module] :: System;
PutModule[System[#mainurl, #modules], #url, #module] 
→ System[#mainurl, MapPut[#modules, #url, #module]];

// --- Loaded content mutation functions.

/* Add rule to module content. Always succeed. 
*/ 
PutRule[MAP[$String, $List[Core_cdecl_sort]], Core_cdecl_sort] :: MAP[$String, $List[Core_cdecl_sort]];
-[Data[#rules]]:
PutRule[#rules, {#L}%cdecl⟦ rule ##CONSTRUCTOR ##cterms? → ##cterm ⟧]
→ PutRule1[MapGet[#rules, #CONSTRUCTOR], #rules, #CONSTRUCTOR, {#L}%cdecl⟦ rule ##CONSTRUCTOR ##cterms? → ##cterm ⟧];

PutRule1[Option[$List[Core_cdecl_sort]], MAP[$String, $List[Core_cdecl_sort]], $String, Core_cdecl_sort] :: MAP[$String, $List[Core_cdecl_sort]];
PutRule1[NONE, #rules, #constructor, #rule]
→ MapPut[#rules, #constructor, (#rule;)];

PutRule1[SOME[#rulesForCons], #rules, #constructor, #rule]
→ MapPut[#rules, #constructor, Append[#rule, #rulesForCons]]; // Keep rules in order.

/*  Add data sort to module content. Fail if data sort already exists. 
*/ 
PutDataSort[MAP[$String, Core_cdecl_sort], Core_cdecl_sort] :: MAP[$String, Core_cdecl_sort];
-[Data[#data]]:
PutDataSort[#data, {#L}%cdecl⟦ data ##csortvars? ##CONSTRUCTOR ##cforms ⟧]
→ PutDataSort1[MapGet[#data, #CONSTRUCTOR], #data, #CONSTRUCTOR,  {#L}%cdecl⟦ data ##csortvars? ##CONSTRUCTOR ##cforms ⟧];

PutDataSort1[Option[Core_cdecl_sort], MAP[$String /* Constructor */, Core_cdecl_sort], $String, Core_cdecl_sort] :: MAP[$String, Core_cdecl_sort];
PutDataSort1[NONE, #data, #constructor, #decl]
→ MapPut[#data, #constructor, #decl];

PutDataSort1[SOME[#datasort], #data, #constructor, #rule]
→ $[Error, $[:, "Data sort already declared:", #constructor]];

/* Add function sort to module content. 
 */
PutFuncSort[MAP[$String, Core_cdecl_sort], Core_ccdecl_sort] :: MAP[$String, Core_cdecl_sort];
-[Data[#func]]:
PutFuncSort[#func, {#L}%cdecl⟦ func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧]
→ PutFuncSort1[MapGet[#func, #CONSTRUCTOR], #func, #CONSTRUCTOR,  {#L}%cdecl⟦ func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧];

PutFuncSort1[Option[Core_cdecl_sort], MAP[$String, Core_cdecl_sort], $String, Core_cdecl_sort] :: MAP[$String, Core_cdecl_sort];
PutFuncSort1[NONE, #func, #constructor, #decl]
→ MapPut[#func, #constructor, #decl];

PutFuncSort1[SOME[#datasort], #func, #constructor, #rule]
→ $[Error, $[:, "Function sort already declared:", #constructor]];

// --- Load core program into system

/*
   Loads core program 
   @param `Core_ccrsx_sort` core program 
   @return loaded core program into internal representation
 */
LoadCore[Core_ccrsx_sort] :: LoadedContent;
LoadCore[%ccrsx⟦ ##cdecl+ ⟧]
→ LoadDecls[#cdecl+, MAP, MAP, MAP];

LoadDecls[$List[Core_cdecl_sort]] :: LoadedContent;
LoadDecls[%cdecl+⟦⟧, #rules, #data, #func] 
→ LoadedContent[#rules, #data, #func];

LoadDecls[%cdecl+⟦ data ##csortvars? ##CONSTRUCTOR ##cforms ##cdecl+ ⟧, #rules, #data, #func] 
→ LoadDecls[#cdecl+, #rules, PutDataSort[#data, %cdecl⟦ data ##csortvars? ##CONSTRUCTOR ##cforms ⟧], #func];

LoadDecls[%cdecl+⟦ func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ##cdecl+ ⟧, #rules, #data, #func] 
→ LoadDecls[#cdecl+, #rules, #data, PutFuncSort[#func, %cdecl⟦ func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧]];

LoadDecls[%cdecl+⟦ rule ##cterm → ##cterm2 ##cdecl+  ⟧, #rules, #data, #func] 
→ LoadDecls[#cdecl+, PutRule[#rules, %cdecl⟦ rule  ##cterm → ##cterm2 ⟧], #data, #func];

)]