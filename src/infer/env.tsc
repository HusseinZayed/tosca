// Copyright (c) 2016 IBM Corporation.

import Std::Core
import Std::Mapdef
import Std::Listdef
import Std::Pairdef
import Std::Num
import Core::Core
import Systemdef

// --- Sort inference environment

/* Environment entry sort */
enum IEnvEntry | IContent(Content)       // read-only
               | ISystem(TSystem)        // read-only
               | ITerm(Core_cterm_sort)
               | ISort(Core_csort_sort)
               | IBool(Bool)
               | INum(Numeric)
               | IMapSort({String /* sort variable */: Core_csort_sort}) // Sort enviroment (usually called theta)
               | ISortArgs(List<List<Pair<String Core_csort_sort>>>) // map formal sort parameter to actual sort argument
               | ISorts(List<{String: Core_csort_sort}>) // Stack of (variable:sort) pairs
               | IMeta({String: Core_csort_sort}) // Metavar associated with sort

/* Corresponding unwrappers */
func UnIContent(IEnvEntry) -> Content
rule UnIContent(IContent(#)) → #

func UnISystem(IEnvEntry) -> TSystem
rule UnISystem(ISystem(#)) → #

func UnITerm(IEnvEntry) -> Core_cterm_sort
rule UnITerm(ITerm(#)) → #

func UnIBool(IEnvEntry) -> Bool
rule UnIBool(IBool(#)) → #

func UnINum(IEnvEntry) -> Numeric
rule UnINum(INum(#)) → #

func UnISort(IEnvEntry) -> Core_csort_sort
rule UnISort(ISort(#)) → #

func UnIMapSort(IEnvEntry) -> {String : Core_csort_sort}
rule UnIMapSort(IMapSort(#)) → #

func UnISortArgs(IEnvEntry) -> List<List<Pair<String Core_csort_sort>>>
rule UnISortArgs(ISortArgs(#)) → #

func UnISorts(IEnvEntry) -> List<{String:Core_csort_sort}>
rule UnISorts(ISorts(#)) → #

func UnIMeta(IEnvEntry) -> {String: Core_csort_sort}
rule UnIMeta(IMeta(#)) → #

/* Initialize environment */
func EnvNew(#content:Content, #system:TSystem) -> {String:IEnvEntry}
→ ISetFormalSorts(ISetBoundVarSorts(IResetCounter(ResetSortArgs(ResetSorts(ResetIMetas(SetInPattern(
    SetSystem(ISetContent(MapNew<String IEnvEntry>, #content), #system), TRUE))))), ()), ())

// --- Module content

func ISetContent(#env: {String : IEnvEntry}, #content: Content) -> {String : IEnvEntry}
→ ISetValue(#env, "content", IContent(#content))

func IGetContent(#env: {String : IEnvEntry}) -> Content
→ UnIContent(IGetValue(#env, "content"))

// --- System

func SetSystem(#env: {String : IEnvEntry}, #system: TSystem) -> {String : IEnvEntry}
→ ISetValue(#env, "system", ISystem(#system))

func GetSystem(#env: {String : IEnvEntry}) -> TSystem
→ UnISystem(IGetValue(#env, "system"))

// --- InPattern?

func SetInPattern(#env: {String : IEnvEntry}, #inpattern: Bool) -> {String : IEnvEntry}
→ ISetValue(#env, "inpattern", IBool(#inpattern))

func GetInPattern(#env: {String : IEnvEntry}) -> Bool
→ UnIBool(IGetValue(#env, "inpattern"))

// --- Stack of sort variable to sort variable argument mappings

/* Reset mapping stack */
func ResetSortArgs(#env: {String : IEnvEntry}) -> {String : IEnvEntry}
→ ISetValue(#env, "sortargs", ISortArgs(()))

func GetSortArgs(#env: {String : IEnvEntry}) -> List<List<Pair<String Core_csort_sort>>>
→ UnISortArgs(IGetValue(#env, "sortargs"))

/* Push the given mapping onto the stack  */
func PushSortArgs(#env: {String : IEnvEntry}, #mapping: List<Pair<String Core_csort_sort>>) -> {String : IEnvEntry}
→ ISetValue(#env, "sortargs", ISortArgs(Cons(#mapping, GetSortArgs(#env))))

func PopSortArgs(#env:{String : IEnvEntry}) -> {String : IEnvEntry}
→ ISetValue(#env, "sortargs", ISortArgs(Tail<List>(GetSortArgs(#env))))

func TopSortArgs(#env:{String : IEnvEntry}) -> List<Core_csortargs_sort>
→ TopSortArgsAux(Map<Pair Core_csort_sort>((pair)->Snd<String Core_csort_sort>(pair), Head<List>(GetSortArgs(#env))))

func TopSortArgsAux(List<Core_csort_sort>) -> List<Core_csortargs_sort>
rule TopSortArgsAux(csort*⟦⟧) → csortargs?⟦⟧
rule TopSortArgsAux(#csort*) → csortargs?⟦< ##csort* >⟧

func GetSortArg(#env: {String : IEnvEntry}, #sortvar:String) -> Option<Core_csort_sort>
→ HeadO<Core_csort_sort>(LookUp<String Core_csort_sort>(#sortvar, Flatten<Pair>(GetSortArgs(#env))))

// --- Sort argument counter to generate unique sort argument name

func IResetCounter(#env: {String : IEnvEntry}) -> {String : IEnvEntry}
→ ISetCounter(#env, 1)

func IGetCounter(#env: {String : IEnvEntry}) -> Numeric
→ UnINum(IGetValue(#env, "counter"))

func ISetCounter(#env: {String : IEnvEntry}, #num: Numeric) -> {String : IEnvEntry}
→ ISetValue(#env, "counter", INum(#num))

func IIncCounter(#env: {String : IEnvEntry}) -> {String : IEnvEntry}
→ ISetValue(#env, "counter", INum(Plus(IGetCounter(#env), 1)))

// --- Sort environment

/* Reset sort environment */
func ResetSorts(#env: {String : IEnvEntry}) -> {String : IEnvEntry}
→ ISetValue(#env, "sorts", IMapSort(MapNew<String Core_csort_sort>))

/* @return the sort environment */
func GetSorts(#env: {String : IEnvEntry}) -> {String:Core_csort_sort}
→ UnIMapSort(IGetValue(#env, "sorts"))

/* Set sort environment */
func SetSorts(#env: {String : IEnvEntry}, #sorts: {String:Core_csort_sort}) -> {String:IEnvEntry}
→ ISetValue(#env, "sorts", IMapSort(#sorts))

/* @return the sort associated to the given sort variable */
func GetSort(#env: {String : IEnvEntry}, #sortvar: String) -> Option<Core_csort_sort>
→ MapGet<String Core_csort_sort>(GetSorts(#env), #sortvar)

/* Add sort variable sort pair to the sort environment. Silently overrides the previous entry (if any) */
func PutSort(#env: {String : IEnvEntry}, #sortvar: String, #sort: Core_csort_sort) -> {String : IEnvEntry}
→ ISetValue(#env, "sorts", IMapSort(MapPut<String Core_csort_sort>(GetSorts(#env), #sortvar, #sort)))

// --- Stack of bound variable sorts

func IGetBoundVarSorts(#env: {String : IEnvEntry}) -> List<{String:Core_csort_sort}>
→ UnISorts(IGetValue(#env, "bvsorts"))

func ISetBoundVarSorts(#env: {String : IEnvEntry}, #sorts: List<{String: Core_csort_sort}>) -> {String : IEnvEntry}
→ ISetValue(#env, "bvsorts", ISorts(#sorts))

func IAddBoundVarSort<a>(#env: {String : IEnvEntry}, #var: a, #sort: Core_csort_sort) -> {String : IEnvEntry}
→ ISetBoundVarSorts(#env, IAddBinderSort<a>(IGetBoundVarSorts(#env), #var, #sort))

func IGetBoundVarSort<a>(#env: {String : IEnvEntry}, #var: a) -> Option<Core_csort_sort>
→ IGetBinderSort<a>(#env, #var, FALSE)

// --- Stack of formal parameters sorts

func IGetFormalSorts(#env: {String : IEnvEntry}) -> List<{String:Core_csort_sort}>
→ UnISorts(IGetValue(#env, "fsorts"))

func ISetFormalSorts(#env: {String : IEnvEntry}, #sorts: List<{String:Core_csort_sort}>) -> {String : IEnvEntry}
→ ISetValue(#env, "fsorts", ISorts(#sorts))

func IAddFormalSort<a>(#env: {String : IEnvEntry}, #var: a,  #sort: Core_csort_sort) -> {String : IEnvEntry}
→ ISetFormalSorts(#env, IAddBinderSort<a>(IGetBoundVarSorts(#env), #var, #sort))

func IGetFormalSort<a>(#env: {String : IEnvEntry}, #var: a) -> Option<Core_csort_sort>
→ IGetBinderSort<a>(#env, #var, TRUE)

// --- function manipulating both above stack synchronously

func IPushBinderSorts(#env: {String : IEnvEntry}) -> {String : IEnvEntry}
→ ISetFormalSorts(ISetBoundVarSorts(#env, Cons(MapNew<String Core_csort_sort>, IGetBoundVarSorts(#env))),
                 Cons(MapNew<String Core_csort_sort>, IGetFormalSorts(#env)))

func IResetBinderSorts(#env: {String : IEnvEntry}) -> {String : IEnvEntry}
→ IPushBinderSorts(IPopBinderSorts(#env))

func IPopBinderSorts(#env: {String : IEnvEntry}) -> {String : IEnvEntry}
→ ISetFormalSorts(ISetBoundVarSorts(#env, Tail<{String:Core_csort_sort}>(IGetBoundVarSorts(#env))),
                 Tail<{String:Core_csort_sort}>(IGetFormalSorts(#env)))

func IAddBinderSort<a>(List<{String: Core_csort_sort}>, a, Core_csort_sort) -> List<{String: Core_csort_sort}>
rule IAddBinderSort(Cons(#top:{String: Core_csort_sort}, #rest:List<{String: Core_csort_sort}>), #var, #sort) → Cons(MapPutVar<String Core_csort_sort a>(#top, #var, #sort), #rest)
rule IAddBinderSort((               ), #var, #sort) → Error<List<{String: Core_csort_sort}>>("Internal error: misused of binder sort stack in sort inference.")

func IGetBinderSort<a>(#env: {String : IEnvEntry}, #var: a, #formal: Bool) -> Option<Core_csort_sort>
→ IGetBinderSortAux<a>(If<List<{String:Core_csort_sort}>>(#formal, ()->IGetFormalSorts(#env), ()->IGetBoundVarSorts(#env)), #var)

func IGetBinderSortAux<a>(#entries: List<{String:Core_csort_sort}>, #var: a) -> Option<Core_csort_sort>
→ MaybeO<{String:Core_csort_sort} Core_csort_sort>((entries)->MapGetVar<String Core_csort_sort a>(entries, #var),
                                                   PickFirst<{String:Core_csort_sort}>(#entries, (entry)->HasOption<Core_csort_sort>(MapGetVar<String Core_csort_sort a>(entry, #var))))

// --- Meta

func GetIMetas(#env: {String : IEnvEntry}) -> {String: Core_csort_sort}
→ UnIMeta(IGetValue(#env, "metas"))

func SetIMetas(#env: {String : IEnvEntry}, #metas: {String: Core_csort_sort}) -> {String : IEnvEntry}
→ ISetValue(#env, "metas", IMeta(#metas))

func ResetIMetas(#env: {String : IEnvEntry}) -> {String : IEnvEntry}
→ SetIMetas(#env, MapNew<String Core_csort_sort>())

func GetIMeta(#env: {String : IEnvEntry}, #metavar:String) -> Option<Core_csort_sort>
→ MapGet<String Core_csort_sort>(GetIMetas(#env), #metavar)

func AddIMeta(#env: {String : IEnvEntry}, #metavar:String, #sort: Core_csort_sort) -> {String : IEnvEntry}
→ SetIMetas(#env, MapPut<String Core_csort_sort>(GetIMetas(#env), #metavar, #sort))

// --- Some generic helper functions

func IGetValue(#env: {String : IEnvEntry}, #key: String) -> IEnvEntry
→ UnSOME<IEnvEntry>(MapGet<String IEnvEntry>(#env, #key))

func ISetValue(#env: {String : IEnvEntry}, #key: String, #value: IEnvEntry) -> {String : IEnvEntry}
→ MapPut<String IEnvEntry>(#env, #key, #value)
