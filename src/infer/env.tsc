// Copyright (c) 2016 IBM Corporation.

import Std::Core
import Std::Mapdef
import Std::Listdef
import Std::Pairdef
import Std::String
import Std::Num
import Core::Core
import Systemdef

// --- Sort inference environment

/* Environment entry sort */
enum IEnvEntry | IContent(Content)       // read-only
               | ISystem(TSystem)        // read-only
               | ITerm(Core_cterm_sort)
               | ISort(Core_csort_sort)
               | IBool(Bool)
               | INum(Numeric)
               | IMapSort({String /* sort variable */: Core_csort_sort}) // Sort enviroment (usually called theta)
               | ISortArgs(List<Pair<String Core_csort_sort>>) // map declared sort parameter to actual sort argument
               | ISorts(List<{String: Core_csort_sort}>) // Stack of (variable:sort) pairs
               | IVar({String: Core_csort_sort}) // Metavar and variable associated with sort

/* Corresponding unwrappers */
func UnIContent(IEnvEntry) -> Content
rule UnIContent(IContent(#)) → #

func UnISystem(IEnvEntry) -> TSystem
rule UnISystem(ISystem(#)) → #

func UnITerm(IEnvEntry) -> Core_cterm_sort
rule UnITerm(ITerm(#)) → #

func UnIBool(IEnvEntry) -> Bool
rule UnIBool(IBool(#)) → #

func UnINum(IEnvEntry) -> Numeric
rule UnINum(INum(#)) → #

func UnISort(IEnvEntry) -> Core_csort_sort
rule UnISort(ISort(#)) → #

func UnIMapSort(IEnvEntry) -> {String : Core_csort_sort}
rule UnIMapSort(IMapSort(#)) → #

func UnISortArgs(IEnvEntry) -> List<Pair<String Core_csort_sort>>
rule UnISortArgs(ISortArgs(#)) → #

func UnISorts(IEnvEntry) -> List<{String:Core_csort_sort}>
rule UnISorts(ISorts(#)) → #

func UnIVar(IEnvEntry) -> {String: Core_csort_sort}
rule UnIVar(IVar(#)) → #

/* Initialize environment */
func IEnvNew(#content:Content, #system:TSystem) -> {String:IEnvEntry}
→ ISetFormalSorts(ISetBoundVarSorts(IResetCounter(ResetSorts(ResetIVars(SetInPattern(
    SetSystem(ISetContent(MapNew, #content), #system), TRUE)))), ()), ())

// --- Module content

func ISetContent(#env: {String : IEnvEntry}, #content: Content) -> {String : IEnvEntry}
→ ISetValue(#env, "content", IContent(#content))

func IGetContent(#env: {String : IEnvEntry}) -> Content
→ UnIContent(IGetValue(#env, "content"))

// --- System

func SetSystem(#env: {String : IEnvEntry}, #system: TSystem) -> {String : IEnvEntry}
→ ISetValue(#env, "system", ISystem(#system))

func GetSystem(#env: {String : IEnvEntry}) -> TSystem
→ UnISystem(IGetValue(#env, "system"))

// --- InPattern?

func SetInPattern(#env: {String : IEnvEntry}, #inpattern: Bool) -> {String : IEnvEntry}
→ ISetValue(#env, "inpattern", IBool(#inpattern))

func GetInPattern(#env: {String : IEnvEntry}) -> Bool
→ UnIBool(IGetValue(#env, "inpattern"))

// --- Declared sort variable to sort argument mapping

func SetSortArgsMap(#env: {String : IEnvEntry}, #mapping: List<Pair<String Core_csort_sort>>) -> {String : IEnvEntry}
→ ISetValue(#env, "sortargs", ISortArgs(#mapping))

func GetSortArgsMap(#env: {String : IEnvEntry}) -> List<Pair<String Core_csort_sort>>
→ UnISortArgs(IGetValue(#env, "sortargs"))

func GetSortArgs(#env: {String : IEnvEntry}) -> List<Core_csortargs_sort>
→ GetSortArgsAux(GetSortArgsMap(#env))

func GetSortArgsAux(List<Pair<String Core_csort_sort>>) -> List<Core_csortargs_sort>
rule GetSortArgsAux((          )) → csortargs?⟦⟧
rule GetSortArgsAux(Cons(#1, #2)) → csortargs?⟦ < ⟨csort*: UnZipS<String Core_csort_sort>(Cons(#1, #2))⟩ > ⟧


// --- Sort argument counter to generate unique sort argument name

func IResetCounter(#env: {String : IEnvEntry}) -> {String : IEnvEntry}
→ ISetCounter(#env, 1)

func IGetCounter(#env: {String : IEnvEntry}) -> Numeric
→ UnINum(IGetValue(#env, "counter"))

func ISetCounter(#env: {String : IEnvEntry}, #num: Numeric) -> {String : IEnvEntry}
→ ISetValue(#env, "counter", INum(#num))

func IIncCounter(#env: {String : IEnvEntry}) -> {String : IEnvEntry}
→ ISetValue(#env, "counter", INum(Plus(IGetCounter(#env), 1)))

// --- Sort environment

/* Reset sort environment */
func ResetSorts(#env: {String : IEnvEntry}) -> {String : IEnvEntry}
→ ISetValue(#env, "sorts", IMapSort(MapNew))

/* @return the sort environment */
func GetSorts(#env: {String : IEnvEntry}) -> {String:Core_csort_sort}
→ UnIMapSort(IGetValue(#env, "sorts"))

/* Set sort environment */
func SetSorts(#env: {String : IEnvEntry}, #sorts: {String:Core_csort_sort}) -> {String:IEnvEntry}
→ ISetValue(#env, "sorts", IMapSort(#sorts))

/* @return the sort associated to the given sort variable */
func GetSort(#env: {String : IEnvEntry}, #sortvar: String) -> Option<Core_csort_sort>
→ MapGet(GetSorts(#env), #sortvar)

/* @return true if it exists a equation mapping to the given sort variable */
func IsMapToSort(#env: {String : IEnvEntry}, #sortvar: String) -> Bool
→ HasOption(PickFirst(MapValues(GetSorts(#env)), (sort)->ISortEqual(sort, #sortvar)))

func ISortEqual(Core_csort_sort, String) -> Bool
rule ISortEqual(csort⟦ ##VARIABLE ⟧, #sortvar) → StringEqual(#VARIABLE, #sortvar)
rule ISortEqual(#csort             , #sortvar) → FALSE

/* Add sort variable sort pair to the sort environment. Silently overrides the previous entry (if any) */
func PutSort(#env: {String : IEnvEntry}, #sortvar: String, #sort: Core_csort_sort) -> {String : IEnvEntry}
→ ISetValue(#env, "sorts", IMapSort(MapPut(GetSorts(#env), #sortvar, #sort)))

// --- Stack of bound variable sorts

func IGetBoundVarSorts(#env: {String : IEnvEntry}) -> List<{String:Core_csort_sort}>
→ UnISorts(IGetValue(#env, "bvsorts"))

func ISetBoundVarSorts(#env: {String : IEnvEntry}, #sorts: List<{String: Core_csort_sort}>) -> {String : IEnvEntry}
→ ISetValue(#env, "bvsorts", ISorts(#sorts))

func IAddBoundVarSort<a>(#env: {String : IEnvEntry}, #var: a, #sort: Core_csort_sort) -> {String : IEnvEntry}
→ ISetBoundVarSorts(#env, IAddBinderSort(IGetBoundVarSorts(#env), #var, #sort))

func IGetBoundVarSort<a>(#env: {String : IEnvEntry}, #var: a) -> Option<Core_csort_sort>
→ IGetBinderSort<a>(#env, #var, FALSE)

// --- Stack of formal parameters sorts

func IGetFormalSorts(#env: {String : IEnvEntry}) -> List<{String:Core_csort_sort}>
→ UnISorts(IGetValue(#env, "fsorts"))

func ISetFormalSorts(#env: {String : IEnvEntry}, #sorts: List<{String:Core_csort_sort}>) -> {String : IEnvEntry}
→ ISetValue(#env, "fsorts", ISorts(#sorts))

func IAddFormalSort<a>(#env: {String : IEnvEntry}, #var: a,  #sort: Core_csort_sort) -> {String : IEnvEntry}
→ ISetFormalSorts(#env, IAddBinderSort(IGetFormalSorts(#env), #var, #sort))

func IGetFormalSort<a>(#env: {String : IEnvEntry}, #var: a) -> Option<Core_csort_sort>
→ IGetBinderSort(#env, #var, TRUE)

// --- function manipulating both above stack synchronously

func IPushBinderSorts(#env: {String : IEnvEntry}) -> {String : IEnvEntry}
→ ISetFormalSorts(ISetBoundVarSorts(#env, Cons(MapNew, IGetBoundVarSorts(#env))),
                 Cons(MapNew, IGetFormalSorts(#env)))

func IResetBinderSorts(#env: {String : IEnvEntry}) -> {String : IEnvEntry}
→ IPushBinderSorts(IPopBinderSorts(#env))

func IPopBinderSorts(#env: {String : IEnvEntry}) -> {String : IEnvEntry}
→ ISetFormalSorts( ISetBoundVarSorts(#env, Tail(IGetBoundVarSorts(#env))), Tail(IGetFormalSorts(#env)))

func IAddBinderSort<a>(List<{String: Core_csort_sort}>, a, Core_csort_sort) -> List<{String: Core_csort_sort}>
rule IAddBinderSort(Cons(#top, #rest), #var, #sort) → Cons(MapPutVar(#top, #var, #sort), #rest)
rule IAddBinderSort((               ), #var, #sort) → Error("Internal error: misused of binder sort stack in sort inference.")

func IGetBinderSort<a>(#env: {String : IEnvEntry}, #var: a, #formal: Bool) -> Option<Core_csort_sort>
→ IGetBinderSortAux(If(#formal, ()->IGetFormalSorts(#env), ()->IGetBoundVarSorts(#env)), #var)

func IGetBinderSortAux<a>(#entries: List<{String:Core_csort_sort}>, #var: a) -> Option<Core_csort_sort>
→ MaybeO((entries)->MapGetVar(entries, #var),
         PickFirst(#entries, (entry)->HasOption(MapGetVar(entry, #var))))

// --- Meta variable and free/fresh variable

func GetIVars(#env: {String : IEnvEntry}) -> {String: Core_csort_sort}
→ UnIVar(IGetValue(#env, "metas"))

func SetIVars(#env: {String : IEnvEntry}, #metas: {String: Core_csort_sort}) -> {String : IEnvEntry}
→ ISetValue(#env, "metas", IVar(#metas))

func ResetIVars(#env: {String : IEnvEntry}) -> {String : IEnvEntry}
→ SetIVars(#env, MapNew())

func GetIMetaVar(#env: {String : IEnvEntry}, #metavar:String) -> Option<Core_csort_sort>
→ MapGet(GetIVars(#env), #metavar)

func GetIVar(#env: {String : IEnvEntry}, #var:String) -> Option<Core_csort_sort>
→ MapGetVar(GetIVars(#env), #var)

func AddIMetaVar(#env: {String : IEnvEntry}, #metavar:String, #sort: Core_csort_sort) -> {String : IEnvEntry}
→ SetIVars(#env, MapPut(GetIVars(#env), #metavar, #sort))

func AddIVar(#env: {String : IEnvEntry}, #var:String, #sort: Core_csort_sort) -> {String : IEnvEntry}
→ SetIVars(#env, MapPutVar(GetIVars(#env), #var, #sort))

// --- Some generic helper functions

func IGetValue(#env: {String : IEnvEntry}, #key: String) -> IEnvEntry
→ UnSOME(MapGet(#env, #key))

func ISetValue(#env: {String : IEnvEntry}, #key: String, #value: IEnvEntry) -> {String : IEnvEntry}
→ MapPut(#env, #key, #value)
