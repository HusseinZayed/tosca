// Copyright (c) 2016 IBM Corporation.
/*
  Propagate missing sort annotations and sort variables, but only to compensate the target language limitations.

  For Java:
  - Sort parameters must be instantiated (eg. ListLength<Numeric>(...))
  - Meta-variable sort annotations must be specified (meta-variable declarations only)
  - Data constructor must be prefixed by their sort. (eg. List<a>::Cons) (for now in pattern only)

  For C++:
  - ...

  Also perform opportunistic sort checking. The full complete sort checking is done by the target language

  The sort inference below is done in two passes:
  - The first pass propagates sorts bottom-up. Unspecified sorts are retrieved from sort declarations. The sort environment is extended with sort instantiations.
  - The second pass first starts by solving sort equations stored in the sort environment and then apply sort variable instantiations.
    by traversing the term tree top-down.

 */
import Std::Core
import Std::Listdef
import Std::Pairdef
import Std::Mapdef
import Std::String
import Core::Core
import Core::Utils
import Infer::Env
import Systemdef

// --- API

/* Infer sorts of given `#`
   @param System The Tosca system */
func InferM(#system: TSystem, #module: Module) -> Module
→ IfConfigDef<Module>(#system, "infer",
    (v) -> SetModuleContent(#module, InferContent(GetModuleContent(#module), #system)),
    ( ) -> #module)

// -- Content

func InferContent(#content: Content, #system: TSystem) -> Content
→ FoldlP<String Content>((key content) -> InferRules(key, UnSOME<List>(GetRulesForKeyC(content, key)), content, #system),
                         #content,
                         MapKeys<String List>(GetRules(#content)))

// -- Rules

func InferRules(#key: String, #rules: List<Core_cdecl_sort>, #content: Content, #system: TSystem) -> Content
→ PutRulesC(#content, #key, Map<Core_cdecl_sort Core_cdecl_sort>((rul) -> InferRule(EnvNew(#content, #system), rul), #rules))

// -- Rule

func InferRule({String:EnvEntry}, Core_cdecl_sort) -> Core_cdecl_sort
rule InferRule(#env, cdecl⟦ rule ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? → ##cterm ⟧)
→ InferPatternUp(InferFunc(ResetEnv(#env), #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, NONE), #cterm, FindFuncSortS(GetSystem(#env), #CONSTRUCTOR))

func InferPatternUp(Pair<{String:EnvEntry} Core_cterm_sort>, Core_cterm_sort, Option<Core_cdecl_sort>) -> Core_cdecl_sort
rule InferPatternUp(PairCons(#env:{String:EnvEntry}, #pattern:Core_cterm_sort), #contractum, SOME(cdecl⟦ ##canno* ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧))
→ InferRuleUp(#pattern, InferTerm(SetInPattern(ResetEnv(#env), FALSE), #contractum, #csort))

func InferRuleUp(Core_cterm_sort, Pair<{String:EnvEntry} Core_cterm_sort>) -> Core_cdecl_sort
rule InferRuleUp(#cterm1, PairCons(#env:{String:EnvEntry}, #cterm2:Core_cterm_sort)) → SubstRule(OptimizeSorts(#env), #cterm1, #cterm2)

// ---- Synthesize sorts

// --- Terms

/* Synthesize term sort.
   @return a pair consisting of an updated environment and the sorted term (which might contain sort variables)
*/
func InferTerm({String:EnvEntry}, Core_cterm_sort, Core_csort_sort /* formal sort */) -> Pair<{String:EnvEntry} Core_cterm_sort>

  rule InferTerm(#env, cterm⟦ ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #fsort)
  → InferCons(#env, GetInPattern(#env), IsDataS(GetSystem(#env), #CONSTRUCTOR), #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #fsort)

  rule InferTerm(#env, cterm⟦ ##STRING ⟧, #fsort) → PairCons(UnifySort(#env, #fsort, csort⟦ String  ⟧), cterm⟦ ##STRING ⟧)
  rule InferTerm(#env, cterm⟦ ##NUMBER ⟧, #fsort) → PairCons(UnifySort(#env, #fsort, csort⟦ Numeric ⟧), cterm⟦ ##NUMBER ⟧)

  // TODO: traverse when contraction
  // metavar arguments on pattern must all be variables. No need to traverse. TODO: could check arity
  rule InferTerm(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #csort)
  // TODO: enable when issue #15 is fixed
  //→ CheckSortAnnoE<Pair<{String:EnvEntry} Core_cterm_sort>>(#csortanno?, #csort, () -> PairCons(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? : ##csort ⟧))
  → PairCons(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? : ##csort ⟧)

  // TODO:
  rule InferTerm(#env, cterm⟦ ##VARIABLE ##csortanno? ⟧, #fsort) // TODO: could check sort annotation
  → PairCons(#env, cterm⟦ ##VARIABLE ##csortanno? ⟧)

  rule InferTerm(#env, cterm⟦ [ v ##csortanno? ] ##cterm ⟧, csort⟦ [ ##csort1 ] ##csort ⟧)
  → CheckSortAnnoE<Pair<{String:EnvEntry} Core_cterm_sort>>(#csortanno?, #csort1, ()->InferBinderUp([v] -> InferTerm(#env, #cterm[v], #csort), #csort1))

  rule InferTerm(#env, cterm⟦ [ v ##csortanno? ] ##cterm ⟧, #fsort)
  → Error<Pair<{String:EnvEntry} Core_cterm_sort>>("Type error") // TODO:

  rule InferTerm(#env, cterm⟦ ( f ##csortanno? ) ##cterm ⟧, csort⟦ ( ##csort1 ) ##csort ⟧)
  → CheckSortAnnoE<Pair<{String:EnvEntry} Core_cterm_sort>>(#csortanno?, #csort1, ()->InferFormalUp([f] -> InferTerm(#env, #cterm[f], #csort), #csort1))

  rule InferTerm(#env, cterm⟦ ( f ##csortanno? ) ##cterm ⟧, #fsort) → Error<Pair<{String:EnvEntry} Core_cterm_sort>>("Type error") // TODO:
  rule InferTerm(#env, cterm⟦ thunk ##cterm              ⟧, #fsort) → InferTerm(#env, #cterm, #fsort)

/* Traverse terms if any */
func InferMaybeTerms({String:EnvEntry}, List<Core_cterms_sort>, List<Core_csort_sort>) -> Pair<{String:EnvEntry} List<Core_cterms_sort>>
rule InferMaybeTerms(#env, cterms?⟦              ⟧, #fsort*) → PairCons(#env, cterms?⟦⟧) // TODO: check sort arity
rule InferMaybeTerms(#env, cterms?⟦ (          ) ⟧, #fsort*) → PairCons(#env, cterms?⟦⟧)  // TODO: check sort arity
rule InferMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧, #fsort*) → UnPair<{String:EnvEntry} List Pair>(InferTerms(#env, #cterm*, #fsort*), (env terms)->PairCons(env, cterms?⟦ ( ⟨cterm*: terms⟩ )⟧))

/* Traverse terms */
func InferTerms({String:EnvEntry}, List<Core_cterm_sort>, List<Core_csort_sort>) -> Pair<{String:EnvEntry} List<Core_cterm_sort>>
rule InferTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, csort*⟦ ##csort ##csort* ⟧) → InferTermsUp(InferTerm(#env, #cterm, #csort), #cterm*, #csort*)
rule InferTerms(#env, cterm*⟦                  ⟧, csort*⟦                  ⟧) → PairCons(#env, cterm*⟦⟧)
rule InferTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, csort*⟦                  ⟧) → Error<Pair<{String:EnvEntry} List<Core_cterm_sort>>>("Error: too many arguments.")
rule InferTerms(#env, cterm*⟦                  ⟧, csort*⟦ ##csort ##csort* ⟧) → Error<Pair<{String:EnvEntry} List<Core_cterm_sort>>>("Error: not enough arguments.")

/* Reconstruct terms */
func InferTermsUp(Pair<{String:EnvEntry} Core_cterm_sort>, List<Core_cterm_sort>, List<Core_csort_sort>) -> Pair<{String:EnvEntry} List<Core_cterm_sort>>
rule InferTermsUp(PairCons(#env:{String:EnvEntry} , #cterm:Core_cterm_sort), #cterm*, #csort*)
→ UnPair<{String:EnvEntry} List Pair>(InferTerms(#env, #cterm*, #csort*), (env cterms) -> PairCons(env, cterm*⟦ ##cterm ⟨cterm*: cterms⟩⟧))

/* Synthesize construction sort
   @param `#env`
   @param `#inpattern`
   @param `#isdatasort`
 */
func InferCons({String:EnvEntry}, Bool, Bool, String, List<Core_csortargs_sort>, List<Core_cterms_sort>, List<Core_csortanno_sort>, Core_csort_sort) -> Pair<{String:EnvEntry} Core_cterm_sort>

  rule InferCons(#env, #inpattern, TRUE, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #fsort)
  → InferConsUp(#CONSTRUCTOR, InferDataSubs(UnifySortArgs(#env, (), ()), #cterms?, FindFormS(GetSystem(#env), #fsort, #CONSTRUCTOR), #CONSTRUCTOR, #fsort), SOME(#fsort))

  rule InferCons(#env, FALSE, FALSE, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #fsort)
  → InferFunc(#env, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, SOME(#fsort))

  rule InferCons(#env, TRUE, FALSE, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #fsort)
  → Error<Pair<{String:EnvEntry} Core_cterm_sort>>(ConcatString("Error: function symbol cannot occur in pattern: ", #CONSTRUCTOR))

/* Reconstruct construction */
func InferConsUp(String, Pair<{String:EnvEntry} List<Core_cterms_sort>>, Option<Core_csort_sort>) -> Pair<{String:EnvEntry} Core_cterm_sort>
  rule InferConsUp(#CONSTRUCTOR, PairCons(#env:{String:EnvEntry}, #cterms?:List<Core_cterms_sort>), SOME(#csort:Core_csort_sort))
  → PairCons(PopSortArgs(#env), cterm⟦ ##csort :: ##CONSTRUCTOR ⟨csortargs?: TopSortArgs(#env)⟩ ##cterms? : ##csort ⟧)

  rule InferConsUp(#CONSTRUCTOR, PairCons(#env:{String:EnvEntry}, #cterms?:List<Core_cterms_sort>), NONE)
  → PairCons(PopSortArgs(#env), cterm⟦ ##CONSTRUCTOR ⟨csortargs?: TopSortArgs(#env)⟩ ##cterms? ⟧)

/* Infer sorts for function application. */
func InferFunc(#env: {String:EnvEntry}, #CONSTRUCTOR: String, #csortargs?: List<Core_csortargs_sort>, #cterms?: List<Core_cterms_sort>,
                  #csortanno?: List<Core_csortanno_sort>, #fsort: Option<Core_csort_sort>) -> Pair<{String:EnvEntry} Core_cterm_sort>
→ InferConsUp(#CONSTRUCTOR, InferFuncSubs(#env, FindFuncSortS(GetSystem(#env), #CONSTRUCTOR), #csortargs?, #cterms?, #CONSTRUCTOR), #fsort)

/* Traverse data construction sub terms */
func InferDataSubs({String:EnvEntry}, List<Core_cterms_sort>, Option<Pair<Core_csort_sort Core_cform_sort>>, String, Core_csort_sort) -> Pair<{String:EnvEntry} List<Core_cterms_sort>>
rule InferDataSubs(#env, #cterms?, SOME(Pair<Core_csort_sort Core_cform_sort>::PairCons(#csort:Core_csort_sort, cform⟦ ##CONSTRUCTOR ( ##csort* ) ⟧)), #formname, #fsort) → InferMaybeTerms(UnifySort(#env, #fsort, #csort), #cterms?, #csort*)
rule InferDataSubs(#env, cterms?⟦⟧, SOME(Pair<Core_csort_sort Core_cform_sort>::PairCons(#csort:Core_csort_sort, cform⟦ ##CONSTRUCTOR              ⟧)), #formname, #fsort) → PairCons(UnifySort(#env, #fsort, #csort), cterms?⟦⟧)
rule InferDataSubs(#env, cterms?⟦()⟧, SOME(Pair<Core_csort_sort Core_cform_sort>::PairCons(#csort:Core_csort_sort, cform⟦ ##CONSTRUCTOR              ⟧)), #formname, #fsort) → PairCons(UnifySort(#env, #fsort, #csort), cterms?⟦⟧)
rule InferDataSubs(#env, #cterms?, NONE                                    , #formname, #fsort) → Error<Pair>(ConcatString("Error: undefined enumeration value ", #formname)) // TODO: in sort #fsort
rule InferDataSubs(#env, #cterms?, SOME(Pair<Core_csort_sort Core_cform_sort>::PairCons(#csort:Core_csort_sort, #cform: Core_cform_sort))           , #formname, #fsort) → Error<Pair>(ConcatString("Error: wrong arity for enumeration value ", #formname))

/* Traverse function construction sub terms */
func InferFuncSubs({String:EnvEntry}, Option<Core_cdecl_sort>, List<Core_csortargs_sort>, List<Core_cterms_sort>, String) -> Pair<{String:EnvEntry} List<Core_cterms_sort>>
rule InferFuncSubs(#env, SOME(cdecl⟦ ##canno* ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ( ##csort* ) ⟧), #csortargs?, #cterms?, #funcname) → InferMaybeTerms(UnifySortArgs(#env, #csortvars?, #csortargs?), #cterms?, #csort*)
rule InferFuncSubs(#env, SOME(cdecl⟦ ##canno* ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ⟧), #csortargs?, cterms?⟦⟧, #funcname) → PairCons(UnifySortArgs(#env, #csortvars?, #csortargs?), cterms?⟦⟧)
rule InferFuncSubs(#env, NONE                                                                         , #csortargs?, cterms?⟦⟧, #funcname) → Error<Pair>(ConcatString("Error: undeclared function named ", #funcname))
rule InferFuncSubs(#env, SOME(#cdecl:Core_cdecl_sort)                                                 , #csortargs?, #cterms?, #funcname) → Error<Pair>(ConcatString("Error: wrong arity for function ", #funcname))

/* Reconstruct binder */
// Note: #env is weak.
func InferBinderUp([String] -> Pair<{String:EnvEntry} Core_cterm_sort>, Core_csort_sort) -> Pair<{String:EnvEntry} Core_cterm_sort>
rule InferBinderUp([b] -> PairCons(#env:{String:EnvEntry}, #cterm[b]:Core_cterm_sort), #csort) → PairCons(#env, cterm⟦ [ b : ##csort ] ##cterm ⟧)

/* Reconstruct formal parameter */
// Note: #env is weak.
func InferFormalUp([String] -> Pair<{String:EnvEntry} Core_cterm_sort>, Core_csort_sort) -> Pair<{String:EnvEntry} Core_cterm_sort>
rule InferFormalUp([f] -> PairCons(#env:{String:EnvEntry}, #cterm[f]:Core_cterm_sort), #csort) → PairCons(#env, cterm⟦ ( f : ##csort ) ##cterm ⟧)

// --- Sort unification

/* Unify `#sort1` such that under a set of substitutions it is equal to `#sort2`.
   @param `#env` the environment containing the sort environment and sort argument mappings
   @param `#sort1` formal sort
   @param `#sort2` actual sort
   @return The environment containing an updated sort environment with substitutions unifying `#sort1` and  `#sort2`.
          If no such substitution is found, an error is raised.
 */
func UnifySort({String:EnvEntry}, Core_csort_sort, Core_csort_sort) -> {String:EnvEntry}

  rule UnifySort(#env, csort⟦ ##CONSTRUCTOR ##csorts? ⟧, csort⟦ ##CONSTRUCTOR2 ##csorts?2 ⟧)
  //→ CheckConstructor(#CONSTRUCTOR, #CONSTRUCTOR2, ()->CheckArity(#csorts?, #csorts?2, ()->UnifyMaybeSorts(#env, #csorts?, #csorts?)))
  → UnifyMaybeSorts(#env, #csorts?, #csorts?2)

  rule UnifySort(#env, csort⟦ ##VARIABLE ⟧, #csort)
  → UnifySortVar(#env, #VARIABLE, GetSortArg(#env, #VARIABLE), #csort)

  rule UnifySort(#env, #csort, csort⟦ ##VARIABLE ⟧)
  → UnifySortVar2(#env, GetSort(#env, #VARIABLE), #VARIABLE, #csort)

  rule UnifySort(#env, csort⟦ [ ##csort11 ] ##csort12 ⟧, csort⟦ [ ##csort21 ] ##csort22 ⟧)
  → UnifySort(UnifySort(#env, #csort11, #csort21), #csort12, #csort22)

  rule UnifySort(#env, csort⟦ ( ##csort11 ) ##csort12 ⟧, csort⟦ ( ##csort21 ) ##csort22 ⟧)
  → UnifySort(UnifySort(#env, #csort11, #csort21), #csort12, #csort22)

  rule UnifySort(#env, csort⟦ { ##csort11 : ##csort12 } ⟧, csort⟦ { ##csort21 : ##csort22 } ⟧)
  → UnifySort(UnifySort(#env, #csort11, #csort21), #csort12, #csort22)

  rule UnifySort(#env, csort⟦ thunk ##csort1 ⟧, #csort2) → UnifySort(#env, #csort1, #csort2)
  rule UnifySort(#env, #csort1, csort⟦ thunk ##csort2 ⟧) → UnifySort(#env, #csort1, #csort2)
  rule UnifySort(#env, csort⟦ data ##csort1 ⟧, #csort2)  → UnifySort(#env, #csort1, #csort2)
  rule UnifySort(#env, #csort1, csort⟦ data ##csort2 ⟧)  → UnifySort(#env, #csort1, #csort2)

  rule UnifySort(#env, #csort1, #csort2                ) → Error<{String:Core_csort_sort}>(ConcatString("Error: type ", ConcatString(PrintSort(#csort2), ConcatString(" is not an instance of type ", PrintSort(#csort1)))))

// -- Sub sorts

func UnifyMaybeSorts({String:EnvEntry}, List<Core_csorts_sort>, List<Core_csorts_sort>) -> {String:EnvEntry}
rule UnifyMaybeSorts(#env, csorts?⟦              ⟧, csorts?⟦               ⟧) → #env
rule UnifyMaybeSorts(#env, csorts?⟦ ( ##csort*1 )⟧, csorts?⟦ ( ##csort*2 ) ⟧) → UnifySorts(#env, #csort*1, #csort*2)

func UnifySorts({String:EnvEntry}, List<Core_csort_sort>, List<Core_csort_sort>) -> {String:EnvEntry}
rule UnifySorts(#env, csort*⟦                    ⟧, csort*⟦                    ⟧) → #env
rule UnifySorts(#env, csort*⟦ ##csort1 ##csort*1 ⟧, csort*⟦ ##csort2 ##csort*2 ⟧) → UnifySorts(UnifySort(#env, #csort1, #csort2), #csort*1, #csort*2)
rule UnifySorts(#env, #csort*1, #csort*2) → Error<{String:EnvEntry}>("Error: mismatched type arity for type XX and YY") // TODO

// -- Variable

func UnifySortVar({String:EnvEntry}, String, Option<String>, Core_csort_sort) -> {String:EnvEntry}
rule UnifySortVar(#env, #variable, NONE                 , #csort) → Error<{String:Core_csort_sort}>(ConcatString("Error: undeclared type variable ", #variable))
rule UnifySortVar(#env, #variable, SOME(#sortarg:String), #csort) → UnifySortVar2(#env, GetSort(#env, #sortarg), #sortarg, #csort)

func UnifySortVar2({String:EnvEntry}, Option<Core_csort_sort>, String, Core_csort_sort) -> {String:EnvEntry}
  // Case 1: no existing mapping. Create it
  rule UnifySortVar2(#env, NONE, #csortarg, #csort) → PutSort(#env, #csortarg, #csort)

  // Case 2: there is already a mapping to a sort variable and new sort is also a sort variable
  rule UnifySortVar2(#env, SOME(csort⟦ ##VARIABLE1 ⟧), #csortarg, csort⟦ ##VARIABLE2 ⟧)
  → If<{String:Core_csort_sort}>(StringEqual(#VARIABLE1, #VARIABLE2),
      // Same variable, nothing to do
      ()->#env,
      // Not the same variable. Instantiate both directions
      ()->UnifySortVar(UnifySortVar(#env, #VARIABLE2, SOME(#VARIABLE2), csort⟦ ##VARIABLE1 ⟧), #VARIABLE1, SOME(#VARIABLE1), csort⟦ ##VARIABLE2 ⟧))

  // Case 3, there is already a mapping to a sort variable.
  rule UnifySortVar2(#env, SOME(csort⟦ ##VARIABLE1 ⟧), #csortarg, #csort)
  → UnifySortVar(#env, #VARIABLE1, SOME(#VARIABLE1), #csort)

  // Case 4, there is already a mapping to a sort that is not a variable
  rule UnifySortVar2(#env, SOME(#csort:Core_csort_sort), #csortarg, csort⟦ ##VARIABLE2 ⟧)
  → UnifySortVar(#env, #VARIABLE2, SOME(#VARIABLE2), #csort)

  // Case 5, there is already a mapping to non sort variables
  rule UnifySortVar2(#env, SOME(#csort1:Core_csort_sort), #csortarg, #csort2)
  → #env // TODO: could check csort1 = csort2

// --- Sort variable instantiation

/* Instantiate sort variables.

   Works as follows:
   - a variable sort argument is created for each sort variables (if any) and the correspondence
     between them is kept in the environment (see XXSortArgs functions).
   - the sort environment is extended with user-specified sort arguments (if any).
 */
func UnifySortArgs({String:EnvEntry}, List<Core_csortvars_sort>, List<Core_csortargs_sort>) -> {String:EnvEntry}
rule UnifySortArgs(#env, csortvars?⟦                     ⟧, csortargs?⟦             ⟧) → PushSortArgs(#env, ())
rule UnifySortArgs(#env, csortvars?⟦ ∀ ##variable_TOK+ . ⟧, csortargs?⟦             ⟧) → UnifySortArgs2(#env, #variable_TOK+, csort*⟦⟧, ())
rule UnifySortArgs(#env, csortvars?⟦ ∀ ##variable_TOK+ . ⟧, csortargs?⟦ < ##csort* >⟧) → UnifySortArgs2(#env, #variable_TOK+, #csort*, ())

func UnifySortArgs2(#env: {String:EnvEntry}, #sortvars: List<String>, #csort*: List<Core_csort_sort>, #mapping: List<Pair<String String>>) -> {String:EnvEntry}
→ UnifySortArgs3(IncCounter(#env), ConcatString("a", FormatNumber(GetCounter(#env))), #sortvars, #csort*, #mapping)

func UnifySortArgs3({String:EnvEntry}, String, List<String>, List<Core_csort_sort>, List<Pair<String String>>) -> {String:EnvEntry}

  rule UnifySortArgs3(#env, #sortvararg, Cons(#sortvar:String, #sortvars:List<String>), #csort*, #mapping)
  → UnifySortArgs4(#env, #sortvararg, #sortvars, #csort*, Append<Pair>(PairCons(#sortvar, #sortvararg), #mapping))

  rule UnifySortArgs3(#env, #sortvararg, Nil, #csort*, #mapping) → PushSortArgs(#env, #mapping)

func UnifySortArgs4({String:EnvEntry}, String, List<String>, List<Core_csort_sort>, List<Pair<String String>>) -> {String:EnvEntry}

  rule UnifySortArgs4(#env, #sortvararg, #sortvars, csort*⟦⟧, #mapping)
  → UnifySortArgs2(#env, #sortvars, csort*⟦⟧, #mapping)

  rule UnifySortArgs4(#env, #sortvararg, #sortvars, csort*⟦ ##csort ##csort* ⟧, #mapping)
  → UnifySortArgs2(PutSort(#env, #sortvararg, #csort), #sortvars, #csort*, #mapping)

// ---- Sort environment optimizer

/* Optimize the sort environment by computing its transitive closure. */
func OptimizeSorts(#env: {String : EnvEntry}) -> {String : EnvEntry}
→ SetSorts(#env, FoldlP<String {String : Core_csort_sort}>((key sorts) -> OptimizeSort(sorts, (key,), MapGet<String Core_csort_sort>(sorts, key)), GetSorts(#env), MapKeys<String Core_csort_sort>(GetSorts(#env))))

func OptimizeSort({String : Core_csort_sort}, List<String>, Option<Core_csort_sort>) -> {String : Core_csort_sort}
rule OptimizeSort(#sorts, #keys, SOME(csort⟦ ##VARIABLE ⟧))   → OptimizeSort(#sorts, Cons(#VARIABLE, #keys), MapGet<String Core_csort_sort>(#sorts, #VARIABLE))
rule OptimizeSort(#sorts, #keys, SOME(#sort:Core_csort_sort)) → FoldlP<String {String : Core_csort_sort}>((key sorts)->MapPut<String Core_csort_sort>(sorts, key, #sort), #sorts, #keys)
rule OptimizeSort(#sorts, #keys, NONE                    )    → #sorts

// ---- Apply sort instantiation

// TODO: check for empty sort environment.
func SubstRule(#env: {String:EnvEntry}, #cterm1: Core_cterm_sort, #cterm2: Core_cterm_sort) -> Core_cdecl_sort
→ cdecl⟦ rule ⟨cterm: SubstTerm(#env, #cterm1)⟩ → ⟨cterm: SubstTerm(#env, #cterm2)⟩ ⟧

func SubstTerm({String:EnvEntry}, Core_cterm_sort) -> Core_cterm_sort
rule SubstTerm(#env, cterm⟦ ##cqconstructor ##csortargs? ##cterms? ##csortanno? ⟧) → cterm⟦ ##cqconstructor ⟨csortargs?: SubstMaybeSortArgs(#env, #csortargs?)⟩ ⟨cterms?: SubstMaybeTerms(#env, #cterms?)⟩ ⟨csortanno?: SubstMaybeSortAnno(#env, #csortanno?)⟩ ⟧
rule SubstTerm(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧)          → cterm⟦ ##METAVAR ⟨cterms?: SubstMaybeTerms(#env, #cterms?)⟩ ⟨csubst?: SubstMaybeSubst(#env, #csubst?)⟩ ⟨csortanno?: SubstMaybeSortAnno(#env, #csortanno?)⟩ ⟧
rule SubstTerm(#env, cterm⟦ [ x ##csortanno? ] ##cterm ⟧)                          → cterm⟦ [ x ##csortanno? ] ##cterm ⟧
rule SubstTerm(#env, cterm⟦ ( f ##csortanno? ) ##cterm ⟧)                          → cterm⟦ ( f ##csortanno? ) ##cterm ⟧
rule SubstTerm(#env, #cterm)                                                      → #cterm
// TODO: map

func SubstMaybeSortArgs({String:EnvEntry}, List<Core_csortargs_sort>) -> List<Core_csortargs_sort>
rule SubstMaybeSortArgs(#env, csortargs?⟦              ⟧) → csortargs?⟦⟧
rule SubstMaybeSortArgs(#env, csortargs?⟦ < ##csort* > ⟧) → csortargs?⟦ < ⟨csort*: SubstSorts(#env, #csort*)⟩ >⟧

func SubstMaybeTerms({String:EnvEntry}, List<Core_cterms_sort>) -> List<Core_cterms_sort>
rule SubstMaybeTerms(#env, cterms?⟦              ⟧) → cterms?⟦⟧
rule SubstMaybeTerms(#env, cterms?⟦ ()           ⟧) → cterms?⟦⟧
rule SubstMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧) → cterms?⟦ ( ⟨cterm*: SubstTerms(#env, #cterm*)⟩ ) ⟧

func SubstMaybeSortAnno({String:EnvEntry}, List<Core_csortanno_sort>) -> List<Core_csortanno_sort>
rule SubstMaybeSortAnno(#env, csortanno?⟦           ⟧) → csortanno?⟦⟧
rule SubstMaybeSortAnno(#env, csortanno?⟦ : ##csort ⟧) → csortanno?⟦ : ⟨csort: SubstSort(#env, #csort)⟩ ⟧

func SubstMaybeSubst({String:EnvEntry}, List<Core_csubst_sort>) -> List<Core_csubst_sort>
rule SubstMaybeSubst(#env, csubst?⟦              ⟧) → csubst?⟦⟧
rule SubstMaybeSubst(#env, csubst?⟦ [ ##cterm* ] ⟧) → csubst?⟦ [ ⟨cterm*: SubstTerms(#env, #cterm*)⟩ ] ⟧

func SubstTerms({String:EnvEntry}, List<Core_cterm_sort>) -> List<Core_cterm_sort>
rule SubstTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧) → cterm*⟦ ⟨cterm: SubstTerm(#env, #cterm)⟩ ⟨cterm*: SubstTerms(#env, #cterm*)⟩ ⟧
rule SubstTerms(#env, cterm*⟦                  ⟧) → cterm*⟦⟧

func SubstSorts({String:EnvEntry}, List<Core_csort_sort>) -> List<Core_csort_sort>
rule SubstSorts(#env, csort*⟦ ##csort ##csort* ⟧) → csort*⟦ ⟨csort: SubstSort(#env, #csort)⟩ ⟨csort*: SubstSorts(#env, #csort*)⟩ ⟧
rule SubstSorts(#env, csort*⟦                  ⟧) → csort*⟦⟧

func SubstSort({String:EnvEntry}, Core_csort_sort) -> Core_csort_sort
rule SubstSort(#env, csort⟦ ##CONSTRUCTOR ##csorts? ⟧) → csort⟦ ##CONSTRUCTOR ⟨csorts?: SubstMaybeSorts(#env, #csorts?)⟩ ⟧
rule SubstSort(#env, csort⟦ ##VARIABLE              ⟧) → SubstVar(#VARIABLE, GetSort(#env, #VARIABLE))
rule SubstSort(#env, csort⟦ [ ##csort1 ] ##csort2   ⟧) → csort⟦ [ ⟨csort: SubstSort(#env, #csort1)⟩ ] ⟨csort: SubstSort(#env, #csort2)⟩ ⟧
rule SubstSort(#env, csort⟦ ( ##csort1 ) ##csort2   ⟧) → csort⟦ ( ⟨csort: SubstSort(#env, #csort1)⟩ ) ⟨csort: SubstSort(#env, #csort2)⟩ ⟧
rule SubstSort(#env, csort⟦ { ##cmapsort* }         ⟧) → csort⟦ { ⟨cmapsort*: SubstMapSorts(#env, #cmapsort*)⟩ } ⟧
rule SubstSort(#env, csort⟦ thunk ##csort           ⟧) → csort⟦ thunk ⟨csort: SubstSort(#env, #csort)⟩ ⟧
rule SubstSort(#env, csort⟦ data ##csort            ⟧) → csort⟦ data ⟨csort: SubstSort(#env, #csort)⟩ ⟧

func SubstMaybeSorts({String:EnvEntry}, List<Core_csorts_sort>) -> List<Core_csorts_sort>
rule SubstMaybeSorts(#env, csorts?⟦ ( ##csort* ) ⟧) → csorts?⟦ ( ⟨csort*: SubstSorts(#env, #csort*)⟩ ) ⟧
rule SubstMaybeSorts(#env, csorts?⟦              ⟧) → csorts?⟦⟧

// The insteresting bit is here. The rest is just boilerplate.
func SubstVar(String, Option<Core_csort_sort>) -> Core_csort_sort
rule SubstVar(#VARIABLE, NONE                        ) → csort⟦ ##VARIABLE ⟧  // generic variable
rule SubstVar(#VARIABLE, SOME(#csort:Core_csort_sort)) → #csort              // variable is replaced.

func SubstMapSorts({String:EnvEntry}, List<Core_cmapsort_sort>) -> List<Core_cmapsort_sort>
rule SubstMapSorts(#env, cmapsort*⟦                                 ⟧) → cmapsort*⟦⟧
rule SubstMapSorts(#env, cmapsort*⟦ ##csort1 : ##csort2 ##cmapsort* ⟧) → cmapsort*⟦ ⟨csort: SubstSort(#env, #csort1)⟩ : ⟨csort: SubstSort(#env, #csort2)⟩  ⟨cmapsort*: SubstMapSorts(#env, #cmapsort*)⟩ ⟧

// --- Various utility functions

/* Check the given `#sortanno?` matches the given `#sort`. Output an error if not, otherwise apply `#result` */
func CheckSortAnnoE<a>(List<Core_csortanno_sort>, Core_csort_sort, ()->a) -> a
rule CheckSortAnnoE(csortanno?⟦           ⟧, #csort, #result) → #result()
rule CheckSortAnnoE(csortanno?⟦ : ##csort ⟧, #csort, #result) → #result()  // TODO: really check when Equal is fixed.
