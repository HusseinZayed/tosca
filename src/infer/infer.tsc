// Copyright (c) 2016 IBM Corporation.
/*
  Propagate missing sort annotations and arguments, but only to compensate the target language limitations.

  For Java:
  - Sort parameters must be instantiated (eg. ListLength<Numeric>(...))
  - Meta-variable sort annotations must be specified (meta-variable declarations only)
  - Data constructor must be prefixed by their sort. (eg. List<a>::Cons) (for now in pattern only)

  For C++:
  - ...

  This is basically a simplified version of the Hindley-Milner type inference algo,
  as decribed in http://lucacardelli.name/Papers/BasicTypechecking.pdf

  Simplified in such way:
  - Sorts must be specified on function signatures
  - Only look for one sort instantiation; does not try to resolve sort constraints.

  Also perform the followings checks:
  - Mismatched number of arguments in rule and corresponding function sort.
  - Invalid use of function symbol in pattern
  - Invalid sort annotations
  - ...

 */
import Std::Core
import Std::Listdef
import Std::Pairdef
import Std::Mapdef
import Std::String
import Core::Core
import Infer::Env
import Systemdef

/* Infer sorts of given `#system`
   @param System The Tosca system */
func InferSystem(TSystem) -> TSystem
rule InferSystem(TSystem(#url:String, #modules:{String : Module}))
→ TSystem(#url, MapIndex<String Module>(Map<Module Pair<String Module>>((mod) -> InferModule(mod, TSystem(#url, #modules)), MapValues<String Module>(#modules))))

func InferModule(Module, TSystem) -> Pair<String Module>
rule InferModule(Module(#url:String, #content: Content), #system) → PairCons(#url, Module(#url, InferContent(#content, #system)))

func InferContent(Content, TSystem) -> Content
rule InferContent(Loaded(#content:LoadedContent), #system)
→ Loaded(FoldlP<String LoadedContent>((key content) -> InferRules(key, UnSOME<List>(GetRulesForKeyC(content, key)), content, #system),
                               #content,
                               MapKeys<String List>(GetRules(#content))))

func InferRules(#key: String, #rules: List<Core_cdecl_sort>, #content: LoadedContent, #system: TSystem) -> LoadedContent
→ PutRulesC(#content, #key, Map<Core_cdecl_sort Core_cdecl_sort>((rul) -> InferRule(EnvNew(#content, #system), rul), #rules))

func InferRule({String:EnvEntry}, Core_cdecl_sort) -> Core_cdecl_sort
rule InferRule(#env, cdecl⟦ rule ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? → ##cterm ⟧)
→ InferRuleUp(#CONSTRUCTOR, #csortargs?, #csortanno?, InferPattern(SetContractum(#env, #cterm), #cterms?, GetFuncSortCE(GetContent(#env), #CONSTRUCTOR)))

func InferRuleUp(String, List<Core_csortargs_sort>, List<Core_csortanno_sort>, Pair<List<Core_cterms_sort> Core_cterm_sort>) -> Core_cdecl_sort
rule InferRuleUp(#CONSTRUCTOR, #csortargs?, #csortanno?, PairCons(#cterms?:List<Core_cterms_sort> , #cterm: Core_cterm_sort))
→ cdecl⟦ rule ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? → ##cterm ⟧

// --- Pattern

/* Traverse pattern, reconstruct data constructor sort prefixes and meta-variable sort annotations.
   Store (meta-variable, sort) pairs in the environment */
func InferPattern({String:EnvEntry}, List<Core_cterms_sort>, Core_cdecl_sort) -> Pair<List<Core_cterms_sort> /* pattern */ Core_cterm_sort /* contractum */>

  rule InferPattern(#env, #cterms?, cdecl⟦ ##canno* ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ( ##csort* ) ⟧)
  → InferPatternUp(InferMaybeTerms(SetSort(#env, #csort), #cterms?, #csort*))

  // TODO: could easily check arity
  rule InferPattern(#env, cterms?⟦⟧, cdecl⟦ ##canno* ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧)
  → PairCons(cterms?⟦⟧, InferContractum(SetSort(#env, #csort)))

  // The signature or rule is wrong.
  rule InferPattern(#env, #cterms?, cdecl⟦ ##canno* ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧)
  → Error<Pair<List<Core_cterms_sort> Core_cterm_sort>>(ConcatString("Error: mismatched number of arguments in rule and corresponding function declaration for ", #CONSTRUCTOR))

/* Reconstruct pattern and move on to contractum */
func InferPatternUp(Pair<{String:EnvEntry} List<Core_cterms_sort>>) -> Pair<List<Core_cterms_sort> /* pattern */ Core_cterm_sort /* contractum */>
rule InferPatternUp(PairCons(#env:{String:EnvEntry}, #cterms?:List<Core_cterms_sort>)) → PairCons(#cterms?, InferContractum(#env))

// --- Contraction

func InferContractum(#env: {String:EnvEntry}) -> Core_cterm_sort
→ InferContractumUp(InferTerm(SetInPattern(#env, FALSE), GetContractum(#env), GetSort(#env))) // TODO: could easily unify actual/expected result sort

func InferContractumUp(Pair<{String:EnvEntry} Core_cterm_sort>) -> Core_cterm_sort
rule InferContractumUp(PairCons(#env: {String:EnvEntry}, #cterm: Core_cterm_sort)) → #cterm

// --- Terms

/* Traverse terms if any */
func InferMaybeTerms({String:EnvEntry}, List<Core_cterms_sort>, List<Core_csort_sort>) -> Pair<{String:EnvEntry} List<Core_cterms_sort>>
rule InferMaybeTerms(#env, cterms?⟦              ⟧, #csort*) → PairCons(#env, cterms?⟦⟧) // TODO: check sort arity
rule InferMaybeTerms(#env, cterms?⟦ (          ) ⟧, #csort*) → PairCons(#env, cterms?⟦⟧)  // TODO: check sort arity
rule InferMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧, #csort*) → UnPair<{String:EnvEntry} List Pair>(InferTerms(#env, #cterm*, #csort*), (env terms)->PairCons(env, cterms?⟦ ( ⟨cterm*: terms⟩ )⟧))

/* Traverse terms */
func InferTerms({String:EnvEntry}, List<Core_cterm_sort>, List<Core_csort_sort>) -> Pair<{String:EnvEntry} List<Core_cterm_sort>>
rule InferTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, csort*⟦ ##csort ##csort* ⟧) → InferTermsUp(InferTerm(#env, #cterm, #csort), #cterm*, #csort*)
rule InferTerms(#env, cterm*⟦                  ⟧, csort*⟦                  ⟧) → PairCons(#env, cterm*⟦⟧)
rule InferTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, csort*⟦                  ⟧) → Error<Pair<{String:EnvEntry} List<Core_cterm_sort>>>("Error: too many arguments.")
rule InferTerms(#env, cterm*⟦                  ⟧, csort*⟦ ##csort ##csort* ⟧) → Error<Pair<{String:EnvEntry} List<Core_cterm_sort>>>("Error: not enough arguments.")

/* Reconstruct terms */
func InferTermsUp(Pair<{String:EnvEntry} Core_cterm_sort>, List<Core_cterm_sort>, List<Core_csort_sort>) -> Pair<{String:EnvEntry} List<Core_cterm_sort>>
rule InferTermsUp(PairCons(#env:{String:EnvEntry} , #cterm:Core_cterm_sort), #cterm*, #csort*)
→ UnPair<{String:EnvEntry} List Pair>(InferTerms(#env, #cterm*, #csort*), (env cterms) -> PairCons(env, cterm*⟦ ##cterm ⟨cterm*: cterms⟩⟧))

/* Traverse term */
func InferTerm({String:EnvEntry}, Core_cterm_sort, Core_csort_sort) -> Pair<{String:EnvEntry} Core_cterm_sort>

  rule InferTerm(#env, cterm⟦ ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #csort)
  → InferCons(#env, GetInPattern(#env), IsDataS(GetSystem(#env), #CONSTRUCTOR), #csortqualifier*, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #csort)

  rule InferTerm(#env, cterm⟦ ##cliteral ⟧, #csort) → PairCons(#env, cterm⟦ ##cliteral ⟧)

  // metavar arguments on pattern must all be variables. No need to traverse. TODO: could check arity
  rule InferTerm(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #csort)
  // TODO: enable when issue #15 is fixed
  //→ CheckSortAnnoE<Pair<{String:EnvEntry} Core_cterm_sort>>(#csortanno?, #csort, () -> PairCons(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? : ##csort ⟧))
  → PairCons(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? : ##csort ⟧)

  rule InferTerm(#env, cterm⟦ ##VARIABLE ##csortanno? ⟧, #csort) // TODO: could check sort annotation
  → PairCons(#env, cterm⟦ ##VARIABLE ##csortanno? ⟧)

  rule InferTerm(#env, cterm⟦ [ v ##csortanno? ] ##cterm ⟧, csort⟦ [ ##csort1 ] ##csort ⟧)
  → CheckSortAnnoE<Pair<{String:EnvEntry} Core_cterm_sort>>(#csortanno?, #csort1, ()->InferBinderUp([v] -> InferTerm(#env, #cterm[v], #csort), #csort1))

  rule InferTerm(#env, cterm⟦ [ v ##csortanno? ] ##cterm ⟧, #csort)
  → Error<Pair<{String:EnvEntry} Core_cterm_sort>>("Type error") // TODO:

  rule InferTerm(#env, cterm⟦ ( f ##csortanno? ) ##cterm ⟧, csort⟦ ( ##csort1 ) ##csort ⟧)
  → CheckSortAnnoE<Pair<{String:EnvEntry} Core_cterm_sort>>(#csortanno?, #csort1, ()->InferFormalUp([f] -> InferTerm(#env, #cterm[f], #csort), #csort1))

  rule InferTerm(#env, cterm⟦ ( f ##csortanno? ) ##cterm ⟧, #csort)
  → Error<Pair<{String:EnvEntry} Core_cterm_sort>>("Type error") // TODO:

  rule InferTerm(#env, cterm⟦ thunk ##cterm ⟧, #csort)
  → InferTerm(#env, #cterm, #csort)

/*  Traverse construction
    @param `#env`
    @param `#inpattern`
    @param `#isdatasort`
 */
func InferCons({String:EnvEntry}, Bool, Bool, List<Core_csortqualifier_sort>, String, List<Core_csortargs_sort>, List<Core_cterms_sort>, List<Core_csortanno_sort>, Core_csort_sort) -> Pair<{String:EnvEntry} Core_cterm_sort>

  // TODO: should use the sort annotation
  // TODO: CheckSortQualifier
  rule InferCons(#env, #inpattern, TRUE, #csortqualifier*, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #csort)
  → //CheckSortQualifier(#csortqualifier*, #csort,
    InferConsUp(#CONSTRUCTOR, #csortargs?, InferDataSubs(#env, #cterms?, FindFormS(GetSystem(#env), #csort, #CONSTRUCTOR), #CONSTRUCTOR), #csort)

  rule InferCons(#env, FALSE, FALSE, #csortqualifier*, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #csort)
  → //CheckSortQualifier(#csortqualifier*, #csort,
    InferConsUp(#CONSTRUCTOR, #csortargs?, InferFuncSubs(#env, #cterms?, FindFuncSortS(GetSystem(#env), #CONSTRUCTOR), #CONSTRUCTOR), #csort)

  rule InferCons(#env, TRUE, FALSE, #csortqualifier*, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #csort)
  → Error<Pair<{String:EnvEntry} Core_cterm_sort>>(ConcatString("Error: function symbol cannot occur in pattern: ", #CONSTRUCTOR))

/* Reconstruct construction */
func InferConsUp(String, List<Core_csortargs_sort>, Pair<{String:EnvEntry} List<Core_cterms_sort>>, Core_csort_sort) -> Pair<{String:EnvEntry} Core_cterm_sort>
rule InferConsUp(#CONSTRUCTOR, #csortargs?, PairCons(#env:{String:EnvEntry}, #cterms?:List<Core_cterms_sort>), #csort) → PairCons(#env, cterm⟦ ##csort :: ##CONSTRUCTOR ##csortargs? ##cterms? : ##csort ⟧)

/* Traverse data construction sub terms */
func InferDataSubs({String:EnvEntry}, List<Core_cterms_sort>, Option<Core_cform_sort>, String) -> Pair<{String:EnvEntry} List<Core_cterms_sort>>
rule InferDataSubs(#env, #cterms?, SOME(cform⟦ ##CONSTRUCTOR ( ##csort* ) ⟧), #formname) → InferMaybeTerms(#env, #cterms?, #csort*)
rule InferDataSubs(#env, cterms?⟦⟧, SOME(cform⟦ ##CONSTRUCTOR              ⟧), #formname) → PairCons(#env, cterms?⟦⟧)
rule InferDataSubs(#env, #cterms?, NONE                              , #formname) → Error<Pair>(ConcatString("Error: undeclared enumeration value ", #formname))
rule InferDataSubs(#env, #cterms?, SOME(#cform: Core_cform_sort)     , #formname) → Error<Pair>(ConcatString("Error: wrong arity for enumeration value ", #formname))

/* Traverse function construction sub terms */
func InferFuncSubs({String:EnvEntry}, List<Core_cterms_sort>, Option<Core_cdecl_sort>, String) -> Pair<{String:EnvEntry} List<Core_cterms_sort>>
rule InferFuncSubs(#env, #cterms?, SOME(cdecl⟦ ##canno* ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ( ##csort* ) ⟧), #constructor) → InferMaybeTerms(#env, #cterms?, #csort*)
rule InferFuncSubs(#env, cterms?⟦⟧, SOME(cdecl⟦ ##canno* ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR              ⟧), #constructor) → PairCons(#env, cterms?⟦⟧)
rule InferFuncSubs(#env, #cterms?, NONE                        , #constructor) → Error<Pair>(ConcatString("Error: undeclared function named ", #constructor))
rule InferFuncSubs(#env, #cterms?, SOME(#cdecl:Core_cdecl_sort), #constructor) → Error<Pair>(ConcatString("Error: wrong arity for function ", #constructor))

/* Reconstruct binder */
// Note: #env is weak.
func InferBinderUp([String] -> Pair<{String:EnvEntry} Core_cterm_sort>, Core_csort_sort) -> Pair<{String:EnvEntry} Core_cterm_sort>
rule InferBinderUp([b] -> PairCons(#env:{String:EnvEntry}, #cterm[b]:Core_cterm_sort), #csort) → PairCons(#env, cterm⟦ [ b : ##csort ] ##cterm ⟧)

/* Reconstruct formal parameter */
// Note: #env is weak.
func InferFormalUp([String] -> Pair<{String:EnvEntry} Core_cterm_sort>, Core_csort_sort) -> Pair<{String:EnvEntry} Core_cterm_sort>
rule InferFormalUp([f] -> PairCons(#env:{String:EnvEntry}, #cterm[f]:Core_cterm_sort), #csort) → PairCons(#env, cterm⟦ ( f : ##csort ) ##cterm ⟧)

// Contraction:

// Main idea : propagate type bottom up. Use sort unification to instantiate type variables

/* Example
 ListLength<a>( Cons(# : Int, Nil : List<a>) : List<Int> )
 sort unification:

 For data: unifyConstruction(List<a>::Cons(a, List<a>), (Int, List<a>))
            unifySort(a, Int) = {a -> Int}
            unifySort(List<a>, List<a>)) = unifySort(a, a) = { a -> a }
    only need one instantiation. a -> Int

 for function
   ListLength<a>(List<a>)

   unifySort(List<a>, List<Int>)

 ListLength<a>( F : List<Int>::Cons(# : Int, List<a>::Nil : List<a>) )


*/

//func UnifySort(Core_csort_sort, Core_csort_sort) -> List<Pair<String Core_csort_sort>>

// --- Various utility functions

/* Check the given `#sortanno?` matches the given `#sort`. Output an error if not, otherwise apply `#result` */
func CheckSortAnnoE<a>(List<Core_csortanno_sort>, Core_csort_sort, ()->a) -> a
rule CheckSortAnnoE(csortanno?⟦           ⟧, #csort, #result) → #result()
rule CheckSortAnnoE(csortanno?⟦ : ##csort ⟧, #csort, #result) → #result()  // TODO: really check when Equal is fixed.
