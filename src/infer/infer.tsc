// Copyright (c) 2016 IBM Corporation.
/*
  Propagate missing sort annotations and sort arguments.

  Also perform opportunistic sort checking. The full complete sort checking is done by the target language

  The sort inference below is done in two passes:
  - The first pass propagates sorts bottom-up and unsorted terms are sorted (but still generic) using sort declarations.
    The sort environment is extended with sort unification.
  - The second pass first starts by solving sort equations stored in the sort environment. Upon success, sort variables are instantiated
    by traversing the term tree top-down.

 */
import Std::Core
import Std::Listdef
import Std::Pairdef
import Std::Mapdef
import Std::String
import Core::Core
import Core::Utils
import Infer::Env
import Systemdef

// --- API

/* Infer sorts of given `#`
   @param System The Tosca system */
func InferM(#system: TSystem, #module: Module) -> Module
→ IfConfigDef<Module>(#system, "infer",
    (v) -> SetModuleContent(#module, InferContent(GetModuleContent(#module), #system)),
    ( ) -> #module)

// -- Content

func InferContent(#content: Content, #system: TSystem) -> Content
→ FoldlP<String Content>((key content) -> InferRules(key, UnSOME<List>(GetRulesForKeyC(content, key)), content, #system),
                         #content,
                         MapKeys<String List>(GetRules(#content)))

// -- Rules

func InferRules(#key: String, #rules: List<Core_cdecl_sort>, #content: Content, #system: TSystem) -> Content
→ PutRulesC(#content, #key, Map<Core_cdecl_sort Core_cdecl_sort>((rul) -> InferRule(EnvNew(#content, #system), rul), #rules))

// -- Rule

func InferRule({String:IEnvEntry}, Core_cdecl_sort) -> Core_cdecl_sort
rule InferRule(#env, cdecl⟦ rule ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? → ##cterm ⟧)
→ InferPatternUp(InferFunc(ResetEnv(#env), #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, NONE), #cterm, FindFuncSortS(GetSystem(#env), #CONSTRUCTOR))

func InferPatternUp(Pair<{String:IEnvEntry} Core_cterm_sort>, Core_cterm_sort, Option<Core_cdecl_sort>) -> Core_cdecl_sort
rule InferPatternUp(PairCons(#env:{String:IEnvEntry}, #pattern:Core_cterm_sort), #contractum, SOME(cdecl⟦ ##canno* ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧))
→ InferRuleUp(#pattern, PreInferTerm(SetInPattern(#env, FALSE), #contractum, #csort))

func InferRuleUp(Core_cterm_sort, Pair<{String:IEnvEntry} Core_cterm_sort>) -> Core_cdecl_sort
rule InferRuleUp(#cterm1, PairCons(#env:{String:IEnvEntry}, #cterm2:Core_cterm_sort)) → SubstRule(OptimizeSorts(#env), #cterm1, #cterm2)

// ---- Synthesize sorts

// --- Terms

/* Reset environment and continue with term */
func PreInferTerm(#env: {String:IEnvEntry}, #term: Core_cterm_sort, #fsort: Core_csort_sort /* formal sort */) -> Pair<{String:IEnvEntry} Core_cterm_sort>
→ InferTerm(SetBoundVarSorts(SetFormalSorts(#env, ()), ()), #term, #fsort)

/* Synthesize term sort.
   @return a pair consisting of an updated environment and the sorted term (which might contain sort variables)
*/
func InferTerm({String:IEnvEntry}, Core_cterm_sort, Core_csort_sort /* formal sort */) -> Pair<{String:IEnvEntry} Core_cterm_sort>

  rule InferTerm(#env, cterm⟦ ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #fsort)
  → InferCons(#env, GetInPattern(#env), IsDataS(GetSystem(#env), #CONSTRUCTOR), #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #fsort)

  rule InferTerm(#env, cterm⟦ ##STRING ⟧, #fsort) → PairCons(UnifySort(#env, #fsort, csort⟦ String  ⟧), cterm⟦ ##STRING ⟧)
  rule InferTerm(#env, cterm⟦ ##NUMBER ⟧, #fsort) → PairCons(UnifySort(#env, #fsort, csort⟦ Numeric ⟧), cterm⟦ ##NUMBER ⟧)

  rule InferTerm(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #fsort)
  → InferMeta(#env, GetInPattern(#env), #METAVAR, #cterms?, #csubst?, #csortanno?, #fsort)

  // TODO:
  rule InferTerm(#env, cterm⟦ ##VARIABLE ##csortanno? ⟧, #fsort) // TODO: could check sort annotation
  → PairCons(#env, cterm⟦ ##VARIABLE ##csortanno? ⟧)

  rule InferTerm(#env, cterm⟦ [ v ##csortanno? ] ##cterm ⟧, csort⟦ [ ##csort1 ] ##csort ⟧)
  → UnifySortAnno<Pair>(#env, #csort1, #csortanno?, (env sort) -> InferBinderUp([v] -> InferTerm(AddBoundVarSort(env, sort), #cterm[v], #csort), sort))

  rule InferTerm(#env, cterm⟦ [ v ##csortanno? ] ##cterm ⟧, #fsort)
  → Error<Pair<{String:IEnvEntry} Core_cterm_sort>>("Type error") // TODO:

  rule InferTerm(#env, cterm⟦ ( f ##csortanno? ) ##cterm ⟧, csort⟦ ( ##csort1 ) ##csort ⟧)
  → UnifySortAnno<Pair<{String:IEnvEntry} Core_cterm_sort>>(#env, #csort1, #csortanno?, (env sort) -> InferFormalUp([f] -> InferTerm(AddFormalSort(env, sort), #cterm[f], #csort), sort))

  rule InferTerm(#env, cterm⟦ ( f ##csortanno? ) ##cterm ⟧, #fsort) → Error<Pair<{String:IEnvEntry} Core_cterm_sort>>("Type error") // TODO:
  rule InferTerm(#env, cterm⟦ thunk ##cterm              ⟧, #fsort) → UnPair<{String:IEnvEntry} Core_cterm_sort Pair>(InferTerm(#env, #cterm, #fsort), (env term)->PairCons(env, cterm⟦ thunk ⟨cterm: term⟩ ⟧))

/* Traverse terms */
func InferMaybeTerms({String:IEnvEntry}, String, List<Core_cterms_sort>, List<Core_csort_sort>) -> Pair<{String:IEnvEntry} List<Core_cterms_sort>>
rule InferMaybeTerms(#env, #constructor, cterms?⟦              ⟧, #fsort*) → PairCons(#env, cterms?⟦    ⟧) // TODO: check sort arity
rule InferMaybeTerms(#env, #constructor, cterms?⟦ (          ) ⟧, #fsort*) → PairCons(#env, cterms?⟦ () ⟧)  // TODO: check sort arity
rule InferMaybeTerms(#env, #constructor, cterms?⟦ ( ##cterm* ) ⟧, #fsort*) → UnPair<{String:IEnvEntry} List Pair>(InferTerms(#env, #constructor, #cterm*, #fsort*), (env terms)->PairCons(env, cterms?⟦ ( ⟨cterm*: terms⟩ ) ⟧))

/* Traverse subst */
func InferMaybeSubst({String:IEnvEntry}, String, List<Core_csubst_sort>, List<Core_csort_sort>) -> Pair<{String:IEnvEntry} List<Core_csubst_sort>>
rule InferMaybeSubst(#env, #constructor, csubst?⟦              ⟧, #fsort*) → PairCons(#env, csubst?⟦    ⟧) // TODO: check sort arity
rule InferMaybeSubst(#env, #constructor, csubst?⟦ [ ##cterm* ] ⟧, #fsort*) → UnPair<{String:IEnvEntry} List Pair>(InferTerms(#env, #constructor, #cterm*, #fsort*), (env terms)->PairCons(env, csubst?⟦ [ ⟨cterm*: terms⟩ ] ⟧))

/* Traverse terms */
func InferTerms({String:IEnvEntry}, String, List<Core_cterm_sort>, List<Core_csort_sort>) -> Pair<{String:IEnvEntry} List<Core_cterm_sort>>
rule InferTerms(#env, #constructor, cterm*⟦ ##cterm ##cterm* ⟧, csort*⟦ ##csort ##csort* ⟧) → InferTermsUp(PreInferTerm(#env, #cterm, #csort), #constructor, #cterm*, #csort*)
rule InferTerms(#env, #constructor, cterm*⟦                  ⟧, csort*⟦                  ⟧) → PairCons(#env, cterm*⟦⟧)
rule InferTerms(#env, #constructor, cterm*⟦ ##cterm ##cterm* ⟧, csort*⟦                  ⟧) → Error<Pair<{String:IEnvEntry} List<Core_cterm_sort>>>(ConcatString("Error: extra argument(s) in ", #constructor))
rule InferTerms(#env, #constructor, cterm*⟦                  ⟧, csort*⟦ ##csort ##csort* ⟧) → Error<Pair<{String:IEnvEntry} List<Core_cterm_sort>>>(ConcatString("Error: missing argument(s) in ", #constructor))

/* Reconstruct terms */
func InferTermsUp(Pair<{String:IEnvEntry} Core_cterm_sort>, String, List<Core_cterm_sort>, List<Core_csort_sort>) -> Pair<{String:IEnvEntry} List<Core_cterm_sort>>
rule InferTermsUp(PairCons(#env:{String:IEnvEntry}, #cterm:Core_cterm_sort), #constructor, #cterm*, #csort*)
→ UnPair<{String:IEnvEntry} List Pair>(InferTerms(#env, #constructor, #cterm*, #csort*), (env cterms) -> PairCons(env, cterm*⟦ ##cterm ⟨cterm*: cterms⟩⟧))

/* Synthesize construction sort
   @param `#env`
   @param `#inpattern`
   @param `#isdatasort`
 */
func InferCons({String:IEnvEntry}, Bool, Bool, String, List<Core_csortargs_sort>, List<Core_cterms_sort>, List<Core_csortanno_sort>, Core_csort_sort) -> Pair<{String:IEnvEntry} Core_cterm_sort>

  rule InferCons(#env, #inpattern, TRUE, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #fsort)
  → InferData(#env, #csortargs?, #cterms?, FindFormS(GetSystem(#env), #fsort, #CONSTRUCTOR), #CONSTRUCTOR, #fsort)

  rule InferCons(#env, FALSE, FALSE, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #fsort)
  → InferFunc(#env, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, SOME(#fsort))

  rule InferCons(#env, TRUE, FALSE, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #fsort)
  → Error<Pair<{String:IEnvEntry} Core_cterm_sort>>(ConcatString("Error: function symbol cannot occur in pattern: ", #CONSTRUCTOR))

/* Synthesize function  */
func InferFunc(#env: {String:IEnvEntry}, #CONSTRUCTOR: String, #csortargs?: List<Core_csortargs_sort>, #cterms?: List<Core_cterms_sort>,
                  #csortanno?: List<Core_csortanno_sort>, #fsort: Option<Core_csort_sort>) -> Pair<{String:IEnvEntry} Core_cterm_sort>
→ InferFuncAux(#env, FindFuncSortS(GetSystem(#env), #CONSTRUCTOR), #csortargs?, #cterms?, #CONSTRUCTOR, #fsort)

func InferFuncAux({String:IEnvEntry}, Option<Core_cdecl_sort>, List<Core_csortargs_sort>, List<Core_cterms_sort>, String, Option<Core_csort_sort>) -> Pair<{String:IEnvEntry} Core_cterm_sort>
rule InferFuncAux(#env, SOME(cdecl⟦ ##canno* ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧), #csortargs?, #cterms?, #funcname, #fsort) → InferSubs(#env, #CONSTRUCTOR, FALSE, #csortvars?, #csortargs?, #cterms?, MaybeSortsToSorts(#csorts?), #fsort)
rule InferFuncAux(#env, NONE                                                                                   , #csortargs?, cterms?⟦⟧, #funcname, #fsort) → Error<Pair>(ConcatString("Error: undeclared function named ", #funcname))

/* Synthesize data construction */
func InferData({String:IEnvEntry}, List<Core_csortargs_sort>, List<Core_cterms_sort>, Option<Pair<Core_cdecl_sort Core_cform_sort>>, String, Core_csort_sort) -> Pair<{String:IEnvEntry} Core_cterm_sort>
rule InferData(#env, #csortargs?, #cterms?, SOME(Pair<Core_cdecl_sort Core_cform_sort>::PairCons(#cdecl:Core_cdecl_sort, cform⟦ ##CONSTRUCTOR ##csorts? ⟧)), #formname, #fsort) → InferSubs(#env, #CONSTRUCTOR, TRUE, GetMaybeSortVars(#cdecl), #csortargs?, #cterms?, MaybeSortsToSorts(#csorts?), SOME(#fsort))
rule InferData(#env, #csortargs?, #cterms?, NONE                                    , #formname, #fsort) → Error<Pair>(ConcatString("Error: undefined enumeration value ", ConcatString(#formname, ConcatString(" in type ", PrintSort(#fsort)))))

/* Synthesize construction sub terms */
func InferSubs(#env: {String:IEnvEntry}, #CONSTRUCTOR:String, #data: Bool, #csortvars?: List<Core_csortvars_sort>, #csortargs?: List<Core_csortargs_sort>, #cterms?: List<Core_cterms_sort>,
                 #csort*: List<Core_csort_sort>, #fsort:Option<Core_csort_sort>) -> Pair<{String:IEnvEntry} Core_cterm_sort>
→  InferConsUp(#CONSTRUCTOR, #data, InferMaybeTerms(InferSortArgs(#env, #csortvars?, #csortargs?), #CONSTRUCTOR, #cterms?, #csort*), #fsort)

/* Reconstruct construction. For data, erase sort arguments. */
func InferConsUp(String, Bool, Pair<{String:IEnvEntry} List<Core_cterms_sort>>, Option<Core_csort_sort>) -> Pair<{String:IEnvEntry} Core_cterm_sort>
  rule InferConsUp(#CONSTRUCTOR, #data, PairCons(#env:{String:IEnvEntry}, #cterms?:List<Core_cterms_sort>), SOME(#csort:Core_csort_sort))
  → PairCons(PopSortArgs(#env), cterm⟦ ##csort :: ##CONSTRUCTOR ⟨csortargs?: InferSortArgsUp(#env, #data)⟩ ##cterms? : ##csort ⟧)

  rule InferConsUp(#CONSTRUCTOR, #data, PairCons(#env:{String:IEnvEntry}, #cterms?:List<Core_cterms_sort>), NONE)
  → PairCons(PopSortArgs(#env), cterm⟦ ##CONSTRUCTOR ⟨csortargs?: InferSortArgsUp(#env, #data)⟩ ##cterms? ⟧)

/* Reconstruct sort arguments, for function only */
func InferSortArgsUp({String:IEnvEntry}, Bool) -> List<Core_csortargs_sort>
rule InferSortArgsUp(#env, TRUE)  → csortargs?⟦⟧
rule InferSortArgsUp(#env, FALSE) → TopSortArgs(#env)

/* Reconstruct binder */
// Note: #env is weak.
func InferBinderUp([String] -> Pair<{String:IEnvEntry} Core_cterm_sort>, Core_csort_sort) -> Pair<{String:IEnvEntry} Core_cterm_sort>
rule InferBinderUp([b] -> PairCons(#env:{String:IEnvEntry}, #cterm[b]:Core_cterm_sort), #csort) → PairCons(#env, cterm⟦ [ b : ##csort ] ##cterm ⟧)

/* Reconstruct formal parameter */
// Note: #env is weak.
func InferFormalUp([String] -> Pair<{String:IEnvEntry} Core_cterm_sort>, Core_csort_sort) -> Pair<{String:IEnvEntry} Core_cterm_sort>
rule InferFormalUp([f] -> PairCons(#env:{String:IEnvEntry}, #cterm[f]:Core_cterm_sort), #csort) → PairCons(#env, cterm⟦ ( f : ##csort ) ##cterm ⟧)

// --- Synthesize meta

func InferMeta({String:IEnvEntry}, Bool /* Declaration? */, String, List<Core_cterms_sort>, List<Core_csubst_sort>, List<Core_csortanno_sort>, Core_csort_sort) -> Pair<{String:IEnvEntry} Core_cterm_sort>

  // Declaration
  rule InferMeta(#env, TRUE, #METAVAR, #cterms?, #csubst?, #csortanno?, #fsort)
  → InferMetaAux(#METAVAR, InferMaybeTerms(AddIMeta(#env, #METAVAR, GetFormalSorts(#env), GetBoundVarSorts(#env)), #METAVAR, #cterms?, GetFormalSorts(#env)), #csubst?, GetBoundVarSorts(#env), #csortanno?, #fsort)

  // Use
  rule InferMeta(#env, FALSE, #METAVAR, #cterms?, #csubst?, #csortanno?, #fsort)
  → InferMetaUse(#env, GetIMeta(#env, #METAVAR), #METAVAR, #cterms?, #csubst?, #csortanno?, #fsort)

func InferMetaAux(String, Pair<{String:IEnvEntry} List<Core_cterms_sort>>, List<Core_csubst_sort>, List<Core_csort_sort>, List<Core_csortanno_sort>, Core_csort_sort) -> Pair<{String:IEnvEntry} Core_cterm_sort>
rule InferMetaAux(#METAVAR, PairCons(#env:{String:IEnvEntry}, #cterms?:List<Core_cterms_sort>), #csubst?, #bvsort*, #csortanno?, #fsort)
→  InferMetaAux2(#METAVAR, #cterms?, InferMaybeSubst(#env, #METAVAR, #csubst?, #bvsort*), #csortanno?, #fsort)

func InferMetaAux2(String, List<Core_cterms_sort>, Pair<{String:IEnvEntry} List<Core_csubst_sort>>, List<Core_csortanno_sort>, Core_csort_sort) -> Pair<{String:IEnvEntry} Core_cterm_sort>
rule InferMetaAux2(#METAVAR, #cterms?, PairCons(#env:{String:IEnvEntry}, #csubst?:List<Core_csubst_sort>), #csortanno?, #fsort)
→ UnifySortAnno<Pair<{String:IEnvEntry} Core_cterm_sort>>(#env, #fsort, #csortanno?, (env sort) -> PairCons(env, cterm⟦ ##METAVAR ##cterms? ##csubst? : ⟨csort: sort⟩ ⟧))

func InferMetaUse({String:IEnvEntry}, Option<Pair<List<Core_csort_sort> List<Core_csort_sort>>>, String, List<Core_cterms_sort>, List<Core_csubst_sort>, List<Core_csortanno_sort>, Core_csort_sort) -> Pair<{String:IEnvEntry} Core_cterm_sort>
rule InferMetaUse(#env, NONE, #METAVAR,  #cterms?, #csubst?, #csortanno?, #fsort) → Error<Pair<{String:IEnvEntry} Core_cterm_sort>>(ConcatString("Error: undefined meta-variable ", #METAVAR))
rule InferMetaUse(#env, SOME(Pair<List<Core_csort_sort> List<Core_csort_sort>>::PairCons(#fsorts:List<Core_csort_sort>, #bvsorts:List<Core_csort_sort>)), #METAVAR,  #cterms?, #csubst?, #csortanno?, #fsort) → InferMetaAux(#METAVAR, InferMaybeTerms(#env, #METAVAR, #cterms?, #fsorts), #csubst?, #bvsorts, #csortanno?, #fsort)

/* Synthesize sort variables.

   Works as follows:
   - a sort variable is created for each (formal) sort parameter and the correspondence
     between them is kept in the environment (see XXSortArgs functions).
   - the sort environment is extended with mapping between sort variables and user-specified sort arguments.
 */
func InferSortArgs({String:IEnvEntry}, List<Core_csortvars_sort>, List<Core_csortargs_sort>) -> {String:IEnvEntry}
rule InferSortArgs(#env, csortvars?⟦                     ⟧, csortargs?⟦              ⟧) → PushSortArgs(#env, ())
rule InferSortArgs(#env, csortvars?⟦ ∀ ##variable_TOK+ . ⟧, csortargs?⟦              ⟧) → InferSortArgs2(#env, #variable_TOK+, csort*⟦⟧, ())
rule InferSortArgs(#env, csortvars?⟦ ∀ ##variable_TOK+ . ⟧, csortargs?⟦ < ##csort* > ⟧) → InferSortArgs2(#env, #variable_TOK+, #csort*, ())
rule InferSortArgs(#env, csortvars?⟦                     ⟧, csortargs?⟦ < ##csort* > ⟧) → PushSortArgs(#env, ()) // TODO: issue warning

func InferSortArgs2(#env: {String:IEnvEntry}, #sortvars: List<String>, #csort*: List<Core_csort_sort>, #mapping: List<Pair<String String>>) -> {String:IEnvEntry}
→ InferSortArgs3(IIncCounter(#env), INewSortVar(#env), #sortvars, #csort*, #mapping)

func InferSortArgs3({String:IEnvEntry}, String, List<String>, List<Core_csort_sort>, List<Pair<String String>>) -> {String:IEnvEntry}

  rule InferSortArgs3(#env, #sortvararg, Cons(#sortvar:String, #sortvars:List<String>), #csort*, #mapping)
  → InferSortArgs4(#env, #sortvararg, #sortvars, #csort*, Append<Pair>(PairCons(#sortvar, #sortvararg), #mapping))

  rule InferSortArgs3(#env, #sortvararg, Nil, #csort*, #mapping) → PushSortArgs(#env, #mapping)

func InferSortArgs4({String:IEnvEntry}, String, List<String>, List<Core_csort_sort>, List<Pair<String String>>) -> {String:IEnvEntry}

  rule InferSortArgs4(#env, #sortvararg, #sortvars, csort*⟦⟧, #mapping)
  → InferSortArgs2(#env, #sortvars, csort*⟦⟧, #mapping)

  rule InferSortArgs4(#env, #sortvararg, #sortvars, csort*⟦ ##csort ##csort* ⟧, #mapping)
  → InferSortArgs2(PutSort(#env, #sortvararg, #csort), #sortvars, #csort*, #mapping)

// --- Sort unification

/* Unify `#sort1` such that under a set of substitutions it is equal to `#sort2`.
   @param `#env` the environment containing the sort environment and sort argument mappings
   @param `#sort1` formal sort
   @param `#sort2` actual sort
   @return The environment containing an updated sort environment with substitutions unifying `#sort1` and  `#sort2`.
          If no such substitution is found, an error is raised.
 */
func UnifySort({String:IEnvEntry}, Core_csort_sort, Core_csort_sort) -> {String:IEnvEntry}

  rule UnifySort(#env, csort⟦ ##CONSTRUCTOR ##csorts? ⟧, csort⟦ ##CONSTRUCTOR2 ##csorts?2 ⟧)
  //→ CheckConstructor(#CONSTRUCTOR, #CONSTRUCTOR2, ()->CheckArity(#csorts?, #csorts?2, ()->UnifyMaybeSorts(#env, #csorts?, #csorts?)))
  → UnifyMaybeSorts(#env, #csorts?, #csorts?2)

  rule UnifySort(#env, csort⟦ ##VARIABLE ⟧, #csort)
  → UnifySortVar(#env, #VARIABLE, GetSortArg(#env, #VARIABLE), #csort)

  rule UnifySort(#env, #csort, csort⟦ ##VARIABLE ⟧)
  → UnifySortVar2(#env, GetSort(#env, #VARIABLE), #VARIABLE, #csort)

  rule UnifySort(#env, csort⟦ [ ##csort11 ] ##csort12 ⟧, csort⟦ [ ##csort21 ] ##csort22 ⟧)
  → UnifySort(UnifySort(#env, #csort11, #csort21), #csort12, #csort22)

  rule UnifySort(#env, csort⟦ ( ##csort11 ) ##csort12 ⟧, csort⟦ ( ##csort21 ) ##csort22 ⟧)
  → UnifySort(UnifySort(#env, #csort11, #csort21), #csort12, #csort22)

  rule UnifySort(#env, csort⟦ { ##csort11 : ##csort12 } ⟧, csort⟦ { ##csort21 : ##csort22 } ⟧)
  → UnifySort(UnifySort(#env, #csort11, #csort21), #csort12, #csort22)

  rule UnifySort(#env, csort⟦ thunk ##csort1 ⟧, #csort2) → UnifySort(#env, #csort1, #csort2)
  rule UnifySort(#env, #csort1, csort⟦ thunk ##csort2 ⟧) → UnifySort(#env, #csort1, #csort2)
  rule UnifySort(#env, csort⟦ data ##csort1 ⟧, #csort2)  → UnifySort(#env, #csort1, #csort2)
  rule UnifySort(#env, #csort1, csort⟦ data ##csort2 ⟧)  → UnifySort(#env, #csort1, #csort2)

  rule UnifySort(#env, #csort1, #csort2                ) → Error<{String:Core_csort_sort}>(ConcatString("Error: type ", ConcatString(PrintSort(#csort2), ConcatString(" is not an instance of type ", PrintSort(#csort1)))))

// -- Sub sorts

func UnifyMaybeSorts({String:IEnvEntry}, List<Core_csorts_sort>, List<Core_csorts_sort>) -> {String:IEnvEntry}
rule UnifyMaybeSorts(#env, csorts?⟦              ⟧, csorts?⟦               ⟧) → #env
rule UnifyMaybeSorts(#env, csorts?⟦ ( ##csort*1 )⟧, csorts?⟦ ( ##csort*2 ) ⟧) → UnifySorts(#env, #csort*1, #csort*2)

func UnifySorts({String:IEnvEntry}, List<Core_csort_sort>, List<Core_csort_sort>) -> {String:IEnvEntry}
rule UnifySorts(#env, csort*⟦                    ⟧, csort*⟦                    ⟧) → #env
rule UnifySorts(#env, csort*⟦ ##csort1 ##csort*1 ⟧, csort*⟦ ##csort2 ##csort*2 ⟧) → UnifySorts(UnifySort(#env, #csort1, #csort2), #csort*1, #csort*2)
rule UnifySorts(#env, #csort*1, #csort*2) → Error<{String:IEnvEntry}>("Error: mismatched type arity for type XX and YY") // TODO

// -- Variable

func UnifySortVar({String:IEnvEntry}, String, Option<String>, Core_csort_sort) -> {String:IEnvEntry}
rule UnifySortVar(#env, #variable, NONE                 , #csort) → Error<{String:Core_csort_sort}>(ConcatString("Error: undeclared type variable ", #variable))
rule UnifySortVar(#env, #variable, SOME(#sortarg:String), #csort) → UnifySortVar2(#env, GetSort(#env, #sortarg), #sortarg, #csort)

func UnifySortVar2({String:IEnvEntry}, Option<Core_csort_sort>, String, Core_csort_sort) -> {String:IEnvEntry}

  // Case 1: no existing mapping. Create it
  rule UnifySortVar2(#env, NONE, #csortarg, #csort) → PutSort(#env, #csortarg, #csort)

  // Case 2: there is already a mapping to a sort variable and new sort is also a sort variable
  rule UnifySortVar2(#env, SOME(csort⟦ ##VARIABLE1 ⟧), #csortarg, csort⟦ ##VARIABLE2 ⟧)
  → If<{String:Core_csort_sort}>(StringEqual(#VARIABLE1, #VARIABLE2),
      // Same variable, nothing to do
      ()->#env,
      // Not the same variable. Instantiate both directions
      ()->PutSort(#env, #VARIABLE2, csort⟦ ##VARIABLE1 ⟧)) // TODO: check that's enough
      //()->UnifySortVar(UnifySortVar(#env, #VARIABLE2, SOME(#VARIABLE2), csort⟦ ##VARIABLE1 ⟧), #VARIABLE1, SOME(#VARIABLE1), csort⟦ ##VARIABLE2 ⟧))

  // Case 3, there is already a mapping to a sort variable.
  rule UnifySortVar2(#env, SOME(csort⟦ ##VARIABLE1 ⟧), #csortarg, #csort)
  → UnifySortVar(#env, #VARIABLE1, SOME(#VARIABLE1), #csort)

  // Case 4, there is already a mapping to a sort that is not a variable
  rule UnifySortVar2(#env, SOME(#csort:Core_csort_sort), #csortarg, csort⟦ ##VARIABLE2 ⟧)
  → UnifySortVar(#env, #VARIABLE2, SOME(#VARIABLE2), #csort)

  // Case 5, there is already a mapping to non sort variables
  rule UnifySortVar2(#env, SOME(#csort1:Core_csort_sort), #csortarg, #csort2)
  → #env // TODO: could check csort1 = csort2

/* Same as above where actual sort is wrapped inside a sort annotation. */
func UnifySortAnno<a>({String:IEnvEntry}, Core_csort_sort, List<Core_csortanno_sort>, ({String:IEnvEntry} Core_csort_sort)->a) -> a

  // No sort annotation: create a new sort variable and unify.
  rule UnifySortAnno(#env, #fsort, csortanno?⟦           ⟧, #cont) → UnifySortAnnoAux<a>(IIncCounter(#env), #fsort, csort⟦ ⟨VARIABLE:INewSortVar(#env)⟩ ⟧, #cont)

 // With sort annotation: just unify.
  rule UnifySortAnno(#env, #fsort, csortanno?⟦ : ##csort ⟧, #cont) → #cont(UnifySort(#env, #fsort, #csort), #fsort)

func UnifySortAnnoAux<a>(#env: {String:IEnvEntry}, #fsort: Core_csort_sort, #csort: Core_csort_sort, #cont: ({String:IEnvEntry} Core_csort_sort)->a) -> a
→ #cont(UnifySort(#env, #fsort, #csort), #fsort)

// ---- Sort environment optimizer

/* Optimize the sort environment by computing its transitive closure. */
func OptimizeSorts(#env: {String : IEnvEntry}) -> {String : IEnvEntry}
→ SetSorts(#env, FoldlP<String {String : Core_csort_sort}>((key sorts) -> OptimizeSort(sorts, (key,), MapGet<String Core_csort_sort>(sorts, key)), GetSorts(#env), MapKeys<String Core_csort_sort>(GetSorts(#env))))

func OptimizeSort({String : Core_csort_sort}, List<String>, Option<Core_csort_sort>) -> {String : Core_csort_sort}
rule OptimizeSort(#sorts, #keys, SOME(csort⟦ ##VARIABLE ⟧))   → OptimizeSort(#sorts, Cons(#VARIABLE, #keys), MapGet<String Core_csort_sort>(#sorts, #VARIABLE))
rule OptimizeSort(#sorts, #keys, SOME(#sort:Core_csort_sort)) → FoldlP<String {String : Core_csort_sort}>((key sorts)->MapPut<String Core_csort_sort>(sorts, key, #sort), #sorts, #keys)
rule OptimizeSort(#sorts, #keys, NONE                    )    → #sorts

// ---- Apply sort instantiation

// TODO: check for empty sort environment.
func SubstRule(#env: {String:IEnvEntry}, #cterm1: Core_cterm_sort, #cterm2: Core_cterm_sort) -> Core_cdecl_sort
→ cdecl⟦ rule ⟨cterm: SubstTerm(#env, #cterm1)⟩ → ⟨cterm: SubstTerm(#env, #cterm2)⟩ ⟧

func SubstTerm({String:IEnvEntry}, Core_cterm_sort) -> Core_cterm_sort
rule SubstTerm(#env, cterm⟦ ##cqconstructor ##csortargs? ##cterms? ##csortanno? ⟧) → cterm⟦ ##cqconstructor ⟨csortargs?: SubstMaybeSortArgs(#env, #csortargs?)⟩ ⟨cterms?: SubstMaybeTerms(#env, #cterms?)⟩ ⟨csortanno?: SubstMaybeSortAnno(#env, #csortanno?)⟩ ⟧
rule SubstTerm(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧)          → cterm⟦ ##METAVAR ⟨cterms?: SubstMaybeTerms(#env, #cterms?)⟩ ⟨csubst?: SubstMaybeSubst(#env, #csubst?)⟩ ⟨csortanno?: SubstMaybeSortAnno(#env, #csortanno?)⟩ ⟧
rule SubstTerm(#env, cterm⟦ [ x ##csortanno? ] ##cterm ⟧)                          → cterm⟦ [ x ##csortanno? ] ⟨cterm: SubstTerm(#env, #cterm[x])⟩ ⟧
rule SubstTerm(#env, cterm⟦ ( f ##csortanno? ) ##cterm ⟧)                          → cterm⟦ ( f ##csortanno? ) ⟨cterm: SubstTerm(#env, #cterm[f])⟩ ⟧
rule SubstTerm(#env, cterm⟦ thunk ##cterm ⟧)                                       → cterm⟦ thunk ⟨cterm: SubstTerm(#env, #cterm)⟩ ⟧
rule SubstTerm(#env, #cterm)                                                      → #cterm
// TODO: map

func SubstMaybeSortArgs({String:IEnvEntry}, List<Core_csortargs_sort>) -> List<Core_csortargs_sort>
rule SubstMaybeSortArgs(#env, csortargs?⟦              ⟧) → csortargs?⟦⟧
rule SubstMaybeSortArgs(#env, csortargs?⟦ < ##csort* > ⟧) → csortargs?⟦ < ⟨csort*: SubstSorts(#env, #csort*)⟩ >⟧

func SubstMaybeTerms({String:IEnvEntry}, List<Core_cterms_sort>) -> List<Core_cterms_sort>
rule SubstMaybeTerms(#env, cterms?⟦              ⟧) → cterms?⟦⟧
rule SubstMaybeTerms(#env, cterms?⟦ ()           ⟧) → cterms?⟦ () ⟧
rule SubstMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧) → cterms?⟦ ( ⟨cterm*: SubstTerms(#env, #cterm*)⟩ ) ⟧

func SubstMaybeSortAnno({String:IEnvEntry}, List<Core_csortanno_sort>) -> List<Core_csortanno_sort>
rule SubstMaybeSortAnno(#env, csortanno?⟦           ⟧) → csortanno?⟦⟧
rule SubstMaybeSortAnno(#env, csortanno?⟦ : ##csort ⟧) → csortanno?⟦ : ⟨csort: SubstSort(#env, #csort)⟩ ⟧

func SubstMaybeSubst({String:IEnvEntry}, List<Core_csubst_sort>) -> List<Core_csubst_sort>
rule SubstMaybeSubst(#env, csubst?⟦              ⟧) → csubst?⟦⟧
rule SubstMaybeSubst(#env, csubst?⟦ [ ##cterm* ] ⟧) → csubst?⟦ [ ⟨cterm*: SubstTerms(#env, #cterm*)⟩ ] ⟧

func SubstTerms({String:IEnvEntry}, List<Core_cterm_sort>) -> List<Core_cterm_sort>
rule SubstTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧) → cterm*⟦ ⟨cterm: SubstTerm(#env, #cterm)⟩ ⟨cterm*: SubstTerms(#env, #cterm*)⟩ ⟧
rule SubstTerms(#env, cterm*⟦                  ⟧) → cterm*⟦⟧

func SubstSorts({String:IEnvEntry}, List<Core_csort_sort>) -> List<Core_csort_sort>
rule SubstSorts(#env, csort*⟦ ##csort ##csort* ⟧) → csort*⟦ ⟨csort: SubstSort(#env, #csort)⟩ ⟨csort*: SubstSorts(#env, #csort*)⟩ ⟧
rule SubstSorts(#env, csort*⟦                  ⟧) → csort*⟦⟧

func SubstSort({String:IEnvEntry}, Core_csort_sort) -> Core_csort_sort
rule SubstSort(#env, csort⟦ ##CONSTRUCTOR ##csorts? ⟧) → csort⟦ ##CONSTRUCTOR ⟨csorts?: SubstMaybeSorts(#env, #csorts?)⟩ ⟧
rule SubstSort(#env, csort⟦ ##VARIABLE              ⟧) → SubstVar(#VARIABLE, GetSort(#env, #VARIABLE))
rule SubstSort(#env, csort⟦ [ ##csort1 ] ##csort2   ⟧) → csort⟦ [ ⟨csort: SubstSort(#env, #csort1)⟩ ] ⟨csort: SubstSort(#env, #csort2)⟩ ⟧
rule SubstSort(#env, csort⟦ ( ##csort1 ) ##csort2   ⟧) → csort⟦ ( ⟨csort: SubstSort(#env, #csort1)⟩ ) ⟨csort: SubstSort(#env, #csort2)⟩ ⟧
rule SubstSort(#env, csort⟦ { ##cmapsort* }         ⟧) → csort⟦ { ⟨cmapsort*: SubstMapSorts(#env, #cmapsort*)⟩ } ⟧
rule SubstSort(#env, csort⟦ thunk ##csort           ⟧) → csort⟦ thunk ⟨csort: SubstSort(#env, #csort)⟩ ⟧
rule SubstSort(#env, csort⟦ data ##csort            ⟧) → csort⟦ data ⟨csort: SubstSort(#env, #csort)⟩ ⟧

func SubstMaybeSorts({String:IEnvEntry}, List<Core_csorts_sort>) -> List<Core_csorts_sort>
rule SubstMaybeSorts(#env, csorts?⟦ ( ##csort* ) ⟧) → csorts?⟦ ( ⟨csort*: SubstSorts(#env, #csort*)⟩ ) ⟧
rule SubstMaybeSorts(#env, csorts?⟦              ⟧) → csorts?⟦⟧

// The insteresting bit is here. The rest is just boilerplate.
func SubstVar(String, Option<Core_csort_sort>) -> Core_csort_sort
rule SubstVar(#VARIABLE, NONE                        ) → csort⟦ ##VARIABLE ⟧  // generic variable
rule SubstVar(#VARIABLE, SOME(#csort:Core_csort_sort)) → #csort              // variable is replaced.

func SubstMapSorts({String:IEnvEntry}, List<Core_cmapsort_sort>) -> List<Core_cmapsort_sort>
rule SubstMapSorts(#env, cmapsort*⟦                                 ⟧) → cmapsort*⟦⟧
rule SubstMapSorts(#env, cmapsort*⟦ ##csort1 : ##csort2 ##cmapsort* ⟧) → cmapsort*⟦ ⟨csort: SubstSort(#env, #csort1)⟩ : ⟨csort: SubstSort(#env, #csort2)⟩  ⟨cmapsort*: SubstMapSorts(#env, #cmapsort*)⟩ ⟧

// --- Various utility functions

/* Check the given `#sortanno?` matches the given `#sort`. Output an error if not, otherwise apply `#result` */
func CheckSortAnnoE<a>(List<Core_csortanno_sort>, Core_csort_sort, ()->a) -> a
rule CheckSortAnnoE(csortanno?⟦           ⟧, #csort, #result) → #result()
rule CheckSortAnnoE(csortanno?⟦ : ##csort ⟧, #csort, #result) → #result()  // TODO: really check when Equal is fixed.

/* Create a new sort variable */
func INewSortVar(#env: {String:IEnvEntry}) -> String
→ ConcatString("a", FormatNumber(IGetCounter(#env)))
