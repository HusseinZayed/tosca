// Copyright (c) 2016 IBM Corporation.
/*
  Propagate missing sort annotations and sort variables, but only to compensate the target language limitations.

  For Java:
  - Sort parameters must be instantiated (eg. ListLength<Numeric>(...))
  - Meta-variable sort annotations must be specified (meta-variable declarations only)
  - Data constructor must be prefixed by their sort. (eg. List<a>::Cons) (for now in pattern only)

  For C++:
  - ...

  Also perform opportunistic sort checking. The full complete sort checking is done by the target language

  The algorithm used below is inspired by Pierce's bidirectional local sort inference as described
  in http://www.cis.upenn.edu/~bcpierce/papers/lti-toplas.pdf

  TODO: describe differences.

  The sort inference below is done in two passes:
  - The first pass propagates sorts bottom-up. Unspecified sorts are retrieved from sort declarations. The sort environment is extended with sort instantiations.
  - The second pass first starts by solving contraints stored in the sort environment and then apply sort variable instantiations.
    by traversing the term tree top-down.


 */
import Std::Core
import Std::Listdef
import Std::Pairdef
import Std::Mapdef
import Std::String
import Core::Core
import Core::Utils
import Infer::Env
import Systemdef

// --- Top-level system traversal

/* Infer sorts of given `#system`
   @param System The Tosca system */
func InferSystem(TSystem) -> TSystem
rule InferSystem(TSystem(#url:String, #modules:{String : Module}))
→ TSystem(#url, MapIndex<String Module>(Map<Module Pair<String Module>>((mod) -> InferModule(mod, TSystem(#url, #modules)), MapValues<String Module>(#modules))))

// -- Module

func InferModule(Module, TSystem) -> Pair<String Module>
rule InferModule(Module(#url:String, #content: Content), #system) → PairCons(#url, Module(#url, InferContent(#content, #system)))

// -- Content

func InferContent(Content, TSystem) -> Content
rule InferContent(Loaded(#content:LoadedContent), #system)
→ Loaded(FoldlP<String LoadedContent>((key content) -> InferRules(key, UnSOME<List>(GetRulesForKeyC(content, key)), content, #system),
                               #content,
                               MapKeys<String List>(GetRules(#content))))

// -- Rules

func InferRules(#key: String, #rules: List<Core_cdecl_sort>, #content: LoadedContent, #system: TSystem) -> LoadedContent
→ PutRulesC(#content, #key, Map<Core_cdecl_sort Core_cdecl_sort>((rul) -> InferRule(EnvNew(#content, #system), rul), #rules))

// -- Rule

func InferRule({String:EnvEntry}, Core_cdecl_sort) -> Core_cdecl_sort
rule InferRule(#env, cdecl⟦ rule ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? → ##cterm ⟧)
→ InferPatternUp(InferFunc(ResetEnv(#env), #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, NONE), #cterm, FindFuncSortS(GetSystem(#env), #CONSTRUCTOR))

func InferPatternUp(Pair<{String:EnvEntry} Core_cterm_sort>, Core_cterm_sort, Option<Core_cdecl_sort>) -> Core_cdecl_sort
rule InferPatternUp(PairCons(#env:{String:EnvEntry}, #pattern:Core_cterm_sort), #contractum, SOME(cdecl⟦ ##canno* ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧))
→ InferRuleUp(#pattern, InferTerm(SetInPattern(ResetEnv(#env), FALSE), #contractum, #csort))

func InferRuleUp(Core_cterm_sort, Pair<{String:EnvEntry} Core_cterm_sort>) -> Core_cdecl_sort
rule InferRuleUp(#cterm1, PairCons(#env:{String:EnvEntry}, #cterm2:Core_cterm_sort)) → SubstRule(OptimizeSorts(#env), #cterm1, #cterm2)

// ---- Synthesize sorts

// --- Terms

/* Synthesize term sort.
   @return a pair consisting of an updated environment and the sorted term (which might contain sort variables)
*/
func InferTerm({String:EnvEntry}, Core_cterm_sort, Core_csort_sort /* formal sort */) -> Pair<{String:EnvEntry} Core_cterm_sort>

  rule InferTerm(#env, cterm⟦ ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #csort)
  → InferCons(#env, GetInPattern(#env), IsDataS(GetSystem(#env), #CONSTRUCTOR), #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #csort)

  rule InferTerm(#env, cterm⟦ ##STRING ⟧, #csort) → PairCons(InstantiateSort(#env, #csort, csort⟦ String  ⟧), cterm⟦ ##STRING ⟧)
  rule InferTerm(#env, cterm⟦ ##NUMBER ⟧, #csort) → PairCons(InstantiateSort(#env, #csort, csort⟦ Numeric ⟧), cterm⟦ ##NUMBER ⟧)

  // TODO: traverse when contraction
  // metavar arguments on pattern must all be variables. No need to traverse. TODO: could check arity
  rule InferTerm(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #csort)
  // TODO: enable when issue #15 is fixed
  //→ CheckSortAnnoE<Pair<{String:EnvEntry} Core_cterm_sort>>(#csortanno?, #csort, () -> PairCons(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? : ##csort ⟧))
  → PairCons(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? : ##csort ⟧)

  // TODO:
  rule InferTerm(#env, cterm⟦ ##VARIABLE ##csortanno? ⟧, #csort) // TODO: could check sort annotation
  → PairCons(#env, cterm⟦ ##VARIABLE ##csortanno? ⟧)

  rule InferTerm(#env, cterm⟦ [ v ##csortanno? ] ##cterm ⟧, csort⟦ [ ##csort1 ] ##csort ⟧)
  → CheckSortAnnoE<Pair<{String:EnvEntry} Core_cterm_sort>>(#csortanno?, #csort1, ()->InferBinderUp([v] -> InferTerm(#env, #cterm[v], #csort), #csort1))

  rule InferTerm(#env, cterm⟦ [ v ##csortanno? ] ##cterm ⟧, #csort)
  → Error<Pair<{String:EnvEntry} Core_cterm_sort>>("Type error") // TODO:

  rule InferTerm(#env, cterm⟦ ( f ##csortanno? ) ##cterm ⟧, csort⟦ ( ##csort1 ) ##csort ⟧)
  → CheckSortAnnoE<Pair<{String:EnvEntry} Core_cterm_sort>>(#csortanno?, #csort1, ()->InferFormalUp([f] -> InferTerm(#env, #cterm[f], #csort), #csort1))

  rule InferTerm(#env, cterm⟦ ( f ##csortanno? ) ##cterm ⟧, #csort) → Error<Pair<{String:EnvEntry} Core_cterm_sort>>("Type error") // TODO:
  rule InferTerm(#env, cterm⟦ thunk ##cterm              ⟧, #csort) → InferTerm(#env, #cterm, #csort)

/* Traverse terms if any */
func InferMaybeTerms({String:EnvEntry}, List<Core_cterms_sort>, List<Core_csort_sort>) -> Pair<{String:EnvEntry} List<Core_cterms_sort>>
rule InferMaybeTerms(#env, cterms?⟦              ⟧, #csort*) → PairCons(#env, cterms?⟦⟧) // TODO: check sort arity
rule InferMaybeTerms(#env, cterms?⟦ (          ) ⟧, #csort*) → PairCons(#env, cterms?⟦⟧)  // TODO: check sort arity
rule InferMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧, #csort*) → UnPair<{String:EnvEntry} List Pair>(InferTerms(#env, #cterm*, #csort*), (env terms)->PairCons(env, cterms?⟦ ( ⟨cterm*: terms⟩ )⟧))

/* Traverse terms */
func InferTerms({String:EnvEntry}, List<Core_cterm_sort>, List<Core_csort_sort>) -> Pair<{String:EnvEntry} List<Core_cterm_sort>>
rule InferTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, csort*⟦ ##csort ##csort* ⟧) → InferTermsUp(InferTerm(#env, #cterm, #csort), #cterm*, #csort*)
rule InferTerms(#env, cterm*⟦                  ⟧, csort*⟦                  ⟧) → PairCons(#env, cterm*⟦⟧)
rule InferTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧, csort*⟦                  ⟧) → Error<Pair<{String:EnvEntry} List<Core_cterm_sort>>>("Error: too many arguments.")
rule InferTerms(#env, cterm*⟦                  ⟧, csort*⟦ ##csort ##csort* ⟧) → Error<Pair<{String:EnvEntry} List<Core_cterm_sort>>>("Error: not enough arguments.")

/* Reconstruct terms */
func InferTermsUp(Pair<{String:EnvEntry} Core_cterm_sort>, List<Core_cterm_sort>, List<Core_csort_sort>) -> Pair<{String:EnvEntry} List<Core_cterm_sort>>
rule InferTermsUp(PairCons(#env:{String:EnvEntry} , #cterm:Core_cterm_sort), #cterm*, #csort*)
→ UnPair<{String:EnvEntry} List Pair>(InferTerms(#env, #cterm*, #csort*), (env cterms) -> PairCons(env, cterm*⟦ ##cterm ⟨cterm*: cterms⟩⟧))

/* Synthesize construction sort
   @param `#env`
   @param `#inpattern`
   @param `#isdatasort`
 */
func InferCons({String:EnvEntry}, Bool, Bool, String, List<Core_csortargs_sort>, List<Core_cterms_sort>, List<Core_csortanno_sort>, Core_csort_sort) -> Pair<{String:EnvEntry} Core_cterm_sort>

  rule InferCons(#env, #inpattern, TRUE, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #csort)
  → InferConsUp(#CONSTRUCTOR, InferDataSubs(InstantiateSortArgs(#env, (), ()), #cterms?, FindFormS(GetSystem(#env), #csort, #CONSTRUCTOR), #CONSTRUCTOR, #csort), SOME(#csort))

  rule InferCons(#env, FALSE, FALSE, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #csort)
  → InferFunc(#env, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, SOME(#csort))

  rule InferCons(#env, TRUE, FALSE, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #csort)
  → Error<Pair<{String:EnvEntry} Core_cterm_sort>>(ConcatString("Error: function symbol cannot occur in pattern: ", #CONSTRUCTOR))

/* Reconstruct construction */
func InferConsUp(String, Pair<{String:EnvEntry} List<Core_cterms_sort>>, Option<Core_csort_sort>) -> Pair<{String:EnvEntry} Core_cterm_sort>
  rule InferConsUp(#CONSTRUCTOR, PairCons(#env:{String:EnvEntry}, #cterms?:List<Core_cterms_sort>), SOME(#csort:Core_csort_sort))
  → PairCons(PopSortArgs(#env), cterm⟦ ##csort :: ##CONSTRUCTOR ⟨csortargs?: TopSortArgs(#env)⟩ ##cterms? : ##csort ⟧)

  rule InferConsUp(#CONSTRUCTOR, PairCons(#env:{String:EnvEntry}, #cterms?:List<Core_cterms_sort>), NONE)
  → PairCons(PopSortArgs(#env), cterm⟦ ##CONSTRUCTOR ⟨csortargs?: TopSortArgs(#env)⟩ ##cterms? ⟧)

/* Infer sorts for function application. */
func InferFunc(#env: {String:EnvEntry}, #CONSTRUCTOR: String, #csortargs?: List<Core_csortargs_sort>, #cterms?: List<Core_cterms_sort>,
                  #csortanno?: List<Core_csortanno_sort>, #csort: Option<Core_csort_sort>) -> Pair<{String:EnvEntry} Core_cterm_sort>
→ InferConsUp(#CONSTRUCTOR, InferFuncSubs(#env, FindFuncSortS(GetSystem(#env), #CONSTRUCTOR), #csortargs?, #cterms?, #CONSTRUCTOR), #csort)

/* Traverse data construction sub terms */
func InferDataSubs({String:EnvEntry}, List<Core_cterms_sort>, Option<Pair<Core_csort_sort Core_cform_sort>>, String, Core_csort_sort) -> Pair<{String:EnvEntry} List<Core_cterms_sort>>
rule InferDataSubs(#env, #cterms?, SOME(Pair<Core_csort_sort Core_cform_sort>::PairCons(#csort:Core_csort_sort, cform⟦ ##CONSTRUCTOR ( ##csort* ) ⟧)), #formname, #fsort) → InferMaybeTerms(InstantiateSort(#env, #fsort, #csort), #cterms?, #csort*)
rule InferDataSubs(#env, cterms?⟦⟧, SOME(Pair<Core_csort_sort Core_cform_sort>::PairCons(#csort:Core_csort_sort, cform⟦ ##CONSTRUCTOR              ⟧)), #formname, #fsort) → PairCons(InstantiateSort(#env, #fsort, #csort), cterms?⟦⟧)
rule InferDataSubs(#env, #cterms?, NONE                                    , #formname, #fsort) → Error<Pair>(ConcatString("Error: undefined enumeration value ", #formname)) // TODO: in sort #fsort
rule InferDataSubs(#env, #cterms?, SOME(Pair<Core_csort_sort Core_cform_sort>::PairCons(#csort:Core_csort_sort, #cform: Core_cform_sort))           , #formname, #fsort) → Error<Pair>(ConcatString("Error: wrong arity for enumeration value ", #formname))

/* Traverse function construction sub terms */
func InferFuncSubs({String:EnvEntry}, Option<Core_cdecl_sort>, List<Core_csortargs_sort>, List<Core_cterms_sort>, String) -> Pair<{String:EnvEntry} List<Core_cterms_sort>>
rule InferFuncSubs(#env, SOME(cdecl⟦ ##canno* ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ( ##csort* ) ⟧), #csortargs?, #cterms?, #funcname) → InferMaybeTerms(InstantiateSortArgs(#env, #csortvars?, #csortargs?), #cterms?, #csort*)
rule InferFuncSubs(#env, SOME(cdecl⟦ ##canno* ##extern_TOK? func ##csortvars? ##csort ##CONSTRUCTOR ⟧), #csortargs?, cterms?⟦⟧, #funcname) → PairCons(InstantiateSortArgs(#env, #csortvars?, #csortargs?), cterms?⟦⟧)
rule InferFuncSubs(#env, NONE                                                                         , #csortargs?, cterms?⟦⟧, #funcname) → Error<Pair>(ConcatString("Error: undeclared function named ", #funcname))
rule InferFuncSubs(#env, SOME(#cdecl:Core_cdecl_sort)                                                 , #csortargs?, #cterms?, #funcname) → Error<Pair>(ConcatString("Error: wrong arity for function ", #funcname))

/* Reconstruct binder */
// Note: #env is weak.
func InferBinderUp([String] -> Pair<{String:EnvEntry} Core_cterm_sort>, Core_csort_sort) -> Pair<{String:EnvEntry} Core_cterm_sort>
rule InferBinderUp([b] -> PairCons(#env:{String:EnvEntry}, #cterm[b]:Core_cterm_sort), #csort) → PairCons(#env, cterm⟦ [ b : ##csort ] ##cterm ⟧)

/* Reconstruct formal parameter */
// Note: #env is weak.
func InferFormalUp([String] -> Pair<{String:EnvEntry} Core_cterm_sort>, Core_csort_sort) -> Pair<{String:EnvEntry} Core_cterm_sort>
rule InferFormalUp([f] -> PairCons(#env:{String:EnvEntry}, #cterm[f]:Core_cterm_sort), #csort) → PairCons(#env, cterm⟦ ( f : ##csort ) ##cterm ⟧)

// --- Sort instantiation

/* Instantiate `#sort1` such that under a set of substitutions it is equal to `#sort2`.
   @param `#env` the environment containing the sort environment and sort argument mappings
   @param `#sort1` formal sort
   @param `#sort2` actual sort
   @return The environment containing an updated sort environment with substitutions instantiating `#sort1` to be equal to `#sort2`.
          If no such substitution is found (`#sort2` is not an instance of `#sort2`), an error is raised.
 */
func InstantiateSort({String:EnvEntry}, Core_csort_sort, Core_csort_sort) -> {String:EnvEntry}
  rule InstantiateSort(#env, csort⟦ ##CONSTRUCTOR ##csorts? ⟧, csort⟦ ##CONSTRUCTOR2 ##csorts?2 ⟧)
  //→ CheckConstructor(#CONSTRUCTOR, #CONSTRUCTOR2, ()->CheckArity(#csorts?, #csorts?2, ()->InstantiateMaybeSorts(#env, #csorts?, #csorts?)))
  → InstantiateMaybeSorts(#env, #csorts?, #csorts?2)

  rule InstantiateSort(#env, csort⟦ ##VARIABLE ⟧, #csort)
  → InstantiateSortVar(#env, #VARIABLE, GetSortArg(#env, #VARIABLE), #csort)

  rule InstantiateSort(#env, csort⟦ [ ##csort11 ] ##csort12 ⟧, csort⟦ [ ##csort21 ] ##csort22 ⟧)
  → InstantiateSort(InstantiateSort(#env, #csort11, #csort21), #csort12, #csort22)

  rule InstantiateSort(#env, csort⟦ ( ##csort11 ) ##csort12 ⟧, csort⟦ ( ##csort21 ) ##csort22 ⟧)
  → InstantiateSort(InstantiateSort(#env, #csort11, #csort21), #csort12, #csort22)

  rule InstantiateSort(#env, csort⟦ { ##csort11 : ##csort12 } ⟧, csort⟦ { ##csort21 : ##csort22 } ⟧)
  → InstantiateSort(InstantiateSort(#env, #csort11, #csort21), #csort12, #csort22)

  rule InstantiateSort(#env, csort⟦ thunk ##csort1 ⟧, #csort2) → InstantiateSort(#env, #csort1, #csort2)
  rule InstantiateSort(#env, #csort1, csort⟦ thunk ##csort2 ⟧) → InstantiateSort(#env, #csort1, #csort2)
  rule InstantiateSort(#env, #csort1, #csort2                ) → Error<{String:Core_csort_sort}>("Error: type XX is not an instance of type YY") // TODO: print

// -- Sub sorts

func InstantiateMaybeSorts({String:EnvEntry}, List<Core_csorts_sort>, List<Core_csorts_sort>) -> {String:EnvEntry}
rule InstantiateMaybeSorts(#env, csorts?⟦              ⟧, csorts?⟦               ⟧) → #env
rule InstantiateMaybeSorts(#env, csorts?⟦ ( ##csort*1 )⟧, csorts?⟦ ( ##csort*2 ) ⟧) → InstantiateSorts(#env, #csort*1, #csort*2)

func InstantiateSorts({String:EnvEntry}, List<Core_csort_sort>, List<Core_csort_sort>) -> {String:EnvEntry}
rule InstantiateSorts(#env, csort*⟦                    ⟧, csort*⟦                    ⟧) → #env
rule InstantiateSorts(#env, csort*⟦ ##csort1 ##csort*1 ⟧, csort*⟦ ##csort2 ##csort*2 ⟧) → InstantiateSorts(InstantiateSort(#env, #csort1, #csort2), #csort*1, #csort*2)
rule InstantiateSorts(#env, #csort*1, #csort*2) → Error<{String:EnvEntry}>("Error: mismatched type arity for type XX and YY") // TODO

// -- Variable

func InstantiateSortVar({String:EnvEntry}, String, Option<String>, Core_csort_sort) -> {String:EnvEntry}
rule InstantiateSortVar(#env, #variable, NONE                 , #csort) → Error<{String:Core_csort_sort}>(ConcatString("Error: undeclared type variable ", #variable))
rule InstantiateSortVar(#env, #variable, SOME(#sortarg:String), #csort) → InstantiateSortVar2(#env, GetSort(#env, #sortarg), #sortarg, #csort)

func InstantiateSortVar2({String:EnvEntry}, Option<Core_csort_sort>, String, Core_csort_sort) -> {String:EnvEntry}
  // Case 1: no existing mapping. Create it
  rule InstantiateSortVar2(#env, NONE, #csortarg, #csort) → PutSort(#env, #csortarg, #csort)

  // Case 2: there is already a mapping to a sort variable and new sort is also a sort variable
  rule InstantiateSortVar2(#env, SOME(csort⟦ ##VARIABLE1 ⟧), #csortarg, csort⟦ ##VARIABLE2 ⟧)
  → If<{String:Core_csort_sort}>(StringEqual(#VARIABLE1, #VARIABLE2),
      // Same variable, nothing to do
      ()->#env,
      // Not the same variable. Instantiate both directions
      ()->InstantiateSortVar(InstantiateSortVar(#env, #VARIABLE2, SOME(#VARIABLE2), csort⟦ ##VARIABLE1 ⟧), #VARIABLE1, SOME(#VARIABLE1), csort⟦ ##VARIABLE2 ⟧))

  // Case 3, there is already a mapping to a sort variable.
  rule InstantiateSortVar2(#env, SOME(csort⟦ ##VARIABLE1 ⟧), #csortarg, #csort)
  → InstantiateSortVar(#env, #VARIABLE1, SOME(#VARIABLE1), #csort)

  // Case 4, there is already a mapping to a sort that is not a variable
  rule InstantiateSortVar2(#env, SOME(#csort:Core_csort_sort), #csortarg, csort⟦ ##VARIABLE2 ⟧)
  → InstantiateSortVar(#env, #VARIABLE2, SOME(#VARIABLE2), #csort)

  // Case 5, there is already a mapping to non sort variables
  rule InstantiateSortVar2(#env, SOME(#csort1:Core_csort_sort), #csortarg, #csort2)
  → #env // TODO: could check csort1 = csort2

// --- Sort variable instantiation

/* Instantiate sort variables.

   Works as follows:
   - a variable sort argument is created for each sort variables (if any) and the correspondence
     between them is kept in the environment (see XXSortArgs functions).
   - the sort environment is extended with user-specified sort arguments (if any).
 */
func InstantiateSortArgs({String:EnvEntry}, List<Core_csortvars_sort>, List<Core_csortargs_sort>) -> {String:EnvEntry}
rule InstantiateSortArgs(#env, csortvars?⟦                     ⟧, csortargs?⟦             ⟧) → PushSortArgs(#env, ())
rule InstantiateSortArgs(#env, csortvars?⟦ ∀ ##variable_TOK+ . ⟧, csortargs?⟦             ⟧) → InstantiateSortArgs2(#env, #variable_TOK+, csort*⟦⟧, ())
rule InstantiateSortArgs(#env, csortvars?⟦ ∀ ##variable_TOK+ . ⟧, csortargs?⟦ < ##csort* >⟧) → InstantiateSortArgs2(#env, #variable_TOK+, #csort*, ())

func InstantiateSortArgs2(#env: {String:EnvEntry}, #sortvars: List<String>, #csort*: List<Core_csort_sort>, #mapping: List<Pair<String String>>) -> {String:EnvEntry}
→ InstantiateSortArgs3(IncCounter(#env), ConcatString("a", FormatNumber(GetCounter(#env))), #sortvars, #csort*, #mapping)

func InstantiateSortArgs3({String:EnvEntry}, String, List<String>, List<Core_csort_sort>, List<Pair<String String>>) -> {String:EnvEntry}

  rule InstantiateSortArgs3(#env, #sortvararg, Cons(#sortvar:String, #sortvars:List<String>), #csort*, #mapping)
  → InstantiateSortArgs4(#env, #sortvararg, #sortvars, #csort*, Append<Pair>(PairCons(#sortvar, #sortvararg), #mapping))

  rule InstantiateSortArgs3(#env, #sortvararg, Nil, #csort*, #mapping) → PushSortArgs(#env, #mapping)

func InstantiateSortArgs4({String:EnvEntry}, String, List<String>, List<Core_csort_sort>, List<Pair<String String>>) -> {String:EnvEntry}

  rule InstantiateSortArgs4(#env, #sortvararg, #sortvars, csort*⟦⟧, #mapping)
  → InstantiateSortArgs2(#env, #sortvars, csort*⟦⟧, #mapping)

  rule InstantiateSortArgs4(#env, #sortvararg, #sortvars, csort*⟦ ##csort ##csort* ⟧, #mapping)
  → InstantiateSortArgs2(PutSort(#env, #sortvararg, #csort), #sortvars, #csort*, #mapping)

// ---- Sort environment optimizer

/* Optimize the sort environment by computing its transitive closure. */
func OptimizeSorts(#env: {String : EnvEntry}) -> {String : EnvEntry}
→ SetSorts(#env, FoldlP<String {String : Core_csort_sort}>((key sorts) -> OptimizeSort(sorts, (key,), MapGet<String Core_csort_sort>(sorts, key)), GetSorts(#env), MapKeys<String Core_csort_sort>(GetSorts(#env))))

func OptimizeSort({String : Core_csort_sort}, List<String>, Option<Core_csort_sort>) -> {String : Core_csort_sort}
rule OptimizeSort(#sorts, #keys, SOME(csort⟦ ##VARIABLE ⟧))   → OptimizeSort(#sorts, Cons(#VARIABLE, #keys), MapGet<String Core_csort_sort>(#sorts, #VARIABLE))
rule OptimizeSort(#sorts, #keys, SOME(#sort:Core_csort_sort)) → FoldlP<String {String : Core_csort_sort}>((key sorts)->MapPut<String Core_csort_sort>(sorts, key, #sort), #sorts, #keys)
rule OptimizeSort(#sorts, #keys, NONE                    )    → #sorts

// ---- Apply sort instantiation

// TODO: check for empty sort environment.
func SubstRule(#env: {String:EnvEntry}, #cterm1: Core_cterm_sort, #cterm2: Core_cterm_sort) -> Core_cdecl_sort
→ cdecl⟦ rule ⟨cterm: SubstTerm(#env, #cterm1)⟩ → ⟨cterm: SubstTerm(#env, #cterm2)⟩ ⟧

func SubstTerm({String:EnvEntry}, Core_cterm_sort) -> Core_cterm_sort
rule SubstTerm(#env, cterm⟦ ##cqconstructor ##csortargs? ##cterms? ##csortanno? ⟧) → cterm⟦ ##cqconstructor ⟨csortargs?: SubstMaybeSortArgs(#env, #csortargs?)⟩ ⟨cterms?: SubstMaybeTerms(#env, #cterms?)⟩ ⟨csortanno?: SubstMaybeSortAnno(#env, #csortanno?)⟩ ⟧
rule SubstTerm(#env, cterm⟦ ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧)          → cterm⟦ ##METAVAR ⟨cterms?: SubstMaybeTerms(#env, #cterms?)⟩ ⟨csubst?: SubstMaybeSubst(#env, #csubst?)⟩ ⟨csortanno?: SubstMaybeSortAnno(#env, #csortanno?)⟩ ⟧
rule SubstTerm(#env, cterm⟦ [ x ##csortanno? ] ##cterm ⟧)                          → cterm⟦ [ x ##csortanno? ] ##cterm ⟧
rule SubstTerm(#env, cterm⟦ ( f ##csortanno? ) ##cterm ⟧)                          → cterm⟦ ( f ##csortanno? ) ##cterm ⟧
rule SubstTerm(#env, #cterm)                                                      → #cterm
// TODO: map

func SubstMaybeSortArgs({String:EnvEntry}, List<Core_csortargs_sort>) -> List<Core_csortargs_sort>
rule SubstMaybeSortArgs(#env, csortargs?⟦              ⟧) → csortargs?⟦⟧
rule SubstMaybeSortArgs(#env, csortargs?⟦ < ##csort* > ⟧) → csortargs?⟦ < ⟨csort*: SubstSorts(#env, #csort*)⟩ >⟧

func SubstMaybeTerms({String:EnvEntry}, List<Core_cterms_sort>) -> List<Core_cterms_sort>
rule SubstMaybeTerms(#env, cterms?⟦              ⟧) → cterms?⟦⟧
rule SubstMaybeTerms(#env, cterms?⟦ ()           ⟧) → cterms?⟦⟧
rule SubstMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧) → cterms?⟦ ( ⟨cterm*: SubstTerms(#env, #cterm*)⟩ ) ⟧

func SubstMaybeSortAnno({String:EnvEntry}, List<Core_csortanno_sort>) -> List<Core_csortanno_sort>
rule SubstMaybeSortAnno(#env, csortanno?⟦           ⟧) → csortanno?⟦⟧
rule SubstMaybeSortAnno(#env, csortanno?⟦ : ##csort ⟧) → csortanno?⟦ : ⟨csort: SubstSort(#env, #csort)⟩ ⟧

func SubstMaybeSubst({String:EnvEntry}, List<Core_csubst_sort>) -> List<Core_csubst_sort>
rule SubstMaybeSubst(#env, csubst?⟦              ⟧) → csubst?⟦⟧
rule SubstMaybeSubst(#env, csubst?⟦ [ ##cterm* ] ⟧) → csubst?⟦ [ ⟨cterm*: SubstTerms(#env, #cterm*)⟩ ] ⟧

func SubstTerms({String:EnvEntry}, List<Core_cterm_sort>) -> List<Core_cterm_sort>
rule SubstTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧) → cterm*⟦ ⟨cterm: SubstTerm(#env, #cterm)⟩ ⟨cterm*: SubstTerms(#env, #cterm*)⟩ ⟧
rule SubstTerms(#env, cterm*⟦                  ⟧) → cterm*⟦⟧

func SubstSorts({String:EnvEntry}, List<Core_csort_sort>) -> List<Core_csort_sort>
rule SubstSorts(#env, csort*⟦ ##csort ##csort* ⟧) → csort*⟦ ⟨csort: SubstSort(#env, #csort)⟩ ⟨csort*: SubstSorts(#env, #csort*)⟩ ⟧
rule SubstSorts(#env, csort*⟦                  ⟧) → csort*⟦⟧

func SubstSort({String:EnvEntry}, Core_csort_sort) -> Core_csort_sort
rule SubstSort(#env, csort⟦ ##CONSTRUCTOR ##csorts? ⟧) → csort⟦ ##CONSTRUCTOR ⟨csorts?: SubstMaybeSorts(#env, #csorts?)⟩ ⟧
rule SubstSort(#env, csort⟦ ##VARIABLE              ⟧) → SubstVar(#VARIABLE, GetSort(#env, #VARIABLE))
rule SubstSort(#env, csort⟦ [ ##csort1 ] ##csort2   ⟧) → csort⟦ [ ⟨csort: SubstSort(#env, #csort1)⟩ ] ⟨csort: SubstSort(#env, #csort2)⟩ ⟧
rule SubstSort(#env, csort⟦ ( ##csort1 ) ##csort2   ⟧) → csort⟦ ( ⟨csort: SubstSort(#env, #csort1)⟩ ) ⟨csort: SubstSort(#env, #csort2)⟩ ⟧
//rule SubstSort(#env, csort⟦ { ##cmapsort*}        ⟧) →
rule SubstSort(#env, csort⟦ thunk ##csort           ⟧) → csort⟦ thunk ⟨csort: SubstSort(#env, #csort)⟩ ⟧

func SubstMaybeSorts({String:EnvEntry}, List<Core_csorts_sort>) -> List<Core_csorts_sort>
rule SubstMaybeSorts(#env, csorts?⟦ ( ##csort* ) ⟧) → csorts?⟦ ( ⟨csort*: SubstSorts(#env, #csort*)⟩ ) ⟧
rule SubstMaybeSorts(#env, csorts?⟦              ⟧) → csorts?⟦⟧

// The insteresting bit is here. The rest is just boilerplate.
func SubstVar(String, Option<Core_csort_sort>) -> Core_csort_sort
rule SubstVar(#VARIABLE, NONE                        ) → csort⟦ ##VARIABLE ⟧  // generic variable
rule SubstVar(#VARIABLE, SOME(#csort:Core_csort_sort)) → #csort              // variable is replaced.


// --- Various utility functions

/* Check the given `#sortanno?` matches the given `#sort`. Output an error if not, otherwise apply `#result` */
func CheckSortAnnoE<a>(List<Core_csortanno_sort>, Core_csort_sort, ()->a) -> a
rule CheckSortAnnoE(csortanno?⟦           ⟧, #csort, #result) → #result()
rule CheckSortAnnoE(csortanno?⟦ : ##csort ⟧, #csort, #result) → #result()  // TODO: really check when Equal is fixed.
