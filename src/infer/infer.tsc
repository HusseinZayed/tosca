// Copyright (c) 2016 IBM Corporation.
/*
  Propagate missing sort annotations and sort arguments.

  Also perform opportunistic sort checking. The full complete sort checking is done by the target language

  The sort inference below is done in two passes:
  - The first pass propagates sorts bottom-up and unsorted terms are sorted (but still generic) using sort declarations.
    The sort environment is extended with sort unification and builtin sorts.
  - The second pass first starts by solving sort equations stored in the sort environment and sort variables are instantiated
    by traversing the term tree top-down.

 */
import std::core
import std::listdef
import std::pairdef
import std::mapdef
import std::string
import std::num
import std::language
import core::Core
import core::utils
import core::subst
import infer::env
import systemdef

// --- API

/* Infer sorts of given `#module` */
func InferM(#system: TSystem, #module: Module) -> Module
→ IfConfigDef(#system, "infer",
    (v) -> InferM2(#system, #module),
    ( ) -> #module)

func InferM2(TSystem, Module) -> Module
rule InferM2(#system,  Module(#url, #content, #compiled))
→ Debug(ConcatString("Type check ", #url), ()->Module(#url, InferContent(#system, #content), #compiled))

// -- Content

func InferContent(#system: TSystem, #content: Content) -> Content
→ FoldlP((key content) -> InferRules(key, UnSOME(GetRulesForKeyC(content, key)), content, #system),
           #content,
           MapKeys(GetRules(#content)))

// -- Rules

func InferRules(#key: String, #rules: List<Core_cdecl_sort>, #content: Content, #system: TSystem) -> Content
→ PutRulesC(#content, #key, Map((rl) -> InferRule(IEnvNew(#content, #system), rl), #rules))

// -- Rule

func InferRule({String:IEnvEntry}, Core_cdecl_sort) -> Core_cdecl_sort
rule InferRule(#env, cdecl⟦ ##canno* rule ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? → ##cterm ⟧)
→ let #funcSort = FindFuncSortS(IGetSystem(#env), #CONSTRUCTOR)
    Debug(ConcatString("Infer rule ", #CONSTRUCTOR), ()->InferRuleAux(#env, #funcSort, #CONSTRUCTOR, #cterms?, #cterm))

func InferRuleAux({String:IEnvEntry}, Option<Core_cdecl_sort>, String, List<Core_cterms_sort>, Core_cterm_sort) -> Core_cdecl_sort

  rule InferRuleAux(#env, SOME(cdecl⟦ ##canno* ##EXTERN? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧), #funcname, #cterms?, #contractum)
  → let #sorts = MaybeSortsToSorts(#csorts?)
    let #iterms? = InferMaybeTerms(IAddDummySorts(#env, #csortvars?), #CONSTRUCTOR, #cterms?, #sorts, (), ())
      InferPatternUp(#CONSTRUCTOR, #iterms?, #csort, #contractum)

  rule InferRuleAux(#env, NONE,  #funcname, cterms?⟦⟧, #contractum)
  → Error(ConcatString("Error: undeclared function named ", #funcname))

func InferPatternUp(String, PPair<{String:IEnvEntry} List<Core_cterms_sort>>, Core_csort_sort, Core_cterm_sort) -> Core_cdecl_sort
rule InferPatternUp(#CONSTRUCTOR, PairCons(#env, #cterms?), #esort, #contractum)
→ let #nenv = SetInPattern(IPushBinderSorts(#env), FALSE)
    InferRuleUp(cterm⟦ ##CONSTRUCTOR ##cterms? ⟧, Debug("Infer contractum", ()->InferTerm(#nenv, #contractum, #esort)))

func InferRuleUp(Core_cterm_sort, PPair<{String:IEnvEntry} Core_cterm_sort>) -> Core_cdecl_sort
rule InferRuleUp(#cterm1, PairCons(#env, #cterm2))
→ let #decl = ISubstRule(OptimizeSorts(#env), #cterm1, #cterm2)
  #decl
  //Debug(PrintTerm("", #decl), ()->#decl)

// ---- Synthesize sorts

// --- Terms

/* Synthesize term sort.
   @return a pair consisting of an updated environment and the sorted term (which might contain sort variables)
*/
func InferTerm({String:IEnvEntry}, Core_cterm_sort, Core_csort_sort /* expected sort */) -> PPair<{String:IEnvEntry} Core_cterm_sort>

  rule InferTerm(#env, cterm⟦ ##canno* ##csortqualifier* ##CONSTRUCTOR ##csortargs? ##cterms? ##csortanno? ⟧, #esort)
  → let #isdata = IsDataS(IGetSystem(#env), #CONSTRUCTOR)
      InferCons(#env, GetInPattern(#env), #isdata, #canno*, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #esort)

  rule InferTerm(#env, cterm⟦ ##STRING ⟧, #esort)
  → PairCons(UnifySort(#env, #esort, csort⟦ String ⟧), cterm⟦ ##STRING ⟧)

  rule InferTerm(#env, cterm⟦ ##NUMBER ⟧, #esort)
  → PairCons(UnifySort(#env, #esort, csort⟦ Numeric ⟧), cterm⟦ ##NUMBER ⟧)

  // Desugar matching higher-order function without specifying formal parameters
  rule InferTerm(#env, cterm⟦ ##canno*1 ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, csort⟦ ##canno*2 ( ##csort1 ) ##csort ⟧)
  → InferFormalUp([f] -> InferTerm(IAddFormalSort(#env, f, #csort1), cterm⟦ ##METAVAR ⟨cterms?: AppendTerm(cterm⟦ f ⟧, #cterms?)⟩ ##csubst? ##csortanno? ⟧, #csort), #csort1)

  rule InferTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧, #esort)
  → InferMeta(#env, GetInPattern(#env), #METAVAR, #cterms?, #csubst?, #csortanno?, #esort)

  rule InferTerm(#env, cterm⟦ ##canno* ##VARIABLE ##csortanno? ⟧, #esort)
  → InferVar(#env, GetInPattern(#env), #VARIABLE, IGetVarSort(#env, #VARIABLE), MaybeSortAnnoToSort(#csortanno?), #esort)

  rule InferTerm(#env, cterm⟦ ##canno*1 [ v ##csortanno? ] ##cterm[v] ⟧, csort⟦ ##canno*2 [ ##csort1 ] ##csort ⟧)
  → InferBinderUp([v] -> InferTerm(IAddBoundVarSort(#env, v, #csort1), #cterm[v], #csort), #csort1)

  rule InferTerm(#env, cterm⟦ ##canno* [ v ##csortanno? ] ##cterm[v] ⟧, #esort)
  → Error("Type error") // TODO:

  rule InferTerm(#env, cterm⟦ ##canno*1 ( f ##csortanno? ) ##cterm[f] ⟧, csort⟦ ##canno*2 ( ##csort1 ) ##csort ⟧)
  → InferFormalUp([f] -> InferTerm(IAddFormalSort(#env, f, #csort1), #cterm[f], #csort), #csort1)

  rule InferTerm(#env, cterm⟦ ##canno* ( f ##csortanno? ) ##cterm[f] ⟧, #esort)
  → Error("Type error") // TODO:

  rule InferTerm(#env, cterm⟦ ##canno*1 { ##cmapentries? } ⟧, csort⟦ ##canno*2 { ##cmapsort } ⟧)
  → InferMapUp(InferMap(#env, #cmapentries?, #cmapsort), #cmapsort)

  // Could be an alias...
  rule InferTerm(#env, cterm⟦ ##canno* { ##cmapentries? } ⟧, csort⟦ ##canno* ##CONSTRUCTOR ##csorts? ⟧)
  → InferMapAlias(#env, FindAliasS(IGetSystem(#env), #CONSTRUCTOR), cterm⟦ { ##cmapentries? } ⟧, csort⟦ ##canno* ##CONSTRUCTOR ##csorts? ⟧)

  rule InferTerm(#env, cterm⟦ ##canno* thunk ##cterm ⟧, csort⟦ ##canno* thunk ##csort ⟧)
  → UnPair(InferTerm(#env, #cterm, #csort), (env term)->PairCons(env, cterm⟦ thunk ⟨cterm: term⟩ ⟧))

  // TODO: check name is unique
  rule InferTerm(#env, cterm⟦ ##canno* ##METAVAR ##csortanno? = ##cterm ⟧, #esort)
  → InferNamedUp(#METAVAR, #esort, InferTerm(AddIMetaVar(#env, #METAVAR, #esort), #cterm, #esort))

  rule InferTerm(#env, cterm⟦ ##canno* let ##METAVAR ##csortanno? = ##cterm ##cterm2 ⟧, #esort)
  → let #varsort = csort⟦ ⟨VARIABLE: INewSortVar(#env)⟩ ⟧
    InferLet(#METAVAR, #varsort, InferTerm(IIncCounter(#env), #cterm, #varsort), #cterm2, #esort)

/* Traverse terms */
func InferMaybeTerms({String:IEnvEntry}, String, List<Core_cterms_sort>, List<Core_csort_sort>, List<Core_canno_sort>, List<List<Core_cdefaultvalue_sort>>) -> PPair<{String:IEnvEntry} List<Core_cterms_sort>>

  rule InferMaybeTerms(#env, #constructor, cterms?⟦              ⟧, #esort*, #canno*, #dvs)
  → UnPair(InferAnnos(IPushBinderSorts(IResetMetaCounter(#env)), #constructor, #esort*, #canno*, #dvs), (env terms)->
            PairCons(IPopBinderSorts(env), If(IsEmpty(terms), ()->cterms?⟦⟧, ()->cterms?⟦ ( ⟨cterm*: terms⟩ ) ⟧)))

  rule InferMaybeTerms(#env, #constructor, cterms?⟦ (          ) ⟧, #esort*, #canno*, #dvs)
  → UnPair(InferAnnos(IPushBinderSorts(IResetMetaCounter(#env)), #constructor, #esort*, #canno*, #dvs), (env terms)->
           PairCons(IPopBinderSorts(env), cterms?⟦ ( ⟨cterm*: terms⟩ ) ⟧))

  rule InferMaybeTerms(#env, #constructor, cterms?⟦ ( ##cterm* ) ⟧, #esort*, #canno*, #dvs)
  → UnPair(InferTerms(IPushBinderSorts(IResetMetaCounter(#env)), #constructor, #cterm*, #esort*, #canno*, #dvs), (env terms)->
           PairCons(IPopBinderSorts(env), cterms?⟦ ( ⟨cterm*: terms⟩ ) ⟧))

/* Traverse subst */
func InferMaybeSubst({String:IEnvEntry}, String, List<Core_csubst_sort>, List<Core_csort_sort>) -> PPair<{String:IEnvEntry} List<Core_csubst_sort>>
rule InferMaybeSubst(#env, #constructor, csubst?⟦              ⟧, csort*⟦⟧) → PairCons(#env, csubst?⟦⟧)
rule InferMaybeSubst(#env, #constructor, csubst?⟦ [ ##cterm* ] ⟧, #esort*)  → UnPair(InferTerms(IPushBinderSorts(#env), #constructor, #cterm*, #esort*, (), ()), (env terms)->PairCons(IPopBinderSorts(env), csubst?⟦ [ ⟨cterm*: terms⟩ ] ⟧))
rule InferMaybeSubst(#env, #constructor, csubst?⟦              ⟧, #csort*)  → Error(ConcatString("Error: missing substitution argument in ", #constructor))

/* Traverse terms */
func InferTerms({String:IEnvEntry}, String, List<Core_cterm_sort>, List<Core_csort_sort>, List<Core_canno_sort>, List<List<Core_cdefaultvalue_sort>>) -> PPair<{String:IEnvEntry} List<Core_cterm_sort>>

  rule InferTerms(#env, #constructor, cterm*⟦ ##cterm ##cterm* ⟧, csort*⟦ ##csort ##csort* ⟧, #canno*, #dvs)
  → InferTermsUp(InferTerm(#env, #cterm, RemoveSortAnnotation("Variadic", #csort)), #constructor, #cterm*, #csort, #csort*, #canno*, TailNE(#dvs))

  rule InferTerms(#env, #constructor, cterm*⟦⟧, csort*⟦⟧, #canno*, ())
  → PairCons(#env, cterm*⟦⟧) // TODO: check no runtime annotations

  rule InferTerms(#env, #constructor, cterm*⟦⟧, csort*⟦ ##csort ##csort* ⟧, #canno*, #dvs)
  → let #sortAnno = GetSortAnnotations(#csort)
    let #isVariadic = HasAnnotation("Variadic", #sortAnno)
    if #isVariadic
       PairCons(#env, cterm*⟦⟧) // TODO: check no annotations, no default values
    else
      InferAnnos(#env, #constructor, csort*⟦ ##csort ##csort* ⟧, #canno*, #dvs)

  rule InferTerms(#env, #constructor, cterm*⟦ ##cterm ##cterm* ⟧, csort*⟦⟧, #canno*, #dvs)
  → Error(ConcatString("Error: extra argument(s) in ", #constructor))

/* Reconstruct terms */
func InferTermsUp(PPair<{String:IEnvEntry} Core_cterm_sort>, String, List<Core_cterm_sort>, Core_csort_sort, List<Core_csort_sort>, List<Core_canno_sort>, List<List<Core_cdefaultvalue_sort>>) -> PPair<{String:IEnvEntry} List<Core_cterm_sort>>

  // TODO: should check that when the last sort is variadic, no annotation are allowed.
  rule InferTermsUp(PairCons(#env, #cterm), #constructor, #cterm*, #csort, csort*⟦⟧, #canno*, #dvs)
  → let #sortAnno = GetSortAnnotations(#csort)
    let #isVariadic = HasAnnotation("Variadic", #sortAnno)
    UnPair(InferTerms(IResetBinderSorts(#env), #constructor, #cterm*, If(#isVariadic, ()->csort*⟦ ##csort ⟧, ()->csort*⟦⟧), #canno*, #dvs), (env cterms) ->
    PairCons(env, cterm*⟦ ##cterm ⟨cterm*: cterms⟩⟧))

  rule InferTermsUp(PairCons(#env, #cterm), #constructor, #cterm*, #previousSort, #csort*, #canno*, #dvs)
  → UnPair(InferTerms(IResetBinderSorts(#env), #constructor, #cterm*, #csort*, #canno*, #dvs), (env cterms) ->
    PairCons(env, cterm*⟦ ##cterm ⟨cterm*: cterms⟩⟧))

//
func InferMapAlias({String:IEnvEntry}, Option<Core_cdecl_sort>, Core_cterm_sort, Core_csort_sort) -> PPair<{String:IEnvEntry} Core_cterm_sort>

  rule InferMapAlias(#env, SOME(cdecl⟦ ##canno* alias ##CONSTRUCTOR ##csort ⟧), #cterm, #csort2)
  → InferTerm(#env, #cterm, #csort) // TODO: should keep the original sort.

  rule InferMapAlias(#env, NONE, #cterm, #csort)
  → Error(ConcatString( "Type error: map does not match type ", PrintTerm("", #csort)))

/* Process annotations
   For each missing argument, look for an annotation matching the sort name. Only works for non-polymorphic sort name.
   If found -> consume the annotation term, and proceeed.
   Otherwise -> look for a default value. If no default value found, error.
*/
func InferAnnos({String:IEnvEntry}, String, List<Core_csort_sort>, List<Core_canno_sort>, List<List<Core_cdefaultvalue_sort>>) -> PPair<{String:IEnvEntry} List<Core_cterm_sort>>

  rule InferAnnos(#env, #constructor, csort*⟦ ##CONSTRUCTOR ##csort* ⟧, #canno*, #dvs)
  → InferAnnos2(#env, GetAnnotation(#CONSTRUCTOR, #canno*), #constructor, csort*⟦ ##CONSTRUCTOR ##csort* ⟧, #CONSTRUCTOR, #canno*, #dvs)

  // Sort cannot match an annotation.
  rule InferAnnos(#env, #constructor, #csort*, #canno*, #dvs)
  → InferDefaultValues(#env, #constructor, #csort*, #canno*, #dvs)

func InferAnnos2({String:IEnvEntry}, Option<Core_canno_sort>, String, List<Core_csort_sort>, String, List<Core_canno_sort>, List<List<Core_cdefaultvalue_sort>>) -> PPair<{String:IEnvEntry} List<Core_cterm_sort>>

  // There is no annotation matching the first sort. Try default value.
  rule InferAnnos2(#env, NONE, #constructor, #csort*, #anno, #canno*, #dvs)
  → InferDefaultValues(#env, #constructor, #csort*, #canno*, #dvs)

  // Meta annotation. Cool, use it
  rule InferAnnos2(#env, SOME(canno⟦ @ ##METAVAR ⟧), #constructor, csort*⟦ ##csort ##csort* ⟧, #anno, #canno*, #dvs)
  → InferTermsUp(InferTerm(#env, cterm⟦ ##METAVAR ⟧, #csort), #constructor, cterm*⟦⟧, #csort, #csort*, RemoveAnnotation(#anno, #canno*), TailNE(#dvs))

  // Regular annotation. Cool, use it too!
  rule InferAnnos2(#env, SOME(canno⟦ @ ##CONSTRUCTOR ( ##cterm ) ⟧), #constructor, csort*⟦ ##csort ##csort* ⟧, #anno, #canno*, #dvs)
  → InferTermsUp(InferTerm(#env, #cterm, #csort), #constructor, cterm*⟦⟧, #csort, #csort*, RemoveAnnotation(#anno, #canno*), TailNE(#dvs))

  // Regular annotation but with wrong parameter. Error
  rule InferAnnos2(#env, SOME(#canno), #constructor, #csort*, #anno, #canno*, #dvs)
  → Error(ConcatString("Invalid annotation: ", PrintTerm("", #canno)))

/* Process default value */
func InferDefaultValues({String:IEnvEntry}, String, List<Core_csort_sort>, List<Core_canno_sort>, List<List<Core_cdefaultvalue_sort>>) -> PPair<{String:IEnvEntry} List<Core_cterm_sort>>

  // There is a default value provided for the missing argument
  // If in pattern, currently match all.
  rule InferDefaultValues(#env, #constructor, csort*⟦ ##csort ##csort* ⟧, #canno*, ((cdefaultvalue⟦ = ##cterm ⟧,), #dvs...))
  → if GetInPattern(#env)
      InferDefaultValuesPattern(#env, #constructor, #csort, #csort*, #canno*, #dvs)
    else
      InferTermsUp(InferTerm(#env, #cterm, #csort), #constructor, cterm*⟦⟧, #csort, #csort*, #canno*, #dvs)

  rule InferDefaultValues(#env, #constructor, csort*⟦                  ⟧, #canno*, ())
  → PairCons(#env, cterm*⟦⟧)

  rule InferDefaultValues(#env, #constructor, csort*⟦ ##csort ##csort* ⟧, #canno*, #dvs)
  → Error(ConcatString("Error: missing argument(s) in ", #constructor))

func InferDefaultValuesPattern(#env: {String:IEnvEntry}, #constructor: String, #csort: Core_csort_sort, #csort*: List<Core_csort_sort>,
                               #canno*:List<Core_canno_sort>, #dvs: List<List<Core_cdefaultvalue_sort>>) -> PPair<{String:IEnvEntry} List<Core_cterm_sort>>
→ let #METAVAR = ConcatString("#$", FormatInteger(IGetMetaCounter(#env)))
    InferTermsUp(InferTerm(IIncMetaCounter(#env), cterm⟦ ##METAVAR ⟧, #csort), #constructor, cterm*⟦⟧, #csort, #csort*, #canno*, #dvs)

// --- Synthesize construction sort

func InferCons({String:IEnvEntry}, Bool, Bool, List<Core_canno_sort>, String, List<Core_csortargs_sort>, List<Core_cterms_sort>, List<Core_csortanno_sort>, Core_csort_sort) -> PPair<{String:IEnvEntry} Core_cterm_sort>

  // Data construction: search for the data sort declaration defining `#CONSTRUCTOR`
  rule InferCons(#env, #inpattern, TRUE, #canno*, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #esort)
  → let #form = FindFormS(IGetSystem(#env), #esort, #CONSTRUCTOR)
      InferData(#env, #canno*, #CONSTRUCTOR, #csortargs?, #cterms?, #form, #esort)

  rule InferCons(#env, FALSE, FALSE, #canno*, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #esort)
  → InferFunc(#env, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, SOME(#esort))

  rule InferCons(#env, TRUE, FALSE, #canno*, #CONSTRUCTOR, #csortargs?, #cterms?, #csortanno?, #esort)
  → Error(ConcatString("Error: function symbol cannot occur in pattern: ", #CONSTRUCTOR))

/* Synthesize function  */
func InferFunc(#env: {String:IEnvEntry}, #CONSTRUCTOR: String, #csortargs?: List<Core_csortargs_sort>, #cterms?: List<Core_cterms_sort>,
                  #csortanno?: List<Core_csortanno_sort>, #esort: Option<Core_csort_sort>) -> PPair<{String:IEnvEntry} Core_cterm_sort>
→ InferFuncAux(#env, FindFuncSortS(IGetSystem(#env), #CONSTRUCTOR), #csortargs?, #cterms?, #CONSTRUCTOR, #esort)

func InferFuncAux({String:IEnvEntry}, Option<Core_cdecl_sort>, List<Core_csortargs_sort>, List<Core_cterms_sort>, String, Option<Core_csort_sort>) -> PPair<{String:IEnvEntry} Core_cterm_sort>

  rule InferFuncAux(#env, SOME(cdecl⟦ ##canno* ##EXTERN? func ##csortvars? ##csort ##CONSTRUCTOR ##csorts? ⟧), #csortargs?, #cterms?, #funcname, #esort)
  → InferSubs(#env, #canno*, #CONSTRUCTOR, FALSE, #csortvars?, #csortargs?, #cterms?, MaybeSortsToSorts(#csorts?), (), #csort, #esort)

  rule InferFuncAux(#env, NONE, #csortargs?, cterms?⟦⟧, #funcname, #esort)
  → Error(ConcatString("Error: undeclared function named ", #funcname))

/* Synthesize data: if no data decl found, raise an error. Otherwise compute sort from declaration and move on */
func InferData({String:IEnvEntry}, List<Core_canno_sort>, String, List<Core_csortargs_sort>, List<Core_cterms_sort>, Option<PPair<Core_cdecl_sort Core_cform_sort>>, Core_csort_sort) -> PPair<{String:IEnvEntry} Core_cterm_sort>

  rule InferData(#env, #canno*, #formname, #csortargs?, #cterms?, SOME(PairCons(#cdecl, cform⟦ ##CONSTRUCTOR ##csortsdefault? ⟧)), #esort)
  → let #defaultSorts = MaybeSortsDefaultToSorts(#csortsdefault?)
      InferSubs(#env, #canno*, #CONSTRUCTOR, TRUE, GetMaybeSortVars(#cdecl), #csortargs?, #cterms?, #defaultSorts, MaybeSortsDefaultToDefault(#csortsdefault?), DeclToSort(#cdecl), SOME(#esort))

  rule InferData(#env, #canno*, #formname, #csortargs?, #cterms?, NONE, #esort)
  → Error(ConcatString("Error: undefined enumeration value ", ConcatString(#formname, ConcatString(" in type ", PrintSort(#esort)))))

/* Synthesize construction sub terms */
func InferSubs(#env: {String:IEnvEntry}, #canno*: List<Core_canno_sort>, #CONSTRUCTOR: String, #data: Bool,
               #csortvars?: List<Core_csortvars_sort>, #csortargs?: List<Core_csortargs_sort>,
               #cterms?: List<Core_cterms_sort>, #dsort*: List<Core_csort_sort> /* in decl domain */, #default: List<List<Core_cdefaultvalue_sort>>,
               #edsort: Core_csort_sort /* in decl domain */, #esort: Option<Core_csort_sort>) -> PPair<{String:IEnvEntry} Core_cterm_sort>
→ InferSubsAux(InferSortArgs(#env, #csortvars?, #csortargs?), #canno*, #CONSTRUCTOR, #data, #cterms?, #dsort*, #default, #edsort, #esort)

func InferSubsAux(#env: {String:IEnvEntry}, #canno*: List<Core_canno_sort>, #CONSTRUCTOR: String, #data: Bool,
                  #cterms?: List<Core_cterms_sort>, #dsort*: List<Core_csort_sort> /* in decl domain */, #default: List<List<Core_cdefaultvalue_sort>>,
                  #edsort: Core_csort_sort, #esort: Option<Core_csort_sort>) -> PPair<{String:IEnvEntry} Core_cterm_sort>
→ let #sortArgsMap = GetSortArgsMap(#env)
  let #edsort = SubstSort(#edsort, #sortArgsMap)
    InferConsUp(#CONSTRUCTOR, #data, GetSortArgs(#env),
                InferMaybeTerms(UnifySort(#env, #edsort, UnSOME(#esort)),
                                 #CONSTRUCTOR, #cterms?, SubstSortSorts(#dsort*, #sortArgsMap), #canno*, #default), #edsort)

/* Reconstruct construction. Add @Data annotation if constructor is a data symbol */
func InferConsUp(String, Bool, List<Core_csortargs_sort>, PPair<{String:IEnvEntry} List<Core_cterms_sort>>, Core_csort_sort) -> PPair<{String:IEnvEntry} Core_cterm_sort>

  rule InferConsUp(#CONSTRUCTOR, TRUE, #csortargs?, PairCons(#env, #cterms?), #csort)
  → PairCons(#env, cterm⟦ @Data ##csort :: ##CONSTRUCTOR ##csortargs? ##cterms? : ##csort ⟧)

  rule InferConsUp(#CONSTRUCTOR, FALSE, #csortargs?, PairCons(#env, #cterms?), #csort)
  → PairCons(#env, cterm⟦ ##csort :: ##CONSTRUCTOR ##csortargs? ##cterms? : ##csort ⟧)

/* Reconstruct binder */
// Note: #env is weak.
func InferBinderUp([String] -> PPair<{String:IEnvEntry} Core_cterm_sort>, Core_csort_sort) -> PPair<{String:IEnvEntry} Core_cterm_sort>
rule InferBinderUp([b] -> PairCons(#env, #cterm[b]), #csort) → PairCons(#env, cterm⟦ [ b : ##csort ] ##cterm[b] ⟧)

/* Reconstruct formal parameter */
// Note: #env is weak.
func InferFormalUp([String] -> PPair<{String:IEnvEntry} Core_cterm_sort>, Core_csort_sort) -> PPair<{String:IEnvEntry} Core_cterm_sort>
rule InferFormalUp([f] -> PairCons(#env, #cterm[f]), #csort) → PairCons(#env, cterm⟦ ( f : ##csort ) ##cterm[f] ⟧)

// --- Synthesize variable

// TODO: simplify

func InferVar({String:IEnvEntry}, Bool, String, Option<Core_csort_sort> /* Previously declared sort */,
               Option<Core_csort_sort>/* Current sort */, Core_csort_sort /* Expected sort */) -> PPair<{String:IEnvEntry} Core_cterm_sort>
rule InferVar(#env, TRUE , #VARIABLE, #sort      , #vsort, #csort) → PairCons(IAddVar(#env, #VARIABLE, #csort), cterm⟦ ##VARIABLE : ##csort ⟧)
rule InferVar(#env, FALSE, #VARIABLE, SOME(#sort), #vsort, #csort) → PairCons(UnifySort(#env, #sort, #csort), cterm⟦ ##VARIABLE : ##csort ⟧) // Free variable
rule InferVar(#env, FALSE, #VARIABLE, NONE       , #vsort, #csort) → InferVarBound(#env, #VARIABLE, IGetBoundVarSort(#env, #VARIABLE), #vsort, #csort)

func InferVarBound({String:IEnvEntry}, String, Option<Core_csort_sort>, Option<Core_csort_sort>, Core_csort_sort) -> PPair<{String:IEnvEntry} Core_cterm_sort>
rule InferVarBound(#env, #VARIABLE, SOME(#sort), #vsort, #csort) → PairCons(UnifySort(#env, #sort, #csort), cterm⟦ ##VARIABLE : ##csort ⟧)
rule InferVarBound(#env, #VARIABLE, NONE       , #vsort, #csort) → InferVarFormal(#env, #VARIABLE, IGetFormalSort(#env, #VARIABLE), #vsort, #csort)

func InferVarFormal({String:IEnvEntry}, String, Option<Core_csort_sort>, Option<Core_csort_sort>, Core_csort_sort) -> PPair<{String:IEnvEntry} Core_cterm_sort>
rule InferVarFormal(#env, #VARIABLE, SOME(#sort), #vsort      , #csort) → PairCons(UnifySort(#env, #sort, #csort), cterm⟦ ##VARIABLE : ##csort ⟧)
rule InferVarFormal(#env, #VARIABLE, NONE       , SOME(#vsort), #csort) → PairCons(IAddVar(UnifySort(#env, #vsort, #csort), #VARIABLE, #csort), cterm⟦ ##VARIABLE : ##csort ⟧) // Fresh variable, with sort.
rule InferVarFormal(#env, #VARIABLE, NONE       , NONE        , #csort) → PairCons(IAddVar(#env, #VARIABLE, #csort), cterm⟦ ##VARIABLE : ##csort ⟧) // Fresh variable, without sort. Rely on sort inference.

// --- Synthesize meta

func InferMeta({String:IEnvEntry}, Bool /* Declaration? */, String, List<Core_cterms_sort>, List<Core_csubst_sort>, List<Core_csortanno_sort>, Core_csort_sort) -> PPair<{String:IEnvEntry} Core_cterm_sort>

  // Declaration (for now only in pattern). No need to infer sorts in `#cterms?`.
  rule InferMeta(#env, TRUE, #METAVAR, #cterms?, #csubst?, #csortanno?, #esort)
  → InferMetaDecl(#env, #METAVAR, #cterms?, #csubst?, IGetDirectFormalSorts(#env), IGetDirectBoundVarSorts(#env), #esort)

  // Use: retrieve meta-variable/application sort and synthesize arguments. Ignore sort annotation (maybe error if specified?).
  rule InferMeta(#env, FALSE, #METAVAR, #cterms?, #csubst?, #csortanno?, #esort)
  → InferMetaUse(#env, #METAVAR, #cterms?, #csubst?, GetIMetaVar(#env, #METAVAR), #esort)

// Reconstruct meta variable/application declaration
// apply arguments are optional: get sorts from signature.
// TODO: check metavar name is unique. A bit tricky due to map pattern matching.
func InferMetaDecl(#env: {String:IEnvEntry}, #METAVAR: String, #cterms?: List<Core_cterms_sort>, #csubst?: List<Core_csubst_sort>, #fsorts: List<Core_csort_sort>, #bsorts: List<Core_csort_sort>, #csort: Core_csort_sort) -> PPair<{String:IEnvEntry} Core_cterm_sort>
→ let #binderSorts = IFindBinderSorts(#env, MaybeSubstToTerms(#csubst?), FALSE)
    PairCons(AddIMetaVar(IAddMetaArgs(#env, #METAVAR, PairCons(#fsorts, #binderSorts)), #METAVAR, #csort), cterm⟦ ##METAVAR ##cterms? ##csubst? : ##csort ⟧)

func InferMetaUse({String:IEnvEntry}, String, List<Core_cterms_sort>, List<Core_csubst_sort>, Option<Core_csort_sort>, Core_csort_sort) -> PPair<{String:IEnvEntry} Core_cterm_sort>

    rule InferMetaUse(#env, #METAVAR, #cterms?, #csubst?, SOME(#dsort), #esort)
    → let #formalArgs = IGetMetaFormalArgs(#env, #METAVAR)
        InferMetaUse1(#METAVAR, InferMaybeTerms(#env, #METAVAR, #cterms?, #formalArgs, (), ()), #csubst?, #dsort, #esort)

    rule InferMetaUse(#env, #METAVAR, #cterms?, #csubst?, NONE, #esort)
    → Error(ConcatString("Error: undefined meta-variable ", #METAVAR))

func InferMetaUse1(String, PPair<{String:IEnvEntry} List<Core_cterms_sort>>, List<Core_csubst_sort>, Core_csort_sort, Core_csort_sort) -> PPair<{String:IEnvEntry} Core_cterm_sort>
rule InferMetaUse1(#METAVAR, PairCons(#env, #cterms?), #csubst?, #dsort, #esort)
→ let #boundArgs = IGetMetaBoundArgs(#env, #METAVAR)
    InferMetaUse2(#METAVAR, #cterms?, InferMaybeSubst(#env, #METAVAR, #csubst?, #boundArgs), #dsort, #esort)

func InferMetaUse2(String, List<Core_cterms_sort>, PPair<{String:IEnvEntry} List<Core_csubst_sort>>, Core_csort_sort, Core_csort_sort) -> PPair<{String:IEnvEntry} Core_cterm_sort>
rule InferMetaUse2(#METAVAR, #cterms?, PairCons(#env, #csubst?), #dsort, #esort)
→ InferMetaUse3(#env, #METAVAR, #cterms?, #csubst?, #dsort, #esort)

func InferMetaUse3({String:IEnvEntry}, String, List<Core_cterms_sort>, List<Core_csubst_sort>, Core_csort_sort, Core_csort_sort) -> PPair<{String:IEnvEntry} Core_cterm_sort>
rule InferMetaUse3(#env, #METAVAR, #cterms?, #csubst?, #dsort, #csort)
→ PairCons(UnifySort(#env, #dsort, #csort), cterm⟦ ##METAVAR ##cterms? ##csubst? : ##csort ⟧)

// --- Synthesize map


func InferMap({String:IEnvEntry}, List<Core_cmapentries_sort>, Core_cmapsort_sort) -> PPair<{String:IEnvEntry} List<Core_cmapentries_sort>>
rule InferMap(#env, cmapentries?⟦              ⟧, #esort) → PairCons(#env, cmapentries?⟦⟧)
rule InferMap(#env, cmapentries?⟦ ##cmapentry* ⟧, #esort) → InferMapEntriesUp(InferMapEntries(#env, #cmapentry*, #esort))

func InferMapEntries({String:IEnvEntry}, List<Core_cmapentry_sort>, Core_cmapsort_sort) -> PPair<{String:IEnvEntry} List<Core_cmapentry_sort>>
rule InferMapEntries(#env, cmapentry*⟦ ##cmapentry ##cmapentry* ⟧, #esort) → InferMapEntriesNext(InferMapEntry(#env, #cmapentry, GetInPattern(#env), #esort), #cmapentry*, #esort)
rule InferMapEntries(#env, cmapentry*⟦                          ⟧, #esort) → PairCons(#env, cmapentry*⟦⟧)

func InferMapEntriesNext(PPair<{String:IEnvEntry} Core_cmapentry_sort>, List<Core_cmapentry_sort>, Core_cmapsort_sort) -> PPair<{String:IEnvEntry} List<Core_cmapentry_sort>>
rule InferMapEntriesNext(PairCons(#env, #cmapentry), #cmapentry*, #esort) → InferMapEntriesNextUp(#cmapentry, InferMapEntries(#env, #cmapentry*, #esort))

func InferMapEntry({String:IEnvEntry}, Core_cmapentry_sort, Bool, Core_cmapsort_sort) -> PPair<{String:IEnvEntry} Core_cmapentry_sort>
rule InferMapEntry(#env, cmapentry⟦ : ##METAVAR          ⟧, TRUE , #cmapsort) → PairCons(AddIMetaVarE(#env, #METAVAR, csort⟦ { ##cmapsort } ⟧), cmapentry⟦ : ##METAVAR ⟧)
rule InferMapEntry(#env, cmapentry⟦ : ##METAVAR          ⟧, FALSE, #esort) → let #metaSort = GetIMetaVarE(#env, #METAVAR) InferMapMetaUse(#env, #METAVAR, #metaSort, #esort)
rule InferMapEntry(#env, cmapentry⟦ ¬ ##METAVAR          ⟧, TRUE , #esort) → let #metaSort = GetIMetaVar(#env, #METAVAR) InferMapNoMeta(#env, #METAVAR, #metaSort, #esort)
rule InferMapEntry(#env, cmapentry⟦ ##METAVAR : ##cterm  ⟧, #inpa, #esort) → InferMapKV(#METAVAR, GetIMetaVar(#env, #METAVAR), InferTerm(#env, #cterm, GetMapValueSort(#esort)), #esort)
rule InferMapEntry(#env, cmapentry⟦ ##VARIABLE           ⟧, TRUE , #esort) → InferMapVar(#env, #VARIABLE, IFindVarSort(#env, #VARIABLE), cmapentry⟦ ##VARIABLE ⟧)
rule InferMapEntry(#env, cmapentry⟦ ¬ ##VARIABLE         ⟧, TRUE , #esort) → InferMapVar(#env, #VARIABLE, IFindVarSort(#env, #VARIABLE), cmapentry⟦ ¬ ##VARIABLE ⟧)
rule InferMapEntry(#env, cmapentry⟦ ##VARIABLE : ##cterm ⟧, #inpa, #esort) → InferMapVV(#VARIABLE, IFindVarSort(#env, #VARIABLE), InferTerm(#env, #cterm, GetMapValueSort(#esort)), #esort)
rule InferMapEntry(#env, cmapentry⟦ ##STRING             ⟧, TRUE , #esort) → PairCons(UnifySort(#env, csort⟦ String ⟧, GetMapKeySort(#esort)), cmapentry⟦ ##STRING ⟧)
rule InferMapEntry(#env, cmapentry⟦ ¬ ##STRING           ⟧, TRUE , #esort) → PairCons(UnifySort(#env, csort⟦ String ⟧, GetMapKeySort(#esort)), cmapentry⟦ ¬ ##STRING ⟧)
rule InferMapEntry(#env, cmapentry⟦ ##STRING : ##cterm   ⟧, #inpa, #esort) → InferMapSV(#STRING, InferTerm(#env, #cterm, GetMapValueSort(#esort)))
rule InferMapEntry(#env, #cmapentry                      , #inpa, #esort) → Error("Assertion Error")

func InferMapNoMeta({String:IEnvEntry}, String, Option<Core_csort_sort>, Core_cmapsort_sort) -> PPair<{String:IEnvEntry} Core_cmapentry_sort>

    // Case 1: the meta variable has not been declared yet
    rule InferMapNoMeta(#env, #METAVAR, NONE, #esort) → PairCons(AddIMetaVar(#env, #METAVAR, GetMapKeySort(#esort)), cmapentry⟦ ¬ ##METAVAR ⟧)

    // Case 2: the meta variable has been declared. Unify!
    rule InferMapNoMeta(#env, #METAVAR, SOME(#dsort), #esort) → PairCons(UnifySort(#env, #dsort, GetMapKeySort(#esort)), cmapentry⟦ ¬ ##METAVAR ⟧)

func InferMapKV(String, Option<Core_csort_sort>, PPair<{String:IEnvEntry} Core_cterm_sort>, Core_cmapsort_sort) -> PPair<{String:IEnvEntry} Core_cmapentry_sort>

    // Case 1: the meta variable has not been declared yet
    rule InferMapKV(#METAVAR, NONE, PairCons(#env, #cterm), #esort)
    → PairCons(AddIMetaVar(#env, #METAVAR, GetMapKeySort(#esort)), cmapentry⟦ ##METAVAR : ##cterm ⟧)

    // Case 2: the meta variable has been declared. Unify!
    rule InferMapKV(#METAVAR, SOME(#dsort), PairCons(#env, #cterm), #esort)
    → PairCons(UnifySort(#env, #dsort, GetMapKeySort(#esort)), cmapentry⟦ ##METAVAR : ##cterm ⟧)

func InferMapVV(String, Option<Core_csort_sort>, PPair<{String:IEnvEntry} Core_cterm_sort>, Core_cmapsort_sort) -> PPair<{String:IEnvEntry} Core_cmapentry_sort>

    // Case 1: the variable key has not been declared yet. It's a free variable
    rule InferMapVV(#VARIABLE, NONE, PairCons(#env, #cterm), #cmapsort)
    → PairCons(IAddVarE(#env, #VARIABLE, csort⟦ String ⟧), cmapentry⟦ ##VARIABLE : ##cterm ⟧)

    // Case 2: the variable key has been declared. Unify!
    rule InferMapVV(#VARIABLE, SOME(#dsort), PairCons(#env, #cterm), #cmapsort)
    → PairCons(UnifySort(#env, #dsort, csort⟦ String ⟧), cmapentry⟦ ##VARIABLE : ##cterm ⟧)

func InferMapVar({String:IEnvEntry}, String, Option<Core_csort_sort>, Core_cmapentry_sort) -> PPair<{String:IEnvEntry} Core_cmapentry_sort>

  // Case 1: the variable has not been declared yet. This is a free variable.
  // TODO: proper variable sort
  rule InferMapVar(#env, #VARIABLE, NONE, #cmapentry) → PairCons(IAddVarE(#env, #VARIABLE, csort⟦ String ⟧), #cmapentry)

  // Case 2: the variable is declared. Unify!
  rule InferMapVar(#env, #VARIABLE, SOME(#dsort), #cmapentry) → PairCons(UnifySort(#env, #dsort, csort⟦ String ⟧), #cmapentry)

func InferMapSV(String, PPair<{String:IEnvEntry} Core_cterm_sort>) -> PPair<{String:IEnvEntry} Core_cmapentry_sort>
rule InferMapSV(#STRING, PairCons(#env, #cterm)) → PairCons(#env, cmapentry⟦ ##STRING : ##cterm ⟧)

func InferMapMetaUse(#env: {String:IEnvEntry}, #METAVAR: String, #dsort: Core_csort_sort, #cmapsort: Core_cmapsort_sort) -> PPair<{String:IEnvEntry} Core_cmapentry_sort>
→ PairCons(UnifySort(#env, csort⟦ { ##cmapsort } ⟧, #dsort), cmapentry⟦ : ##METAVAR ⟧)

func InferMapEntriesNextUp(Core_cmapentry_sort, PPair<{String:IEnvEntry} List<Core_cmapentry_sort>>) -> PPair<{String:IEnvEntry} List<Core_cmapentry_sort>>
rule InferMapEntriesNextUp(#cmapentry, PairCons(#env, #cmapentry*)) → PairCons(#env, cmapentry*⟦ ##cmapentry ##cmapentry* ⟧ )

func InferMapEntriesUp(PPair<{String:IEnvEntry} List<Core_cmapentry_sort>>) -> PPair<{String:IEnvEntry} List<Core_cmapentries_sort>>
rule InferMapEntriesUp(PairCons(#env, #cmapentry*)) → PairCons(#env, cmapentries?⟦ ##cmapentry* ⟧)

func InferMapUp(PPair<{String:IEnvEntry} List<Core_cmapentries_sort>>, Core_cmapsort_sort) -> PPair<{String:IEnvEntry} Core_cterm_sort>
rule InferMapUp(PairCons(#env, #cmapentries?), #cmapsort) → PairCons(#env, cterm⟦ { ##cmapentries? } : { ##cmapsort } ⟧)

//--- Synthesize named term

func InferNamedUp(String, Core_csort_sort, PPair<{String:IEnvEntry} Core_cterm_sort>) -> PPair<{String:IEnvEntry} Core_cterm_sort>
rule InferNamedUp(#METAVAR, #csort, PairCons(#env, #cterm)) → PairCons(#env, cterm⟦ ##METAVAR : ##csort = ##cterm ⟧)

//--- Synthesize let expression

func InferLet(String, Core_csort_sort, PPair<{String:IEnvEntry} Core_cterm_sort>, Core_cterm_sort, Core_csort_sort) -> PPair<{String:IEnvEntry} Core_cterm_sort>
rule InferLet(#METAVAR, #csort, PairCons(#env, #cterm), #cterm2, #esort)
→ let #shadowed = GetIMetaVar(#env, #METAVAR)
  InferLetUp(#METAVAR, #csort, #cterm, InferTerm(AddIMetaVar(#env, #METAVAR, #csort), #cterm2, #esort), #shadowed)

func InferLetUp(String, Core_csort_sort, Core_cterm_sort, PPair<{String:IEnvEntry} Core_cterm_sort>, Option<Core_csort_sort>) -> PPair<{String:IEnvEntry} Core_cterm_sort>
rule InferLetUp(#METAVAR, #csort, #cterm, PairCons(#env, #cterm2), #shadowed)
→ PairCons(AddIMetaVarO(IRemoveMetaVar(#env, #METAVAR), #METAVAR, #shadowed), cterm⟦ let ##METAVAR : ##csort = ##cterm ##cterm2 ⟧)

/* Synthesize sort variables.

   Works as follows:
   - a mapping between sort parameters and sort arguments kept in the environment (see XXSortArgs functions).
   - a sort variable is created for each missing sort argument. (since it's missing, it's actually  never referenced.)
 */
func InferSortArgs({String:IEnvEntry}, List<Core_csortvars_sort>, List<Core_csortargs_sort>) -> {String:IEnvEntry}
rule InferSortArgs(#env, csortvars?⟦                 ⟧, csortargs?⟦              ⟧) → SetSortArgsMap(#env, ())
rule InferSortArgs(#env, csortvars?⟦ ∀ ##VARIABLE+ . ⟧, csortargs?⟦              ⟧) → InferSortArgsAux(#env, #VARIABLE+, csort*⟦⟧, ())
rule InferSortArgs(#env, csortvars?⟦ ∀ ##VARIABLE+ . ⟧, csortargs?⟦ < ##csort* > ⟧) → InferSortArgsAux(#env, #VARIABLE+, csort*⟦⟧, ())
rule InferSortArgs(#env, csortvars?⟦                 ⟧, csortargs?⟦ < ##csort* > ⟧) → Error("Error: extra type arguments") // TODO: better

func InferSortArgsAux({String:IEnvEntry}, List<String>, List<Core_csort_sort>, List<PPair<String Core_csort_sort>>) -> {String:IEnvEntry}

  // Common case: no sort argument. Create one and update mapping.
  rule InferSortArgsAux(#env, (#sortvar, #sortvars...), csort*⟦⟧, #mapping)
  → let #sortVar = csort⟦ ⟨VARIABLE: INewSortVar(#env)⟩ ⟧
    let #nenv = IIncCounter(#env)
      InferSortArgsAux(#nenv, #sortvars, csort*⟦⟧, Append(PairCons(#sortvar, #sortVar), #mapping))

  // Less common case: there is a sort argument. Just reuse it.
  rule InferSortArgsAux(#env, (#sortvar, #sortvars...), csort*⟦ ##csort ##csort* ⟧, #mapping)
  → InferSortArgsAux(#env, #sortvars, #csort*, Append(PairCons(#sortvar, #csort), #mapping))

  // Termination
  rule InferSortArgsAux(#env, (), csort*⟦⟧, #mapping)  → SetSortArgsMap(#env, #mapping)

  // Error: too many sort arguments
  rule InferSortArgsAux(#env, (), csort*⟦ ##csort ##csort* ⟧, #mapping)  → Error("Error: extra type arguments")

func IAddDummySorts({String:IEnvEntry}, List<Core_csortvars_sort>) -> {String:IEnvEntry}
rule IAddDummySorts(#env, csortvars?⟦                 ⟧) → #env
rule IAddDummySorts(#env, csortvars?⟦ ∀ ##VARIABLE+ . ⟧) → IAddDummySortsAux(#env, #VARIABLE+)

func IAddDummySortsAux({String:IEnvEntry}, List<String>) -> {String:IEnvEntry}
rule IAddDummySortsAux(#env, (#sortvar, #sortvars...)) → IAddDummySortsAux(PutSort(#env, #sortvar, csort⟦ ⟨VARIABLE: "dummy"⟩ ⟧), #sortvars)
rule IAddDummySortsAux(#env, (                      ))  → #env

// --- Sort unification

/* Unify `#sort1` such that under a set of substitutions it is equal to `#sort2`.

   Both sorts need to belong to the same sort variable domain

   @param `#env` the environment containing the sort environment
   @param `#sort1` first sort
   @param `#sort2` second sort
   @return The environment containing an updated sort environment with substitutions unifying `#sort1` and  `#sort2`.
           If no such substitution is found, an error is raised.
*/
func UnifySort({String:IEnvEntry}, Core_csort_sort, Core_csort_sort) -> {String:IEnvEntry}

  rule UnifySort(#env, csort⟦ ##canno* thunk ##csort1 ⟧, csort⟦ ##canno* thunk ##csort2 ⟧)
  → UnifySort(#env, #csort1, #csort2)

  rule UnifySort(#env, csort⟦ ##canno* data ##csort1  ⟧, #csort2)
  → UnifySort(#env, #csort1, #csort2)

  rule UnifySort(#env, #csort1, csort⟦ ##canno* data ##csort2  ⟧)
  → UnifySort(#env, #csort1, #csort2)

  rule UnifySort(#env, csort⟦ ##canno*1 ##CONSTRUCTOR ##csorts? ⟧, csort⟦ ##canno*2 ##CONSTRUCTOR2 ##csorts?2 ⟧)
  → UnifyMaybeSorts(#env, #csorts?, #csorts?2)

  rule UnifySort(#env, csort⟦ ##canno* ##VARIABLE ⟧, #csort)
  → UnifySortVar(#env, #VARIABLE, GetSort(#env, #VARIABLE), #csort)

  rule UnifySort(#env, #csort, csort⟦ ##canno* ##VARIABLE ⟧)
  → UnifySortVar(#env, #VARIABLE, GetSort(#env, #VARIABLE), #csort)

  rule UnifySort(#env, csort⟦ ##canno*1 [ ##csort11 ] ##csort12 ⟧, csort⟦ ##canno*2 [ ##csort21 ] ##csort22 ⟧)
  → UnifySort(UnifySort(#env, #csort11, #csort21), #csort12, #csort22)

  rule UnifySort(#env, csort⟦ ##canno*1 ( ##csort11 ) ##csort12 ⟧, csort⟦ ##canno*2 ( ##csort21 ) ##csort22 ⟧)
  → UnifySort(UnifySort(#env, #csort11, #csort21), #csort12, #csort22)

  rule UnifySort(#env, csort⟦ ##canno*1 { ##csort11 : ##csort12 } ⟧, csort⟦ ##canno*2 { ##csort21 : ##csort22 } ⟧)
  → UnifySort(UnifySort(#env, #csort11, #csort21), #csort12, #csort22)

  // Handle aliases
  rule UnifySort(#env, csort⟦ ##canno* ##CONSTRUCTOR ##csorts? ⟧, #csort)
  → UnifyMaybeAlias(#env, FindAliasS(IGetSystem(#env), #CONSTRUCTOR), csort⟦ ##canno* ##CONSTRUCTOR ##csorts? ⟧, #csort)

  rule UnifySort(#env, #csort, csort⟦ ##canno* ##CONSTRUCTOR ##csorts? ⟧)
  → UnifyMaybeAlias(#env, FindAliasS(IGetSystem(#env), #CONSTRUCTOR), csort⟦ ##canno* ##CONSTRUCTOR ##csorts? ⟧, #csort)

  rule UnifySort(#env, #csort1, #csort2)
  → Error(ConcatString("Error: type ", ConcatString(PrintSort(#csort2), ConcatString(" is not an instance of type ", PrintSort(#csort1)))))

// -- Sub sorts

func UnifyMaybeSorts({String:IEnvEntry}, List<Core_csorts_sort>, List<Core_csorts_sort>) -> {String:IEnvEntry}
rule UnifyMaybeSorts(#env, csorts?⟦               ⟧, csorts?⟦               ⟧) → #env
rule UnifyMaybeSorts(#env, csorts?⟦ ( ##csort*1 ) ⟧, csorts?⟦ ( ##csort*2 ) ⟧) → UnifySorts(#env, #csort*1, #csort*2)

// Allow sort to be incomplete for now
rule UnifyMaybeSorts(#env, #csorts?1, #csorts?2) → #env

func UnifySorts({String:IEnvEntry}, List<Core_csort_sort>, List<Core_csort_sort>) -> {String:IEnvEntry}
rule UnifySorts(#env, csort*⟦                    ⟧, csort*⟦                    ⟧) → #env
rule UnifySorts(#env, csort*⟦ ##csort1 ##csort*1 ⟧, csort*⟦ ##csort2 ##csort*2 ⟧) → UnifySorts(UnifySort(#env, #csort1, #csort2), #csort*1, #csort*2)
rule UnifySorts(#env, #csort*1, #csort*2) → Error("Error: mismatched type arity for type XX and YY") // TODO

// -- Variable

func UnifySortVar({String:IEnvEntry}, String, Option<Core_csort_sort>, Core_csort_sort) -> {String:IEnvEntry}

  // Case 1: unify two sort variables
  rule UnifySortVar(#env, #VARIABLE1, #sort1, csort⟦ ##canno* ##VARIABLE2 ⟧)
  → UnifySortVar1(#env, #VARIABLE1, #sort1, #VARIABLE2, GetSort(#env, #VARIABLE2))

  // Case 2: unify with another non-variable sort, no existing entry
  rule UnifySortVar(#env, #VARIABLE1, NONE, #sort2)
  → PutSort(#env, #VARIABLE1, #sort2)

  // Case 3: unify with another non-variable sort, existing entry
  rule UnifySortVar(#env, #VARIABLE1, SOME(#sort1), #sort2)
  → UnifySort(#env, #sort1, #sort2)

// Helper due to issue #?? (final)
func UnifySortVar1(#env:{String:IEnvEntry}, #VARIABLE1: String, #sort1: Option<Core_csort_sort>, #VARIABLE2: String, #sort2:Option<Core_csort_sort>) -> {String:IEnvEntry}
→ If(StringEqual(#VARIABLE1, #VARIABLE2),
    // Same variable, nothing to do
    ()->#env,
    // Continue...
    ()->UnifySortVar2(#env, #VARIABLE1, #sort1, #VARIABLE2, #sort2))

// Unify 2 non identical variables.
func UnifySortVar2({String:IEnvEntry}, String, Option<Core_csort_sort>, String, Option<Core_csort_sort>) -> {String:IEnvEntry}

  rule UnifySortVar2(#env, #VARIABLE1, NONE, #VARIABLE2, NONE)
  → PutSort(#env, #VARIABLE1, csort⟦ ##VARIABLE2 ⟧)

  rule UnifySortVar2(#env, #VARIABLE1, SOME(#sort1), #VARIABLE2, NONE)
  → If(IsDummy(#sort1), ()->PutSort(#env, #VARIABLE2, csort⟦ ##VARIABLE1 ⟧), ()->UnifySort(#env, #sort1, csort⟦ ##VARIABLE2 ⟧))

  rule UnifySortVar2(#env, #VARIABLE1, NONE, #VARIABLE2, SOME(#sort2))
  → If(IsDummy(#sort2), ()->PutSort(#env, #VARIABLE1, csort⟦ ##VARIABLE2 ⟧), ()->UnifySort(#env, csort⟦ ##VARIABLE1 ⟧, #sort2))

  rule UnifySortVar2(#env, #VARIABLE1, SOME(#sort1), #VARIABLE2, SOME(#sort2))
  →  If(IsDummy(#sort1),
       ()->UnifySort(#env, csort⟦ ##VARIABLE1 ⟧, #sort2),
       ()->If(IsDummy(#sort2),
         ()->UnifySort(#env, csort⟦ ##VARIABLE2 ⟧, #sort1),
         ()->UnifySort(#env, #sort1, #sort2)))

// -- Unify aliases

func UnifyMaybeAlias({String:IEnvEntry}, Option<Core_cdecl_sort>, Core_csort_sort, Core_csort_sort) -> {String:IEnvEntry}

  rule UnifyMaybeAlias(#env, SOME(cdecl⟦ ##canno* alias ##CONSTRUCTOR ##csort ⟧), #csort1, #csort2)
  → UnifySort(#env, #csort, #csort2)

 // TODO: polymorphic sorts
  rule UnifyMaybeAlias(#env, NONE, #csort1, #csort2)
  → Error(ConcatString("Error: type ", ConcatString(PrintSort(#csort2), ConcatString(" is not an instance of type ", PrintSort(#csort1)))))


// ---- Sort environment optimizer

/* Optimize the sort environment by computing its transitive closure. */
func OptimizeSorts(#env: {String : IEnvEntry}) -> {String : IEnvEntry}
→ let #sorts = GetSorts(#env)
  let #nenv = IRemoveSorts(#env)
    Debug("OptimizeSorts", ()->SetSorts(#nenv, FoldlP((key sorts) -> OptimizeSort(sorts, (key,), MapGet(sorts, key), NONE),
                                                      #sorts,
                                                      MapKeys(#sorts))))

func OptimizeSort({String : Core_csort_sort}, List<String>, Option<Core_csort_sort>, Option<Core_csort_sort> /* previous sort */) -> {String : Core_csort_sort}

   // Map to a variable -> continue optimizing
   rule OptimizeSort(#sorts, #keys, SOME(csort⟦ ##canno* ##VARIABLE ⟧), #previous)
   → OptimizeSortAux(IsDummy(csort⟦ ##VARIABLE ⟧), #sorts, #keys, #VARIABLE, #previous)

   // Not a variable -> substitute
   rule OptimizeSort(#sorts, #keys, SOME(#sort), #previous)
   → OptimizeSort(#sorts, #keys, NONE, SOME(#sort))

   // No mapping and no previous, nothing to do
   rule OptimizeSort(#sorts, #keys, NONE, NONE)  → #sorts

   // No more mapping and got a sort -> replace all
   rule OptimizeSort(#sorts, #keys, NONE, SOME(#sort))
   → FoldlP((key sorts)->MapPut(sorts, key, #sort), #sorts, #keys)

func OptimizeSortAux(Bool, {String : Core_csort_sort}, List<String>, String, Option<Core_csort_sort>) -> {String : Core_csort_sort}

   // dummy var -> quit
   rule OptimizeSortAux(TRUE, #sorts, #keys, #VARIABLE, #previous)
   → OptimizeSort(#sorts, #keys, NONE, #previous)

   rule OptimizeSortAux(FALSE, #sorts, #keys, #VARIABLE, #previous)
   → OptimizeSort(#sorts, #keys, MapGet(#sorts, #VARIABLE), SOME(csort⟦ ##VARIABLE ⟧))

// ---- Apply sort instantiation

func ISubstRule(#env: {String:IEnvEntry}, #cterm1: Core_cterm_sort, #cterm2: Core_cterm_sort) -> Core_cdecl_sort
→ Debug("Subst rule", ()->cdecl⟦ rule ⟨cterm: ISubstTerm(#env, #cterm1)⟩ → ⟨cterm: ISubstTerm(#env, #cterm2)⟩ ⟧)

func ISubstTerm({String:IEnvEntry}, Core_cterm_sort) -> Core_cterm_sort
rule ISubstTerm(#env, cterm⟦ ##canno* ##cqconstructor ##csortargs? ##cterms? ##csortanno? ⟧) → cterm⟦ ##canno* ⟨cqconstructor: ISubstQCons(#env, #cqconstructor)⟩ ⟨csortargs?: ISubstMaybeSortArgs(#env, #csortargs?)⟩ ⟨cterms?: ISubstMaybeTerms(#env, #cterms?)⟩ ⟨csortanno?: ISubstMaybeSortAnno(#env, #csortanno?)⟩ ⟧
rule ISubstTerm(#env, cterm⟦ ##canno* ##METAVAR ##cterms? ##csubst? ##csortanno? ⟧)          → cterm⟦ ##canno* ##METAVAR ⟨cterms?: ISubstMaybeTerms(#env, #cterms?)⟩ ⟨csubst?: ISubstMaybeISubst(#env, #csubst?)⟩ ⟨csortanno?: ISubstMaybeSortAnno(#env, #csortanno?)⟩ ⟧
rule ISubstTerm(#env, cterm⟦ ##canno* ##VARIABLE ##csortanno? ⟧)                             → cterm⟦ ##canno* ##VARIABLE ⟨csortanno?: ISubstMaybeSortAnno(#env, #csortanno?)⟩ ⟧
rule ISubstTerm(#env, cterm⟦ ##canno* [ x ##csortanno?[] ] ##cterm[x] ⟧)                     → cterm⟦ ##canno* [ x ⟨csortanno?: ISubstMaybeSortAnno(#env, #csortanno?)⟩ ] ⟨cterm: ISubstTerm(#env, #cterm[x])⟩ ⟧
rule ISubstTerm(#env, cterm⟦ ##canno* ( f ##csortanno?[] ) ##cterm[f] ⟧)                     → cterm⟦ ##canno* ( f ⟨csortanno?: ISubstMaybeSortAnno(#env, #csortanno?)⟩ ) ⟨cterm: ISubstTerm(#env, #cterm[f])⟩ ⟧
rule ISubstTerm(#env, cterm⟦ ##canno* { ##cmapentries? } ##csortanno? ⟧)                     → cterm⟦ ##canno* { ⟨cmapentries?: ISubstMaybeMapEntries(#env, #cmapentries?)⟩ } ⟨csortanno?: ISubstMaybeSortAnno(#env, #csortanno?)⟩ ⟧
rule ISubstTerm(#env, cterm⟦ ##canno* thunk ##cterm ⟧)                                       → cterm⟦ ##canno* thunk ⟨cterm: ISubstTerm(#env, #cterm)⟩ ⟧
rule ISubstTerm(#env, cterm⟦ ##canno* ##METAVAR = ##cterm ⟧)                                 → cterm⟦ ##canno* ##METAVAR = ⟨cterm: ISubstTerm(#env, #cterm)⟩ ⟧
rule ISubstTerm(#env, cterm⟦ ##canno* let ##METAVAR ##csortanno? = ##cterm ##cterm2 ⟧)       → cterm⟦ ##canno* let ##METAVAR ⟨csortanno?: ISubstMaybeSortAnno(#env, #csortanno?)⟩ = ⟨cterm: ISubstTerm(#env, #cterm)⟩ ⟨cterm: ISubstTerm(#env, #cterm2)⟩ ⟧
rule ISubstTerm(#env, #cterm)                                                               → #cterm

func ISubstQCons({String:IEnvEntry}, Core_cqconstructor_sort) -> Core_cqconstructor_sort
rule ISubstQCons(#env, cqconstructor⟦ ##csortqualifier* ##CONSTRUCTOR ⟧) → cqconstructor⟦ ⟨csortqualifier*: ISubstSortQuals(#env, #csortqualifier*)⟩ ##CONSTRUCTOR ⟧

func ISubstSortQuals({String:IEnvEntry}, List<Core_csortqualifier_sort>) -> List<Core_csortqualifier_sort>
rule ISubstSortQuals(#env, csortqualifier*⟦ ##csort :: ##csortqualifier* ⟧) → csortqualifier*⟦ ⟨csort: ISubstSort(#env, #csort)⟩ :: ⟨csortqualifier*: ISubstSortQuals(#env, #csortqualifier*)⟩ ⟧
rule ISubstSortQuals(#env, csortqualifier*⟦                              ⟧) → csortqualifier*⟦  ⟧

func ISubstMaybeSortArgs({String:IEnvEntry}, List<Core_csortargs_sort>) -> List<Core_csortargs_sort>
rule ISubstMaybeSortArgs(#env, csortargs?⟦              ⟧) → csortargs?⟦⟧
rule ISubstMaybeSortArgs(#env, csortargs?⟦ < ##csort* > ⟧) → csortargs?⟦ < ⟨csort*: ISubstSorts(#env, #csort*)⟩ >⟧

func ISubstMaybeTerms({String:IEnvEntry}, List<Core_cterms_sort>) -> List<Core_cterms_sort>
rule ISubstMaybeTerms(#env, cterms?⟦              ⟧) → cterms?⟦⟧
rule ISubstMaybeTerms(#env, cterms?⟦ ()           ⟧) → cterms?⟦ () ⟧
rule ISubstMaybeTerms(#env, cterms?⟦ ( ##cterm* ) ⟧) → cterms?⟦ ( ⟨cterm*: ISubstTerms(#env, #cterm*)⟩ ) ⟧

func ISubstMaybeSortAnno({String:IEnvEntry}, List<Core_csortanno_sort>) -> List<Core_csortanno_sort>
rule ISubstMaybeSortAnno(#env, csortanno?⟦           ⟧) → csortanno?⟦⟧
rule ISubstMaybeSortAnno(#env, csortanno?⟦ : ##csort ⟧) → csortanno?⟦ : ⟨csort: ISubstSort(#env, #csort)⟩ ⟧

func ISubstMaybeISubst({String:IEnvEntry}, List<Core_csubst_sort>) -> List<Core_csubst_sort>
rule ISubstMaybeISubst(#env, csubst?⟦              ⟧) → csubst?⟦⟧
rule ISubstMaybeISubst(#env, csubst?⟦ [ ##cterm* ] ⟧) → csubst?⟦ [ ⟨cterm*: ISubstTerms(#env, #cterm*)⟩ ] ⟧

func ISubstTerms({String:IEnvEntry}, List<Core_cterm_sort>) -> List<Core_cterm_sort>
rule ISubstTerms(#env, cterm*⟦ ##cterm ##cterm* ⟧) → cterm*⟦ ⟨cterm: ISubstTerm(#env, #cterm)⟩ ⟨cterm*: ISubstTerms(#env, #cterm*)⟩ ⟧
rule ISubstTerms(#env, cterm*⟦                  ⟧) → cterm*⟦⟧

func ISubstMaybeMapEntries({String:IEnvEntry}, List<Core_cmapentries_sort>) -> List<Core_cmapentries_sort>
rule ISubstMaybeMapEntries(#env, cmapentries?⟦ ##cmapentry* ⟧) → cmapentries?⟦ ⟨cmapentry*: ISubstMapEntries(#env, #cmapentry*)⟩ ⟧
rule ISubstMaybeMapEntries(#env, cmapentries?⟦              ⟧) → cmapentries?⟦ ⟧

func ISubstMapEntries({String:IEnvEntry}, List<Core_cmapentry_sort>) -> List<Core_cmapentry_sort>
rule ISubstMapEntries(#env, cmapentry*⟦ ##cmapentry ##cmapentry* ⟧) → cmapentry*⟦ ⟨cmapentry: ISubstMapEntry(#env, #cmapentry)⟩ ⟨cmapentry*: ISubstMapEntries(#env, #cmapentry*)⟩ ⟧
rule ISubstMapEntries(#env, cmapentry*⟦                          ⟧) → cmapentry*⟦ ⟧

func ISubstMapEntry({String:IEnvEntry}, Core_cmapentry_sort) -> Core_cmapentry_sort
rule ISubstMapEntry(#env, cmapentry⟦ ##METAVAR : ##cterm  ⟧) → cmapentry⟦ ##METAVAR : ⟨cterm: ISubstTerm(#env, #cterm)⟩ ⟧
rule ISubstMapEntry(#env, cmapentry⟦ ##VARIABLE : ##cterm ⟧) → cmapentry⟦ ##VARIABLE : ⟨cterm: ISubstTerm(#env, #cterm)⟩ ⟧
rule ISubstMapEntry(#env, cmapentry⟦ ##STRING : ##cterm   ⟧) → cmapentry⟦ ##STRING : ⟨cterm: ISubstTerm(#env, #cterm)⟩ ⟧
rule ISubstMapEntry(#env, #cmapentry) → #cmapentry

func ISubstSorts({String:IEnvEntry}, List<Core_csort_sort>) -> List<Core_csort_sort>
rule ISubstSorts(#env, csort*⟦ ##csort ##csort* ⟧) → csort*⟦ ⟨csort: ISubstSort(#env, #csort)⟩ ⟨csort*: ISubstSorts(#env, #csort*)⟩ ⟧
rule ISubstSorts(#env, csort*⟦                  ⟧) → csort*⟦⟧

func ISubstSort({String:IEnvEntry}, Core_csort_sort) -> Core_csort_sort
rule ISubstSort(#env, csort⟦ ##canno* ##CONSTRUCTOR ##csorts? ⟧) → csort⟦ ##canno* ##CONSTRUCTOR ⟨csorts?: ISubstMaybeSorts(#env, #csorts?)⟩ ⟧
rule ISubstSort(#env, csort⟦ ##canno* ##VARIABLE              ⟧) → ISubstVar(#env, #VARIABLE, GetSort(#env, #VARIABLE))
rule ISubstSort(#env, csort⟦ ##canno* [ ##csort1 ] ##csort2   ⟧) → csort⟦ ##canno* [ ⟨csort: ISubstSort(#env, #csort1)⟩ ] ⟨csort: ISubstSort(#env, #csort2)⟩ ⟧
rule ISubstSort(#env, csort⟦ ##canno* ( ##csort1 ) ##csort2   ⟧) → csort⟦ ##canno* ( ⟨csort: ISubstSort(#env, #csort1)⟩ ) ⟨csort: ISubstSort(#env, #csort2)⟩ ⟧
rule ISubstSort(#env, csort⟦ ##canno* { ##cmapsort* }         ⟧) → csort⟦ ##canno* { ⟨cmapsort*: ISubstMapSorts(#env, #cmapsort*)⟩ } ⟧
rule ISubstSort(#env, csort⟦ ##canno* thunk ##csort           ⟧) → csort⟦ ##canno* thunk ⟨csort: ISubstSort(#env, #csort)⟩ ⟧
rule ISubstSort(#env, csort⟦ ##canno* data ##csort            ⟧) → csort⟦ ##canno* data ⟨csort: ISubstSort(#env, #csort)⟩ ⟧

func ISubstMaybeSorts({String:IEnvEntry}, List<Core_csorts_sort>) -> List<Core_csorts_sort>
rule ISubstMaybeSorts(#env, csorts?⟦ ( ##csort* ) ⟧) → csorts?⟦ ( ⟨csort*: ISubstSorts(#env, #csort*)⟩ ) ⟧
rule ISubstMaybeSorts(#env, csorts?⟦              ⟧) → csorts?⟦⟧

// The insteresting bit is here. The rest is just boilerplate.
func ISubstVar({String:IEnvEntry}, String, Option<Core_csort_sort>) -> Core_csort_sort
rule ISubstVar(#env, #VARIABLE, NONE        ) → csort⟦ ##VARIABLE ⟧  // generic variable
rule ISubstVar(#env, #VARIABLE, SOME(#csort)) → If(IsDummy(#csort), ()->csort⟦ ##VARIABLE ⟧, ()->ISubstSort(#env, #csort))

func ISubstMapSorts({String:IEnvEntry}, List<Core_cmapsort_sort>) -> List<Core_cmapsort_sort>
rule ISubstMapSorts(#env, cmapsort*⟦                                 ⟧) → cmapsort*⟦⟧
rule ISubstMapSorts(#env, cmapsort*⟦ ##csort1 : ##csort2 ##cmapsort* ⟧) → cmapsort*⟦ ⟨csort: ISubstSort(#env, #csort1)⟩ : ⟨csort: ISubstSort(#env, #csort2)⟩  ⟨cmapsort*: ISubstMapSorts(#env, #cmapsort*)⟩ ⟧

// --- Various utility functions

/* @return `TRUE` is the given `#sort` is the dummy sort */
func IsDummy(Core_csort_sort) -> Bool
rule IsDummy(csort⟦ ##canno* ##VARIABLE ⟧) → StringEqual(#VARIABLE, "dummy")
rule IsDummy(#csort                     ) → FALSE

/* Create a new sort variable. */
func INewSortVar(#env: {String:IEnvEntry}) -> String
→ ConcatString("a", FormatNumber(IGetCounter(#env)))

/* Create a new generic sort from sort prototype. */
func INewSort<a>({String:IEnvEntry}, Core_csort_sort, ({String:IEnvEntry} Core_csort_sort)->a) -> a
rule INewSort(#env, csort⟦ ##canno* ##CONSTRUCTOR ##csorts? ⟧, #cont) → INewSortMaybeSorts(#env, #csorts?, (env csorts)->#cont(env, csort⟦ ##canno* ##CONSTRUCTOR ⟨csorts?: csorts⟩ ⟧))
rule INewSort(#env, csort⟦ ##canno* ##VARIABLE              ⟧, #cont) → #cont(IIncCounter(#env), csort⟦ ##canno* ⟨VARIABLE: INewSortVar(#env)⟩ ⟧)
rule INewSort(#env, csort⟦ ##canno* [ ##csort1 ] ##csort2   ⟧, #cont) → INewSort(#env, #csort1, (env sort1)->INewSort(env, #csort2, (env sort2)->#cont(env,  csort⟦ ##canno* [ ⟨csort: sort1⟩ ] ⟨csort: sort2⟩ ⟧)))
rule INewSort(#env, csort⟦ ##canno* ( ##csort1 ) ##csort2   ⟧, #cont) → INewSort(#env, #csort1, (env sort1)->INewSort(env, #csort2, (env sort2)->#cont(env,  csort⟦ ##canno* ( ⟨csort: sort1⟩ ) ⟨csort: sort2⟩ ⟧)))
rule INewSort(#env, csort⟦ ##canno* { ##cmapsort* }         ⟧, #cont) → INewSortMapSorts(#env, #cmapsort*, (env mapsorts)->#cont(env, csort⟦ ##canno*  { ⟨cmapsort*: mapsorts⟩ } ⟧))
rule INewSort(#env, csort⟦ ##canno* thunk ##csort           ⟧, #cont) → INewSort(#env, #csort, (env sort)->#cont(env, csort⟦ ##canno* thunk ⟨csort: sort⟩ ⟧))
rule INewSort(#env, csort⟦ ##canno* data ##csort            ⟧, #cont) → INewSort(#env, #csort, (env sort)->#cont(env, csort⟦ ##canno* data ⟨csort: sort⟩ ⟧))

func INewSortMaybeSorts<a>({String:IEnvEntry}, List<Core_csorts_sort>, ({String:IEnvEntry} List<Core_csorts_sort>)->a) -> a
rule INewSortMaybeSorts(#env, csorts?⟦             ⟧, #cont) → #cont(#env, csorts?⟦⟧)
rule INewSortMaybeSorts(#env, csorts?⟦ ( ##csort*) ⟧, #cont) → INewSortSorts(#env, #csort*, (env sorts)->#cont(env, csorts?⟦ ( ⟨csort*: sorts⟩ ) ⟧))

func INewSortSorts<a>({String:IEnvEntry}, List<Core_csort_sort>, ({String:IEnvEntry} List<Core_csort_sort>)->a) -> a
rule INewSortSorts(#env, csort*⟦ ##csort ##csort*  ⟧, #cont) → INewSort(#env, #csort, (env sort)->INewSortSorts(env, #csort*, (env sorts)->#cont(env, csort*⟦ ⟨csort: sort⟩ ⟨csort*: sorts⟩ ⟧)))
rule INewSortSorts(#env, csort*⟦                   ⟧, #cont) → #cont(#env, csort*⟦⟧)

func INewSortMapSorts<a>({String:IEnvEntry}, List<Core_cmapsort_sort>, ({String:IEnvEntry} List<Core_cmapsort_sort>)->a) -> a
rule INewSortMapSorts(#env, cmapsort*⟦ ##csort1 : ##csort2 ##cmapsort* ⟧, #cont) → INewSort(#env, #csort1, (env sort1)->INewSort<a>(env, #csort2, (env sort2)->INewSortMapSorts<a>(env, #cmapsort*, (env mapsorts)->#cont(env, cmapsort*⟦ ⟨csort: sort1⟩ : ⟨csort: sort2⟩ ⟨cmapsort*: mapsorts⟩ ⟧))))
rule INewSortMapSorts(#env, cmapsort*⟦                                 ⟧, #cont) → #cont(#env, cmapsort*⟦⟧)

/* Assemble the sort list corresponding to given formal or bound variable parameters list. */
func IFindBinderSorts({String:IEnvEntry}, List<Core_cterm_sort>, Bool) -> List<Core_csort_sort>
rule IFindBinderSorts(#env, cterm*⟦ ##cqconstructor ##csortargs? ##cterms? : ##csort  ##cterm* ⟧, #formal) → Cons(#csort, IFindBinderSorts(#env, #cterm*, #formal))
rule IFindBinderSorts(#env, cterm*⟦ ##METAVAR ##cterms? ##csubst? : ##csort           ##cterm* ⟧, #formal) → Cons(#csort, IFindBinderSorts(#env, #cterm*, #formal))
rule IFindBinderSorts(#env, cterm*⟦ ##VARIABLE                                        ##cterm* ⟧, TRUE   ) → IFindBinderSortsTerm(#env, IGetFormalSort(#env, #VARIABLE), #cterm*, TRUE)
rule IFindBinderSorts(#env, cterm*⟦ ##VARIABLE                                        ##cterm* ⟧, FALSE  ) → IFindBinderSortsTerm(#env, IGetBoundVarSort(#env, #VARIABLE), #cterm*, FALSE)
rule IFindBinderSorts(#env, cterm*⟦ ##VARIABLE : ##csort                              ##cterm* ⟧, #formal) → Cons(#csort, IFindBinderSorts(#env, #cterm*, #formal))
rule IFindBinderSorts(#env, cterm*⟦ ##STRING                                          ##cterm* ⟧, #formal) → Cons(csort⟦ String ⟧, IFindBinderSorts(#env, #cterm*, #formal))
rule IFindBinderSorts(#env, cterm*⟦ ##NUMBER                                          ##cterm* ⟧, #formal) → Cons(csort⟦ Numeric ⟧, IFindBinderSorts(#env, #cterm*, #formal))
rule IFindBinderSorts(#env, cterm*⟦ { ##cmapentries? } : ##csort                      ##cterm* ⟧, #formal) → Cons(#csort, IFindBinderSorts(#env, #cterm*, #formal))
rule IFindBinderSorts(#env, cterm*⟦ thunk ##cterm                                     ##cterm* ⟧, #formal) → IFindBinderSorts(#env, cterm*⟦ ##cterm ##cterm*⟧, #formal)
rule IFindBinderSorts(#env, cterm*⟦ ##cterm                                           ##cterm* ⟧, #formal) → Error("Type error: formal parameter or bound variable cannot be of a higher-order type")
rule IFindBinderSorts(#env, cterm*⟦                                                            ⟧, #formal) → ()

func IFindBinderSortsTerm({String:IEnvEntry}, Option<Core_csort_sort>, List<Core_cterm_sort>, Bool) -> List<Core_csort_sort>
rule IFindBinderSortsTerm(#env, SOME(#sort:Core_csort_sort), #cterm*, #formal) → Cons(#sort, IFindBinderSorts(#env, #cterm*, #formal))
rule IFindBinderSortsTerm(#env, NONE                       , #cterm*, #formal) → Cons(csort⟦ dummy ⟧, IFindBinderSorts(#env, #cterm*, #formal))
