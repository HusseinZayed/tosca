/*
 * Copyright (c) 2015 IBM Corporation.
 *
 * Generates sorts and basic printer from normalized ANTLR grammar.
 */
MakePrinter[(

$Lax;

$CheckGrammar["net.sf.crsx.text.Text"];
$Use["text/Text.crs"];
$Use["std/core.crs"];
$Use["std/text.crs"];
$Use["std/list.crs"];
$Use["std/pair.crs"];
$Use["std/string.crs"];
$Use["pg/util.crs"];

/* Generates sorts and a basic printer for the given ANTLR grammar specification */
MakeSorts[ANTLR_grammarSpec_sort] :: Text; 
MakeSorts[#] 
→ 
{"@index": INDEX[IndexGrammar[#]]}MakeGrammarSpec[#];

/* Helper */
MakeGrammarSpec[ANTLR_grammarSpec_sort] :: Text; 
{#E}MakeGrammarSpec[{#L}%grammarSpec⟦ #DOC_COMMENT? #grammarType #id ; #prequelConstruct* #ruleSpec* #modeSpec* ⟧] 
→ 
{#E}MakeModuleId[UnwrapId[#id], ok¹.ThenSeqMap[ok¹, rule cont.MakeRuleSpec[rule, cont], #ruleSpec*, ok¹.%n⟦⟧]];

/* Generate Sort/Printer module id */

MakeModuleId[ANTLR_grammarSpec_sort] :: Text;
{#E}MakeModuleId[#id, ok.#[ok]] 
→
%n⟦/* Generated File. */
†«#id»[(
$CheckGrammar["net.sf.crsx.text.Text"];
$Use["std/text.crs"];
$Use["std/core.crs"];
$Use["std/list.crs"];

«{#E; "@id": STRING[#id]}#[OK]»↲)]⟧; // TODO: must match CRSX syntax

/* `MakeRuleSpec[#rule, #cont] :: Text`
   Generates sort and printer for grammar rule 
 */
MakeRuleSpec[ANTLR_ruleSpec_sort, Cont[Text]] :: Text;
{#E}MakeRuleSpec[{#L}%ruleSpec⟦ #RULE_REF : #ruleBlock ; ⟧, #cont]                  → {#E; "@ruleRef": STRING[#RULE_REF]}MakeSort[#ruleBlock, #cont];
{#E}MakeRuleSpec[{#L}%ruleSpec⟦ #FRAGMENT? #TOKEN_REF : #lexerRuleBlock ; ⟧, #cont] → {#E}ApplyCont[#cont];

<!--―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

 Generate sorts, printer sorts and printer rules.

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――-->

/* Generates sort and printer for parser rule by iterating over the grammar alternatives 
   and incrementally building the printer in the environment. 
 */
MakeSort[ANTLR_ruleSpec_sort, Cont[Text]] :: Text;
 {#E}MakeSort[#ruleBlock, #cont] 
→ %n⟦¶¶«{#E}MakeSortName» ::= («
   {#E; "@sortname" : TEXT[{#E}MakeSortName]; 
        "@sort"     : TEXT[%n⟪⟫];
        "@pt-name"  : TEXT[{#E}MakePrinterName]; 
        "@pt-rules" : TEXT[%n⟪⟫];
        "@pt-subs"  : TEXT[%n⟪⟫];
   }MakeForms[#ruleBlock, ok¹.MakeSortTail[ok¹, #cont]]»⟧;

// Retrieves the sort and printer from the environment and construct text
MakeSortTail[OK_SORT, Cont[Text]] :: Text;
{#E; "@sortname": TEXT[#sortname];
     "@sort"    : TEXT[#sort]; 
     "@pt-name" : TEXT[#printerName];    
     "@pt-rules": TEXT[#printerRules];   
     "@pt-subs" : TEXT[#printerSubs];}
MakeSortTail[OK, #cont] 
→
%n⟦«#sort»);¶¶«#printerName»[«#sortname»] :: Text;«#printerRules»«#printerSubs»«{#E}ApplyCont[#cont]»⟧;

// 
MakeForms[ANTLR_ruleBlock_sort, ok::OK_SORT.Text] :: Text;
{#E}MakeForms[{#L}%ruleBlock⟦ #alternative #ruleAltList_S1* ⟧, ok¹.#[ok¹]] 
→ {#E}MakeForm[#alternative, 1, IsEmpty[#ruleAltList_S1*], ok¹ count¹.MakeRuleAltList_S1s[ok¹, count¹, #ruleAltList_S1*, o2¹.#[o2¹]]];

//
MakeRuleAltList_S1s[OK_SORT, $Numeric, $List[ANTLR_ruleAltList_S1_sort], ok::OK_SORT.Text] :: Text;

{#E}MakeRuleAltList_S1s[OK, #count, (), ok¹.#[ok¹]] → {#E}#[OK];

{#E}MakeRuleAltList_S1s[OK, #count, {#L}%ruleAltList_S1*⟦ | #alternative #ruleAltList_S1* ⟧, ok¹.#[ok¹]] 
→ {#E}MakeForm[#alternative, #count, FALSE, ok¹ count¹.MakeRuleAltList_S1s[ok¹, count¹, #ruleAltList_S1*, o2¹.#[o2¹]]];

//
MakeForm[ANTLR_alternative_sort, $Numeric, Boolean, ok::OK_SORT.Text] :: Text;

{#E; "@sort":TEXT[#sort]}MakeForm[{#L}%alternative⟦ #element* ⟧, #count, #unique, ok¹ count¹.#[ok¹, count¹]] 
→ {#E; "@sort"    : TEXT[%n⟦«#sort»«{#E}MakeAlternativeName[#count, #unique]»⟧];
       "@plhs"    : TEXTS[()];   // Printer rule lhs arguments
       "@prhs"    : TEXTS[()];   // Printer rule rhs  
       "@inblock" : NO 
  }MaybeMakeArguments[#element*, ok¹.MakePrintingRule[ok¹, {#E}MakeAlternativeName[#count, #unique], o2¹.#[o2¹, $[Plus, #count, 1]]]];

//
MakePrintingRule[OK_SORT, Text, ok::OK_SORT.Text] :: Text;
{#E; "@pt-rules" : TEXT[#printerRules];
     "@pt-name"  : TEXT[#printerName];
     "@plhs"     : TEXTS[#printerRuleLHS];    
     "@prhs"     : TEXTS[#printerRuleRHS]}
MakePrintingRule[OK, #altName, ok¹.#[ok¹]] 
→ {#E; 
    "@pt-rules" : TEXT[%n⟦«#printerRules»¶«#printerName»[«#altName»[«ReverseTextFold[#printerRuleLHS, %n⟪, ⟫]»]] → «Text-Text[Text-ReverseConcat[#printerRuleRHS]]»;⟧]; 
  }#[OK];

/* Iterates over the elements (maybe none) of an alternative. 
 */
MaybeMakeArguments[$List[ANTLR_element_sort], ok::OK_SORT.Text] :: Text;

{#E; "@sort":TEXT[#sort]}MaybeMakeArguments[(), ok¹.#[ok¹]] → {#E;"@sort": TEXT[%n⟦«#sort»;⟧]}#[OK];

{#E; "@sort":TEXT[#sort]}MaybeMakeArguments[%element*⟨ #element #element* ⟩, ok¹.#[ok¹]] 
→ {#E; "@sort"       : TEXT[%n⟦«#sort»[⟧]; // Have at least one alternative: open bracket
       "@sep"        : TEXT[%n⟦⟧];         // Current separator between data forms
       "@block-count": NUM[0];            // Count the number of subrules for generating unique names
       "@sublist"    : WRAPPER[x.x];      // Use to unfused elements  
  }MakeArguments[OK, 1, %element*⟨ #element #element* ⟩, ok¹.MakeCloseArguments[ok¹, o2¹.#[o2¹]]];

/* Done iterating over alternative elements. Close sort bracket 
*/
MakeCloseArguments[OK_SORT, ok::OK_SORT.Text] :: Text;
{#E; "@sort":TEXT[#sort]}MakeCloseArguments[OK, o2¹.#[o2¹]] → {#E; "@sort":TEXT[%n⟦«#sort»]; ⟧]}#[OK];

//
MakeArguments[OK_SORT, $Numeric, $List[ANTLR_element_sort], ok::OK_SORT.Text] :: Text;

{#E}MakeArguments[OK, #count, (), ok¹.#[ok¹]] → {#E}#[OK];

{#E; "@index": INDEX[{#I}RULEINDEX]}
MakeArguments[OK, #count, %element*⟨ #element #element* ⟩, ok¹.#[ok¹]] 
→ {#E}MaybeMakeArgument[IsFused[#element, #element*, {#I}RULEINDEX], {#I}IsConstantElement[#element], #element, #count, 
                        ok¹ count.MakeArguments[ok¹, count, #element*, o2¹.#[o2¹]]];
//
MaybeMakeArgument[Boolean /* fused? */, Boolean /* constant? */, $List[ANTLR_element_sort], $Numeric, ok::OK_SORT.Text] :: Text;

// Common case: element is not fused and not a constant.   
{#E; "@sort":TEXT[#sort]; "@sep":TEXT[#sep]}
MaybeMakeArgument[FALSE, FALSE, #element, #count, ok¹ count.#[ok¹, count]] 
→ {#E;"@sort":TEXT[%n⟦«#sort»«#sep»⟧]; "@sep":TEXT[%n⟦, ⟧]}MakeArgument[#element, #count, ok¹.#[ok¹, $[Plus, #count, 1]]];

/* The first list argument has been fused but not a constant. Unfused by extracting it. 
   Only update the right hand-side as the lhs metavariable is reused 
 */
{#E; "@prhs": TEXTS[#printerRHS]; "@index": INDEX[#index]}
MaybeMakeArgument[TRUE, FALSE, #element, #count, ok¹ count.#[ok¹, count]] 
→ {#E; "@sublist": WRAPPER[x.%n⟦Tail[«x»]⟧]; 
       "@prhs": TEXTS[({#E}MakeRulerefText[UnSOME[GetRefElement[#element, (), #index]], #count, FALSE, x.%n⟦Head[«x»]⟧]; #printerRHS)]
  }#[OK, #count];

// The argument is a constant. Continue: it won't be added to sort but to printer.
{#E}MaybeMakeArgument[FALSE, TRUE, #element, #count, ok¹ count.#[ok¹, count]] 
→ {#E}MakeArgument[#element, #count, ok¹.#[ok¹, #count]];

//
MakeArgument[ANTLR_element_sort, $Numeric, ok::OK_SORT.Text] :: Text;

// labeled element with optional ebnf suffix
{#E; "@plhs": TEXTS[#printerLHS]; "@inblock":#inblock}
MakeArgument[{#L}%element⟦ #labeledElement #element_A1_S1 ⟧, #count, ok¹.#[ok¹]] 
→ {#E; "@plhs": TEXTS[(MakeMetaVar[#count]; #printerLHS)]}MakeArgFromAtom[UnwrapAtom[#labeledElement], MapToList1[#element_A1_S1, #inblock], #count, ok¹.#[ok¹]];

// atom with optional ebnf
{#E; "@inblock":#inblock}
MakeArgument[{#L}%element⟦ #atom #element_A2_S1 ⟧, #count, ok¹.#[ok¹]] 
→ {#E}MakeArgFromAtom[#atom, MapToList2[#element_A2_S1, #inblock], #count, ok¹.#[ok¹]];

// A trivial block with no suffix: just inlined.
{#E}MakeArgument[{#L}%element⟦ #block ⟧, #count, ok¹.#[ok¹]] 
→ {#E}MakeArgFromBlock[#block, #count, ok¹.#[ok¹]]; 

// A trivial block with suffix: generate printing rule for block and apply it.
{#E}MakeArgument[{#L}%element⟦ #block #blockSuffix ⟧, #count, ok¹.#[ok¹]] 
→ {#E}MakeArgFromSuffixedBlock[#block, #blockSuffix, #count, ok¹.#[ok¹]]; 

// Skip action...
{#E}MakeArgument[{#L}%element⟦ #ACTION #QUESTION? ⟧, #count, ok¹.#[ok¹]] 
→ {#E}#[OK];

//
MakeArgFromAtom[ANTLR_atom_sort, Boolean /* Is list? */, $Numeric, ok::OK_SORT.Text] :: Text;
 
{#E; "@sort": TEXT[#sort]; "@plhs": TEXTS[#printerLHS]; "@prhs": TEXTS[#printerRHS]}
MakeArgFromAtom[{#L}%atom⟦ #STRING_LITERAL ⟧, TRUE, #count, ok¹.#[ok¹]] 
→ {#E; "@sort":TEXT[%n⟦«#sort»$List[$String]⟧]; "@plhs": TEXTS[(MakeMetaVar[#count]; #printerLHS)]; "@prhs": TEXTS[(MakeTerminalText[#count, TRUE]; #printerRHS)]}#[OK];

// String literal are constants. Print it 
{#E; "@plhs": TEXTS[#printerLHS]; "@prhs": TEXTS[#printerRHS]}
MakeArgFromAtom[{#L}%atom⟦ #STRING_LITERAL ⟧, FALSE, #count, ok¹.#[ok¹]] 
→ {#E; "@plhs": TEXTS[(MakeMetaVar[#count]; #printerLHS)]; "@prhs": TEXTS[(StringToText[#STRING_LITERAL]; #printerRHS)]}#[OK];

// List of token ref.
{#E; "@sort": TEXT[#sort]; "@plhs": TEXTS[#printerLHS]; "@prhs": TEXTS[#printerRHS]}
MakeArgFromAtom[{#L}%atom⟦ #TOKEN_REF ⟧, TRUE, #count, ok¹.#[ok¹]] 
→ {#E; "@sort":TEXT[%n⟦«#sort»$List[$String]⟧]; "@plhs": TEXTS[(MakeMetaVar[#count]; #printerLHS)]; "@prhs": TEXTS[(MakeTerminalText[#count, TRUE]; #printerRHS)]}#[OK];
 
{#E; "@index": INDEX[{#I}RULEINDEX]}
MakeArgFromAtom[{#L}%atom⟦ #TOKEN_REF ⟧, FALSE, #count, ok¹.#[ok¹]] 
→ {#E}MakeArgFromTokenRef[{#I}IsConstantAtom[%atom⟦ #TOKEN_REF ⟧], #TOKEN_REF, #count, ok¹.#[ok¹]];

{#E; "@sort": TEXT[#sort]; "@plhs": TEXTS[#printerLHS]; "@prhs": TEXTS[#printerRHS]; "@sublist": WRAPPER[x.#wrap[x]]}
MakeArgFromAtom[{#L}%atom⟦ #RULE_REF ⟧, TRUE, #count, ok¹.#[ok¹]] 
→ {#E; "@sort": TEXT[%n⟦«#sort»$List[«MakeSortName2[{#E}EnvString["@id"], #RULE_REF]»]⟧]; 
       "@plhs": TEXTS[(MakeMetaVar[#count]; #printerLHS)]; 
       "@prhs": TEXTS[({#E}MakeRulerefText[#RULE_REF, #count, TRUE, x.#wrap[x]]; #printerRHS)]}#[OK];

{#E; "@sort": TEXT[#sort]; "@plhs": TEXTS[#printerLHS]; "@prhs": TEXTS[#printerRHS]; "@sublist": WRAPPER[x.#wrap[x]]}
MakeArgFromAtom[{#L}%atom⟦ #RULE_REF ⟧, FALSE, #count, ok¹.#[ok¹]] 
→ {#E; "@sort": TEXT[%n⟦«#sort»«MakeSortName2[{#E}EnvString["@id"], #RULE_REF]»⟧]; 
       "@plhs": TEXTS[(MakeMetaVar[#count]; #printerLHS)];  
       "@prhs": TEXTS[({#E}MakeRulerefText[#RULE_REF, #count, FALSE, x.#wrap[x]]; #printerRHS)]}#[OK];

MakeArgFromTokenRef[Boolean, $String, $Numeric, ok¹::OK_SORT.Text] :: Text; 

{#E; "@prhs": TEXTS[#printerRHS]}MakeArgFromTokenRef[TRUE, #token, #count, ok¹.#[ok¹]] 
→  {#E; "@prhs": TEXTS[({#E}TokenRefToText[#token]; #printerRHS)]}#[OK];

{#E; "@sort": TEXT[#sort]; "@plhs": TEXTS[#printerLHS]; "@prhs": TEXTS[#printerRHS]}
MakeArgFromTokenRef[FALSE, #token, #count, ok¹.#[ok¹]] 
→ {#E; "@sort": TEXT[%n⟦«#sort»$String⟧]; 
       "@plhs": TEXTS[(MakeMetaVar[#count]; #printerLHS)]; 
       "@prhs": TEXTS[(MakeTerminalText[#count, FALSE]; #printerRHS)]}#[OK];

MakeArgFromSuffixedBlock[ANTLR_block_sort, ANTLR_blockSuffix_sort, $Numeric, ok¹::OK_SORT.Text] :: Text; 

/* The block has to be trivial with only one alternative. Something like (C p)*
 * Generate an helper rule printing the constant tokens
 */
{#E; "@block-count": NUM[#blkcnt]; "@index": INDEX[#index]}
MakeArgFromSuffixedBlock[%block⟦ ( #element* ) ⟧, #blockSuffix, #count, ok¹.#[ok¹]]
→ {#E; "@block-count": NUM[$[Plus, #blkcnt, 1]]}MakeArgFromSuffixedBlock1[GetRefElements[#element*, #index], #element*, #blkcnt, #count, ok¹.#[ok¹]];

MakeArgFromSuffixedBlock1[Option[$String], $List[ANTLR_element_sort], $Numeric, ok¹::OK_SORT.Text] :: Text; 

{#E}MakeArgFromSuffixedBlock1[NONE, #element*, #blkcnt, #count, ok¹.#[ok¹]] → $[Error, "constant subrules not supported yet"];

{#E; "@id": STRING[#id]; "@index": #index}
MakeArgFromSuffixedBlock1[SOME[#ruleRef], #element*, #blkcnt, #count, ok¹.#[ok¹]]
→ {#E}MakeArgFromSuffixedBlock2[MakeBlockRuleName[#ruleRef, #blkcnt], #ruleRef, 
       MakeSortForBlock[#id, MakePrinterName2[#id, MakeBlockRuleName[#ruleRef, #blkcnt]], 
                        #ruleRef,
                        UnSOME[{#E; "@plhs": TEXTS[()]; "@prhs": TEXTS[()]; "@inblock":YES}MaybeMakeArguments[#element*, ok¹.ThenGetSome[ok¹, "@prhs"]]]],
       #count, ok¹.#[ok¹]];

MakeArgFromSuffixedBlock2[$String, $String, Pair[Text, Text], $Numeric, ok¹::OK_SORT.Text] :: Text; 

{#E; "@sort": TEXT[#sort]; "@id": STRING[#id]; "@plhs": TEXTS[#printerLHS]; "@prhs": TEXTS[#printerRHS]; "@sublist": WRAPPER[x.#wrap[x]]}
MakeArgFromSuffixedBlock2[#blockRuleRef, #ruleRef, PairCons[#blocksort, #printer], #count, ok¹.#[ok¹]]
→ {#E; "@sort": TEXT[%n⟦«#sort»$List[«MakeSortName2[#id, #ruleRef]»]⟧]; 
       "@plhs": TEXTS[(MakeMetaVar[#count]; #printerLHS)]; 
       "@prhs": TEXTS[({#E}MakeRulerefText[#blockRuleRef, #count, TRUE, x.#wrap[x]]; #printerRHS)];
       "@pt-subs": TEXT[%n⟨‹#blocksort›‹#printer›⟩]}#[OK];

MakeSortForBlock[$String, Text, $String, $StringEntry] :: Pair[Text/* sort */, Text /* printer */]; 
MakeSortForBlock[#id, #name, #ruleRef, TEXTS[#prhs]] 
→ 
PairCons[
  %n⟦¶«#name»[«MakePrinterName2[#id, #ruleRef]»] :: Text;⟧, 
  %n⟦¶«#name»[#1] → «Text-Text[Text-ReverseConcat[#prhs]]»;⟧];

// Helpers

//
MapToList1[%element_A1_S1⟦ #ebnfSuffix ⟧, NO] → TRUE;
MapToList1[%element_A1_S1⟦ ⟧, NO]             → FALSE;
MapToList1[%element_A1_S1⟦ #ebnfSuffix ⟧, YES] → FALSE;
MapToList1[%element_A1_S1⟦ ⟧, YES]             → FALSE;

//
MapToList2[%element_A2_S1⟦ #ebnfSuffix ⟧, NO] → TRUE;
MapToList2[%element_A2_S1⟦ ⟧, NO]             → FALSE;
MapToList2[%element_A2_S1⟦ #ebnfSuffix ⟧, YES] → FALSE;
MapToList2[%element_A2_S1⟦ ⟧, YES]             → FALSE;

//
UnwrapAtom[{#L}%labeledElement⟦ #id #labeledElement_S1 #atom ⟧] 
→
#atom;

UnwrapAtom[{#L}%labeledElement⟦ #id #labeledElement_S1 #block ⟧] 
→
{#L}Special_error[%n⟦Subrules are not allowed.⟧];

//
{#E}EnvString[#key] → EnvString2[$[{#E}Get, #key, STRING[""]]];

EnvString2[STRING[#value]] → #value;
 
//
-[Data[#ruleRef, #id]]:
{#E; "@id": STRING[#id]; "@ruleRef": STRING[#ruleRef]}
MakeSortName 
→ StringToText[$[:, #id, "_", #ruleRef, "_sort"]];

//
-[Data[#ruleRef, #id]]:
MakeSortName2[#id, #ruleRef] 
→ StringToText[$[:, #id, "_", #ruleRef, "_sort"]];


-[Data[#ruleRef, #id]]:
{#E; "@id": STRING[#id]; "@ruleRef": STRING[#ruleRef]}
MakeAlternativeName[#count, FALSE] 
→ StringToText[$[:, #id, "_", #ruleRef, "_A", $[FormatNumber, #count]]];

-[Data[#ruleRef, #id]]
:
{#E; "@id": STRING[#id]; "@ruleRef": STRING[#ruleRef]}
MakeAlternativeName[#count, TRUE] 
→ StringToText[$[:, #id, "_", #ruleRef]];

<!--―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

 Printer helpers

――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――-->

// Generate printer function name corresponding to the given ruleref
MakePrinterName :: Text; 

{#E; "@id": STRING[#id]; "@ruleRef": STRING[#ruleRef]}
MakePrinterName  → MakePrinterName2[#id, #ruleRef];

// Generate printer function name corresponding to the given ruleref
MakePrinterName2[$String, $String] :: Text; 
-[Data[#ruleRef, #id]]: MakePrinterName2[#id, #ruleRef] → StringToText[$[:, #id, "_Print_", #ruleRef]];

MakeMetaVar[$Numeric] :: Text; 
MakeMetaVar[#count] → %n⟦#«NumberToText[#count]»⟧;

//
MakeTerminalText[#count, FALSE] 
→ Text-String[MakeMetaVar[#count]];

MakeTerminalText[#count, TRUE] 
→ Text-Embed[%n⟦TextFold[Map[x.StringToText[x], «MakeMetaVar[#count]»], «Text-Text[%n⟪ ⟫]»]⟧];

{#E}MakeRulerefText[#Ruleref, #count, FALSE, x.#wrap[x]] 
→ Text-Embed[%n⟦«{#E; "@ruleRef": STRING[#Ruleref]}MakePrinterName»[«#wrap[MakeMetaVar[#count]]»]⟧];

{#E}MakeRulerefText[#ruleRef, #count, TRUE, x.#wrap[x]] 
→ Text-Embed[%n⟦TextFold[Map[x.«{#E; "@ruleRef": STRING[#ruleRef]}MakePrinterName»[x], «#wrap[MakeMetaVar[#count]]»], «Text-Text[%n⟪ ⟫]»]⟧];

/* Generate an unique fake rule name for block. */
MakeBlockRuleName[$String, $Numeric] :: $String;
-[Data[#ruleRef, #blockCount]]: MakeBlockRuleName[#parentRuleRef, #blockCount] → $[:, #parentRuleRef, "_S", $[FormatNumber, #blockCount]];

TokenRefToText[$String] :: Text;
{#E; "@index": INDEX[{#I}RULEINDEX]}TokenRefToText[#tokenRef] → %n⟦ †«UnQuote[UnSOME[{#I}GetConstantTokenRef[#tokenRef]]]» ⟧;

UnQuote[$String] :: $String;
UnQuote[#] → RemoveFirstChar[RemoveLastChar[#]];

)]