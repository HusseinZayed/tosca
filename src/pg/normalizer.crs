/*
 * Normalize ANTLR v4 grammar as follows:
 *
 * FIRST PASS:
 *
 * - The following ANTLR constructs are stripped out:
 *   - options 
 *   - tokens {}
 *   - actions
 * - Subrules are promoted to top-level rules. For instance:
 *    
 *      A : ( B | C ) | D
 *      →   
 *      A    : A_S1 | D; 
 *      A_S1 : B | C;
 *
 *
 */
Normalizer[(

$Lax;

$Use["std/core.crs"];
$Use["std/list.crs"];
$Use["pg/util.crs"];
$Use["pg/ANTLR.crs"];

//
Normalize[ANTLR_grammarSpec_sort] :: ANTLR_grammarSpec_sort;
Normalize[#] → NormGrammarSpec[#]
;

// NEXT STEP: NormRule should only do the first transformation. Then do a second pass to create the ZOM rules

//
NormGrammarSpec[{#L}%grammarSpec⟨ #DOC_COMMENT? #grammarType #id ; #prequelConstruct* #rules #modeSpec* ⟩] → 
    {#L}%grammarSpec⟨ #grammarType #id ; #prequelConstruct* ⟨rules: {"@id": STRING[UnwrapId[#id]]}NormRules[#rules] ⟩ #modeSpec*⟩
;

// TODO: syntax
// 
NormPrequelConstructs[$List[ANTLR_prequelConstruct_sort]] :: $List[ANTLR_prequelConstruct_sort];

NormPrequelConstructs[()]   → ();
NormPrequelConstructs[({#L}ANTLR_prequelConstruct_A1[#optionsSpec]; #prequelConstruct*)] →
    NormPrequelConstructs[#prequelConstruct*]
;
 
NormPrequelConstructs[({#L}ANTLR_prequelConstruct_A2[#delegateGrammars]; #prequelConstruct*)] →
    ({#L}ANTLR_prequelConstruct_A2[#delegateGrammars]; NormPrequelConstructs[#prequelConstruct*])
;

NormPrequelConstructs[({#L}ANTLR_prequelConstruct_A3[#tokensSpec]; #prequelConstruct*)] →
    NormPrequelConstructs[#prequelConstruct*]
;

NormPrequelConstructs[({#L}ANTLR_prequelConstruct_A4[#action]; #prequelConstruct*)] →
    NormPrequelConstructs[#prequelConstruct*]
;

//
{#E}NormRules[{#L}%rules⟨ #ruleSpec* ⟩] → {#L}%rules⟨ ⟨ruleSpec*: {#E}NormRuleSpecs[#ruleSpec*]⟩ ⟩;

//
{#E}NormRuleSpecs[()]                       → ();
{#E}NormRuleSpecs[(#ruleSpec; #ruleSpec*)]  → Concat[{#E}NormRuleSpec[#ruleSpec], NormRuleSpecs[#ruleSpec*]];

// Normalize a parser rule. 
//
// A first pass is performed to replace subrules by a reference to the new rule describing the subrule  
//  
// The second pass creates new parser rules corresponding to the subrules.
// 
{#E}NormRuleSpec[{#L}%ruleSpec⟨ #DOC_COMMENT? #ruleModifiers? #RULE_REF #ARG_ACTION? #ruleReturns? #throwsSpec? #localsSpec? 
                                  #rulePrequel* : #ruleAltList ; #exceptionHandler* #finallyClause? ⟩] →
    (
        {#L}%ruleSpec⟨ #RULE_REF : ⟨ruleAltList: {#E; "@rule":STRING[#RULE_REF]}NormRuleAltList[#ruleAltList]⟩ ; ⟩; // First pass
        {#E; "@rule":STRING[#RULE_REF]}NSR-RuleAltList[#ruleAltList]                                             // Second pass
    );

{#E}NormRuleSpec[{#L}%ruleSpec⟨ #lexerRule ⟩] → ( {#L}%ruleSpec⟨ #lexerRule ⟩; );

//--------- First Pass: eliminate subrule

// 
//{#E}NormRuleBlock[{#L}%ruleBlock⟨ #ruleAltList ⟩] →
//    {#L}%ruleBlock⟨ ⟨ruleAltList: {#E}NormRuleAltList[#ruleAltList]⟩ ⟩;

//
{#E}
NormRuleAltList[{#L}%ruleAltList⟨ #labeledAlt #ruleAltList_S1* ⟩] →
    {#L}%ruleAltList⟨ 
        ⟨labeledAlt: {#E; "@alt":NUM[1]; "@unique": BOOL[IsEmpty[#ruleAltList_S1*]]}NormLabeledAlt[#labeledAlt]⟩
        ⟨ruleAltList_S1*: {#E; "@alt":NUM[2]; "@unique": BOOL[FALSE]}NormRuleAltList_S1s[#ruleAltList_S1*] ⟩
    ⟩;

//
{#E}
NormRuleAltList_S1s[{#L}%ruleAltList_S1*⟨⟩] →{#L}%ruleAltList_S1*⟨⟩;

{#E; "@alt":NUM[#count]}
NormRuleAltList_S1s[{#L}%ruleAltList_S1*⟨ | #labeledAlt #ruleAltList_S1*⟩] →
    {#L}%ruleAltList_S1*⟨ 
        | ⟨labeledAlt: {#E}NormLabeledAlt[#labeledAlt]⟩ 
        ⟨ruleAltList_S1*: {#E; "@alt":NUM[$[Plus, #count, 1]]}NormRuleAltList_S1s[#ruleAltList_S1*] ⟩ 
    ⟩;

//
{#E}
NormLabeledAlt[{#L}%labeledAlt⟨ #alternative  #labeledAlt_S1?⟩] →
    {#L}%labeledAlt⟨ ⟨alternative: {#E}NormAlternative[#alternative]⟩ ⟩;

//
{#E}
NormAlternative[{#L}%alternative⟨ #elementOptions? #element* ⟩] →
    {#L}%alternative⟨ ⟨element*: {#E; "@sub":NUM[1]}NormElements[#element*] ⟩ ⟩;

//
{#E}
NormElements[{#L}%element*⟨⟩] → {#L}%element*⟨⟩;


//
//{#E}
//NormElements[{#L}%element*⟨ #labeledElement #element_A1_S1 #element*⟩] →
//    {#E}NormLabeledElement[#labeledElement, #element_A1_S1, #element*];
    
{#E}
NormElements[{#L}%element*⟨ #atom #element_A2_S1 #element*⟩] →
    {#L}%element*⟨ #atom #element_A2_S1 ⟨element*: {#E}NormElements[#element*]⟩ ⟩;


// This is a subrule -> generate an atom
{#E; "@sub": NUM[#count]}
NormElements[{#L}%element*⟨ #block #blockSuffix? #element* ⟩] →
    {#L}%element*⟨ 
        ⟨atom:    {#E}SubruleAtom⟩ ⟨element_A2_S1: {#E}SubruleSuffix[#blockSuffix?]⟩ 
        ⟨element*: {#E;"@sub": NUM[$[Plus, #count, 1]]}NormElements[#element*]⟩
    ⟩;

{#E}
NormElements[{#L}%element*⟨ #ACTION #QUESTION? #element*⟩] →
    {#E}NormElements[#element*];

//--------- Second Pass: Generate subrules

//
{#E}
NSR-RuleAltList[{#L}%ruleAltList⟨ #labeledAlt #ruleAltList_S1* ⟩] →
    {#L}%ruleAltList⟨ ⟨ruleAltList: Concat[
        {#E; "@alt":NUM[1]; "@unique": BOOL[IsEmpty[#ruleAltList_S1*]]}NSR-LabeledAlt[#labeledAlt],
        {#E; "@alt":NUM[2]; "@unique": BOOL[FALSE]}NSR-RuleAltList_S1s[#ruleAltList_S1*]] ⟩
    ⟩;

//
{#E}
NSR-RuleAltList_S1s[{#L}%ruleAltList_S1*⟨⟩] →{#L}%ruleAltList_S1*⟨⟩;

{#E; "@alt":NUM[#count]}
NSR-RuleAltList_S1s[{#L}%ruleAltList_S1*⟨ | #labeledAlt #ruleAltList_S1*⟩] →
    {#L}%ruleAltList_S1*⟨ ⟨ruleAltList_S1*: Concat[
        {#E}NSR-LabeledAlt[#labeledAlt],
        {#E; "@alt":NUM[$[Plus, #count, 1]]}NSR-RuleAltList_S1s[#ruleAltList_S1*]] ⟩
    ⟩;
//
{#E}
NSR-LabeledAlt[{#L}%labeledAlt⟨ #alternative #labeledAlt_S1?⟩] →
    {#E}NSR-Alternative[#alternative] ;

//
{#E}
NSR-Alternative[{#L}%alternative⟨ #elementOptions? #element*⟩] →
    {#E; "@sub":NUM[1]}NSR-Elements[#element*];

//
{#E}
NSR-Elements[{#L}%element*⟨⟩] → {#L}%element*⟨⟩;    

{#E}
NSR-Elements[{#L}%element*⟨ #labeledElement #element_A1_S1 #element*⟩] →
    {#E}NSR-LabeledElement[#labeledElement, #element_A1_S1, #element*];
    
{#E}
NSR-Elements[{#L}%element*⟨ #atom #element_A2_S1  #element*⟩] →
    {#E}NSR-Elements[#element*];

// This is a subrule -> generate new parser rule and recursively normalize.
{#E; "@sub": NUM[#count]}
NSR-Elements[{#L}%element*⟨ #block #blockSuffix? #element*⟩] →
    {#L}%element*⟨ ⟨element*: Concat[
        {#E}NormRuleSpec[{#L}%ruleSpec⟨ ⟨RULE_REF: {#E}SubruleRuleref⟩ : ⟨ruleBlock: Block2RuleBlock[#block]⟩ ; ⟩],
        {#E;"@sub": NUM[$[Plus, #count, 1]]}NSR-Elements[#element*]] ⟩
    ⟩;

{#E}
NSR-Elements[{#L}%element*⟨ #ACTION #QUESTION? #element*⟩] →
    {#E}NSR-Elements[#element*];

// Helpers

{#E}
SubruleAtom →  %atom⟨ ⟨RULE_REF: {#E}SubruleRuleref⟩ ⟩;

//
{#E; 
    "@rule": STRING[#rule]; "@sub": NUM[#subCount]; 
    "@alt":NUM[#altCount]; "@unique": BOOL[#unique]
}
SubruleRuleref →
    SubruleRuleref2[#rule, #altCount, #unique, #subCount]
;

SubruleRuleref2[#rule, #altCount, TRUE, #subCount] →
    $[:, #rule, "_S", $[FormatNumber, #subCount]]
;
    
SubruleRuleref2[#rule, #altCount, FALSE, #subCount] →
    $[:, #rule, "_A", $[FormatNumber, #altCount], "_S", $[FormatNumber, #subCount]]
;

//
SubruleSuffix[()] →
    ANTLR_element_A2_S1_A2
;

SubruleSuffix[({#L}ANTLR_blockSuffix[#ebnfSuffix];)] →
    {#L}ANTLR_element_A2_S1_A1[#ebnfSuffix]
;

//
Block2RuleBlock[{#L}ANTLR_block[#LPAREN, (), {#L2}ANTLR_altList[#alternative, #altList_S1*], #RPAREN]]
    → {#L}ANTLR_ruleBlock[{#L}ANTLR_ruleAltList[{#L}ANTLR_labeledAlt[#alternative, ()], AltList2RuleAltList[#altList_S1*]]]
;

AltList2RuleAltList[()] →
    ()
;

AltList2RuleAltList[({#L}ANTLR_altList_S1[#OR, #alternative]; #altList_S1*)] →
    ({#L}ANTLR_ruleAltList_S1[#OR, {#L}ANTLR_labeledAlt[#alternative, ()]]; AltList2RuleAltList[#altList_S1*])
;




)]
