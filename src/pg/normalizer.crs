/*
 * Copyright (c) 2015 IBM Corporation.
 * 
 * Normalize ANTLR v4 grammar as follows:
 *
 * - The following ANTLR constructs are stripped out:
 *   - options (might reconsider)
 *   - comments
 *   - tokens {}
 *   - actions as they might interfere with the meta rules. 
 * 
 * - In general subrules are promoted to top-level rules, for instance:
 *    
 *      A : ( B | C ) | D
 *      →   
 *      A    : A_S1 | D; 
 *      A_S1 : B | C;
 *
 * - Subrule containing only one production, after eliminating trivial elements, 
 *   are not promoted. Such subrules are called "trivial". For instance:
 *
 *      A : B (',' B)*  is not rewritten.
 * 
 */
Normalizer[(

$Lax;

$Use["std/core.crs"];
$Use["std/list.crs"];
$Use["pg/util.crs"];
$Use["pg/ANTLR.crs"];
$Use["pg/trivial.crs"];
$Use["pg/ANTLR.crs"];

/* API: Normalize the ANTLR grammar spec */
Normalize[ANTLR_grammarSpec_sort] :: ANTLR_grammarSpec_sort;
Normalize[#] → NormGrammarSpec[#];

NormalizePP[ANTLR_grammarSpec_sort] :: Text;
NormalizePP[#] → ANTLR_Print_grammarSpec[NormGrammarSpec[#]];


/* Normalize the ANTLR grammar spec */
NormGrammarSpec[{#L}%grammarSpec⟦ #DOC_COMMENT? #grammarType #id ; #prequelConstruct* #ruleSpec* #modeSpec* ⟧] 
→ 
{#L}%grammarSpec⟦ #grammarType #id ; #prequelConstruct* 
                  ⟨ruleSpec*: {"@id": STRING[UnwrapId[#id]]; "@index": IndexRules[#ruleSpec*]}NormRules[#ruleSpec*] ⟩ #modeSpec* ⟧;

/* Normalize prequel constructs */
// TODO: first need to update the meta antlr parser.
//NormPrequelConstructs[$List[ANTLR_prequelConstruct_sort]] :: $List[ANTLR_prequelConstruct_sort];
//
//NormPrequelConstructs[{#L}%prequelConstruct*⟨⟩]   
//→ 
//();
//
//NormPrequelConstructs[{#L}%prequelConstruct*⟨ #optionsSpec #prequelConstruct* ⟩] 
//→
//NormPrequelConstructs[#prequelConstruct*];
// 
//NormPrequelConstructs[{#L}%prequelConstruct*⟨ #delegateGrammars #prequelConstruct* ⟩] 
//→
//{#L}%prequelConstruct*⟨ #delegateGrammars ⟨prequelConstruct*: NormPrequelConstructs[#prequelConstruct*]⟩ ⟩;
//
//NormPrequelConstructs[{#L}%prequelConstruct*⟨ #tokensSpec #prequelConstruct*⟩] 
//→
//NormPrequelConstructs[#prequelConstruct*];
//
//NormPrequelConstructs[{#L}%prequelConstruct*⟨ #action #prequelConstruct*⟩] 
//→
//NormPrequelConstructs[#prequelConstruct*];

// Normalize rules specification
NormRules[ANTLR_rules_sort] :: ANTLR_rules_sort;
{#E}NormRules[()]                       → ();
{#E}NormRules[(#ruleSpec; #ruleSpec*)]  → Concat[{#E}NormRuleSpec[#ruleSpec], {#E}NormRules[#ruleSpec*]];

/*
 * Normalize parser rule.  
 *
 * Two passes are performed:
 * - the first pass replaces subrules by a reference to the new rule describing the subrule  
 * - the second pass creates new parser rules corresponding to the subrules.
 */ 
{#E}NormRuleSpec[{#L}%ruleSpec⟨ #DOC_COMMENT? #ruleModifiers? #RULE_REF #ARG_ACTION? #ruleReturns? #throwsSpec? #localsSpec? 
                                  #rulePrequel* : #ruleAltList ; #exceptionHandler* #finallyClause? ⟩] 
→
(
    {#L}%ruleSpec⟨ #RULE_REF : ⟨ruleAltList: {#E; "@rule":STRING[#RULE_REF]}NormRuleAltList[#ruleAltList]⟩ ; ⟩; // First pass
    {#E; "@rule":STRING[#RULE_REF]}NSR-RuleAltList[#ruleAltList]                                             // Second pass
);

{#E}NormRuleSpec[{#L}%ruleSpec⟨ #lexerRule ⟩] 
→ 
( {#L}%ruleSpec⟨ #lexerRule ⟩; );

//--------- First Pass: eliminate subrules

// Iterates over rule alternatives
{#E}NormRuleAltList[{#L}%ruleAltList⟨ #labeledAlt #ruleAltList_S1* ⟩] 
→
{#L}%ruleAltList⟨ 
        ⟨labeledAlt: {#E; "@alt":NUM[1]; "@unique": BOOL[IsEmpty[#ruleAltList_S1*]]}NormLabeledAlt[#labeledAlt]⟩
        ⟨ruleAltList_S1*: {#E; "@alt":NUM[2]; "@unique": BOOL[FALSE]}NormRuleAltList_S1s[#ruleAltList_S1*] ⟩
⟩;

//
{#E}NormRuleAltList_S1s[{#L}%ruleAltList_S1*⟨⟩] →{#L}%ruleAltList_S1*⟨⟩;

{#E; "@alt":NUM[#count]}
NormRuleAltList_S1s[{#L}%ruleAltList_S1*⟨ | #labeledAlt #ruleAltList_S1*⟩] 
→
{#L}%ruleAltList_S1*⟨ 
    | ⟨labeledAlt: {#E}NormLabeledAlt[#labeledAlt]⟩ 
    ⟨ruleAltList_S1*: {#E; "@alt":NUM[$[Plus, #count, 1]]}NormRuleAltList_S1s[#ruleAltList_S1*] ⟩ 
⟩;

// Normalize a labeled alternative. Ignore the label for now (TODO: could be used for better ADT value name)
{#E}NormLabeledAlt[{#L}%labeledAlt⟨ #alternative #labeledAlt_S1? ⟩] 
→
{#L}%labeledAlt⟨ ⟨alternative: {#E}NormAlternative[#alternative]⟩ ⟩;

// Normalize an alternative. 
// Keep element options intact as they specify either associativity or failed semantic predicate
{#E}NormAlternative[{#L}%alternative⟨ #elementOptions? #element* ⟩] 
→
{#L}%alternative⟨ #elementOptions? ⟨element*: {#E; "@sub":NUM[1]}NormElements[#element*] ⟩ ⟩;

// Iterate over alternative elements.
NormElements[$List[ANTLR_element_sort]] :: $List[ANTLR_element_sort];

// No more elements.
{#E}NormElements[{#L}%element*⟨⟩] → {#L}%element*⟨⟩;

// Labeled element optionally followed by an ebnfSuffix
// Labeled element are discarded  as the rule context is not accessible within crsx.
// so rewrite as a non-labeled element and recursively normalize.
{#E}NormElements[{#L}%element*⟨ #labeledElement #element_A1_S1 #element* ⟩] 
→
{#E}NormElements[{#L}%element*⟨ ⟨element: NormRemoveLabel[#labeledElement, #element_A1_S1]⟩ #element* ⟩];

// Element is an atom optionally followed by an ebnfSuffix. Leave it this way.
{#E}NormElements[{#L}%element*⟨ #atom #element_A2_S1 #element* ⟩] 
→
{#L}%element*⟨ #atom #element_A2_S1 ⟨element*: {#E}NormElements[#element*]⟩ ⟩;

// Ebnf
// This is a subrule -> lift only if it contains at least two non-constant productions
{#E; "@index": {#I}RULEINDEX}NormElements[{#L}%element*⟨ #block #blockSuffix? #element* ⟩] 
→
{#E}NormBlock[{#I}TrivialBlock[#block], #block, #blockSuffix?, #element*];

// Action or semantic predicate. Preserve it.
{#E}NormElements[{#L}%element*⟨ #ACTION #QUESTION? #element* ⟩] 
→
{#L}%element*⟨ #ACTION #QUESTION? ⟨element*: {#E}NormElements[#element*]⟩ ⟩;

// Normalize a block
NormBlock[Boolean, ANTLR_block_sort, $List[ANTLR_blockSuffix_sort], $List[ANTLR_element_sort]] :: List[ANTLR_element_sort];

// Trivial block: don't lift.
{#E}NormBlock[TRUE, {#L}#block, #blockSuffix?, #element*] 
→
{#L}%element*⟨ #block #blockSuffix? ⟨element*: {#E}NormElements[#element*]⟩ ⟩;

// Not trivial block: lift
{#E; "@sub":NUM[#count]}NormBlock[FALSE, {#L}#block, #blockSuffix?, #element*] 
→
{#L}%element*⟨ 
    ⟨atom:    {#E}SubruleAtom⟩ ⟨element_A2_S1: {#E}SubruleSuffix[#blockSuffix?]⟩ 
    ⟨element*: {#E;"@sub": NUM[$[Plus, #count, 1]]}NormElements[#element*]⟩
⟩;

// Eliminate label from element
NormRemoveElementLabel[ANTLR_labeledElement_sort, ANTLR_element_A2_S1_sort] :: ANTLR_element_sort;

NormRemoveElementLabel[{#L}%labeledElement⟨ #id #labeledElement_S1 #atom ⟩, %element_A2_S1⟨ ⟩] 
→
{#L}%element⟨ #atom ⟩;

NormRemoveElementLabel[{#L}%labeledElement⟨ #id #labeledElement_S1 #atom ⟩, %element_A2_S1⟨ #ebnfSuffix ⟩] 
→
{#L}%element⟨ #atom #ebnfSuffix ⟩;

NormRemoveElementLabel[{#L}%labeledElement⟨ #id #labeledElement_S1 #block ⟩, %element_A2_S1⟨ ⟩] 
→
{#L}%element⟨ #block ⟩;

NormRemoveElementLabel[{#L}%labeledElement⟨ #id #labeledElement_S1 #block ⟩, %element_A2_S1⟨ #ebnfSuffix ⟩] 
→
{#L}%element⟨ #block #ebnfSuffix ⟩;

//--------- Second Pass: Generate subrules

//
{#E}NSR-RuleAltList[{#L}%ruleAltList⟨ #labeledAlt #ruleAltList_S1* ⟩] 
→
{#L}%ruleAltList⟨ ⟨ruleAltList: Concat[
    {#E; "@alt":NUM[1]; "@unique": BOOL[IsEmpty[#ruleAltList_S1*]]}NSR-LabeledAlt[#labeledAlt],
    {#E; "@alt":NUM[2]; "@unique": BOOL[FALSE]}NSR-RuleAltList_S1s[#ruleAltList_S1*]] ⟩
⟩;

//
{#E}NSR-RuleAltList_S1s[{#L}%ruleAltList_S1*⟨⟩] → {#L}%ruleAltList_S1*⟨⟩;

{#E; "@alt":NUM[#count]}
NSR-RuleAltList_S1s[{#L}%ruleAltList_S1*⟨ | #labeledAlt #ruleAltList_S1*⟩] 
→
{#L}%ruleAltList_S1*⟨ ⟨ruleAltList_S1*: Concat[
    {#E}NSR-LabeledAlt[#labeledAlt],
    {#E; "@alt":NUM[$[Plus, #count, 1]]}NSR-RuleAltList_S1s[#ruleAltList_S1*]] ⟩
⟩;

//
{#E}NSR-LabeledAlt[{#L}%labeledAlt⟨ #alternative #labeledAlt_S1?⟩] 
→
{#E}NSR-Alternative[#alternative] ;

//
{#E}
NSR-Alternative[{#L}%alternative⟨ #elementOptions? #element*⟩] 
→
{#E; "@sub":NUM[1]}NSR-Elements[#element*];

//
{#E}NSR-Elements[{#L}%element*⟨⟩] → {#L}%element*⟨⟩;    

{#E}NSR-Elements[{#L}%element*⟨ #labeledElement #element_A1_S1 #element*⟩] 
→
{#E}NSR-LabeledElement[#labeledElement, #element_A1_S1, #element*];
    
{#E}NSR-Elements[{#L}%element*⟨ #atom #element_A2_S1  #element*⟩] 
→
{#E}NSR-Elements[#element*];

// This is a subrule -> generate new parser rule if non-trivial and recursively normalize
{#E; "@index": {#I}RULEINDEX}NSR-Elements[{#L}%element*⟨ #block #blockSuffix? #element*⟩] 
→
{#E}NSR-Block[{#I}TrivialBlock[#block], {#L}LOC, #block, #blockSuffix?, #element*];

{#E}NSR-Elements[{#L}%element*⟨ #ACTION #QUESTION? #element*⟩] 
→
{#E}NSR-Elements[#element*];

// Trivial block. Don't generate lifted rule
{#E}NSR-Block[TRUE, #LOC, #block, #blockSuffix?, #element*]
→
{#E}NSR-Elements[#element*];

// Non-Trivial block. Generate lifted rule
{#E; "@sub": NUM[#count]}
NSR-Block[FALSE, {#L}LOC, #block, #blockSuffix?, #element*]
→
{#L}%element*⟨ ⟨element*: Concat[
    {#E}NormRuleSpec[{#L}%ruleSpec⟨ ⟨RULE_REF: {#E}SubruleRuleref⟩ : ⟨ruleBlock: Block2RuleBlock[#block]⟩ ; ⟩],
    {#E;"@sub": NUM[$[Plus, #count, 1]]}NSR-Elements[#element*]] ⟩ ⟩;

// Helpers

{#E}SubruleAtom →  %atom⟨ ⟨RULE_REF: {#E}SubruleRuleref⟩ ⟩;

//
{#E; 
    "@rule": STRING[#rule]; "@sub": NUM[#subCount]; 
    "@alt":NUM[#altCount]; "@unique": BOOL[#unique]
}
SubruleRuleref 
→
SubruleRuleref2[#rule, #altCount, #unique, #subCount];

SubruleRuleref2[#rule, #altCount, TRUE, #subCount] 
→
$[:, #rule, "_S", $[FormatNumber, #subCount]];
    
SubruleRuleref2[#rule, #altCount, FALSE, #subCount] 
→
$[:, #rule, "_A", $[FormatNumber, #altCount], "_S", $[FormatNumber, #subCount]];

SubruleSuffix[$List[ANTLR_blockSuffix_sort]] :: ANTLR_element_A2_S1_sort;

//
SubruleSuffix[()] 
→
//%element⟨⟩; // TODO: update antlr meta parser
ANTLR_element_A2_S1_A2;

SubruleSuffix[({#L}ANTLR_blockSuffix[#ebnfSuffix];)] 
→
{#L}%element_A2_S1⟦ #ebnfSuffix ⟧;

//
Block2RuleBlock[{#L}ANTLR_block[#LPAREN, (), {#L2}ANTLR_altList[#alternative, #altList_S1*], #RPAREN]]
→
//{#L}%ruleBlock⟨ #alternative #altList_S1* ⟩; 
{#L}ANTLR_ruleBlock[{#L}ANTLR_ruleAltList[{#L}ANTLR_labeledAlt[#alternative, ()], AltList2RuleAltList[#altList_S1*]]];

AltList2RuleAltList[()] 
→
();

AltList2RuleAltList[({#L}ANTLR_altList_S1[#OR, #alternative]; #altList_S1*)] 
→
({#L}ANTLR_ruleAltList_S1[#OR, {#L}ANTLR_labeledAlt[#alternative, ()]]; AltList2RuleAltList[#altList_S1*]);

)]
