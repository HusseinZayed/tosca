/*
 * CRSX Parser generator.
 * 
 * It takes a normalized PG grammar and produces an annotated PG grammar for producing terms and meta-terms.
 * 
 * Each annotation corresponds to an action.
 *
 * Naming convention
 * -----------------
 *
 *    RuleRef     → (MODNAME_)?RuleRef  
 *    
 *    TODO: change _ to be $
 *
 * Single Alternative
 * ------------------
 * 
 *     rule : R1  →  rule : {_enterAlt(");} R1 {_exitAlt();} 
 *
 * Multiple Alternatives
 * ---------------------
 * 
 *     rule : R1 | ... | RN 
 *     →
 *     rule : {_enterAlt("1");} R1 {_exitAlt();} | ... | {_enterAlt("N");} RN {_exitAlt();} 
 * 
 * Quantifiers
 * -----------
 * 
 *     rule : R1   → rule : R1
 *     rule : R1*  → rule : {_enterZOM();} R1* {_exitZOM();}
 *     rule : R1+  → rule : {_enterOOM();} R1+ {_exitOOM();}
 *     rule : R1?  → rule : {_enterOPT();} R1? {_exitOPT();}  
 *
 * Meta Parser
 * -----------
 *
 * The meta parser is generated as follows.
 *
 * For each rule, there is a corresponding EOF rule.
 *
 *     rule      : ... ;
 *     rule_EOF  : rule EOF;
 * 
 * For each rule, there are two additional alternatives: meta and embed.
 * 
 * For each quantified production, a new rule is created as follows:
 *
 *     rule : R1*  
 *     → 
 *     rule : R1_ZOM
 *     rule_ZOM : {enterZOM();} R1* {({tail();} ({term();} MT_RULE_ZOM | {embed();} ET_RULE_ZOM EMBED_END))? exitZOM();}  
 *
 * where tail capture the rest of a list.
 *
 */
MakeParser[(

$Lax;

$Use["pg/ANTLR.crs"];
$Use["pg/util.crs"];
$Use["std/function.crs"];
$Use["std/list.crs"];

Mode ::= ( 
    PARSER;     /* Generate term parser and lexer */ 
    METAPARSER; /* Generate meta parser */ 
    METALEXER;  /* Generate meta lexer */ 
);

MakeParser[ANTLR_grammarSpec_sort] :: ANTLR_grammarSpec_sort;
MakeParser[#] → ANTLR_Print_grammarSpec[MakeGrammarSpec[#, PARSER]];

MakeMetaParser[ANTLR_grammarSpec_sort] :: ANTLR_grammarSpec_sort;
MakeMetaParser[#] → ANTLR_Print_grammarSpec[MakeGrammarSpec[#, METAPARSER]];

MakeMetaLexer[ANTLR_grammarSpec_sort] :: ANTLR_grammarSpec_sort;
MakeMetaLexer[#] → ANTLR_Print_grammarSpec[MakeGrammarSpec[#, METALEXER]];

// grammar ...

MakeGrammarSpec[ANTLR_grammarSpec_sort, Mode] :: ANTLR_grammarSpec_sort;

MakeGrammarSpec[{#L}%grammarSpec⟨ #DOC_COMMENT? #grammarType #id ; #prequelConstruct* #rules #modeSpec* ⟩, #mode] → 
    {#L}%grammarSpec⟨ #DOC_COMMENT? ⟨grammarType: MakeGrammarType[#grammarType, #mode]⟩ ⟨id: MakeGrammarId[#id, #mode]⟩ ; 
                      ⟨prequelConstruct*: MakePrequelConstructs[#mode, UnwrapId[#id]]⟩ 
                      ⟨rules: MakeRules[ApplyIf[#rules, IsMeta[#mode], x.LiftEbnfRules[x]], #mode]⟩ 
                      ⟨modeSpec*: MakeModeSpec[#modeSpec*, #mode]⟩ ⟩;

MakeGrammarType[ANTLR_grammarType_sort, Mode] :: ANTLR_grammarType_sort;

MakeGrammarType[#grammarType, PARSER]       → #grammarType;
MakeGrammarType[#grammarType, METAPARSER]   → %grammarType⟨ parser grammar ⟩;
MakeGrammarType[#grammarType, METALEXER]    → %grammarType⟨ lexer grammar ⟩;

MakeGrammarId[ANTLR_id_sort, Mode] :: ANTLR_id_sort;

MakeGrammarId[{#L}%id⟨ #TOKEN_REF ⟩, PARSER]     →  {#L}%id⟨ ⟨TOKEN_REF:  $[:, #TOKEN_REF,  "Term"] ⟩ ⟩; 
MakeGrammarId[{#L}%id⟨ #TOKEN_REF ⟩, METAPARSER] →  {#L}%id⟨ ⟨TOKEN_REF:  $[:, #TOKEN_REF,  "MetaParser"] ⟩ ⟩; 
MakeGrammarId[{#L}%id⟨ #TOKEN_REF ⟩, METALEXER]  →  {#L}%id⟨ ⟨TOKEN_REF:  $[:, #TOKEN_REF,  "MetaLexer"] ⟩ ⟩; 

// Add target language dependent actions. 
MakePrequelConstructs[Mode, $String] :: $List[ANTLR_prequelConstruct];
MakePrequelConstructs[#mode, #id] → 
    Concat[LexerVocab[#mode, #id], ParserConstructs[#id, IsParser[#mode], IsMeta[#mode]]];

LexerVocab[Mode, $String] :: $List[ANTLR_prequelConstruct];

LexerVocab[PARSER, #id]      → ();
LexerVocab[METALEXER, #id]   → ();
LexerVocab[METAPARSER, #id]  → %prequelConstruct*⟨ options { tokenVocab = ⟨STRING_LITERAL: $[:, #id, "MetaLexer"]⟩ ; } ⟩;

ParserConstructs[$String, $Boolean, $Boolean] :: $List[ANTLR_prequelConstruct];

ParserConstructs[#id, $False, #meta]    → ();

// TODO: string concatenation is quite ugly. CRSX should support string template!
ParserConstructs[#id, $True, #meta]     →
    %prequelConstruct*⟨
        @header ⟨ACTION: $[:, "{\n",
             "import org.crsx.pg.SinkAntlrListener;\n",
             "import static org.crsx.pg.SinkAntlrListener.fireEnterZOM;\n",
             "import static org.crsx.pg.SinkAntlrListener.fireExitZOM;\n",
             "import static org.crsx.pg.SinkAntlrListener.fireEnterOPT;\n",
             "import static org.crsx.pg.SinkAntlrListener.fireExitOPT;\n",
             "import static org.crsx.pg.SinkAntlrListener.fireEnterAlt;\n",
             "import static org.crsx.pg.SinkAntlrListener.fireExitAlt;\n",
             "import static org.crsx.pg.SinkAntlrListener.fireHide;\n",
             $[If, #meta, "import static org.crsx.pg.SinkAntlrListener.fireTail;\n", ""],
             $[If, #meta, "import static org.crsx.pg.SinkAntlrListener.fireTerm;\n", ""],
             $[If, #meta, "import static org.crsx.pg.SinkAntlrListener.fireEmbed;\n", ""],
        "}"]⟩
        
        @parser::members ⟨ACTION: $[:, "{\n",
            $[If, #meta, $[:, "public ", #id, "MetaParser() {}\n"], ""],
            $[If, #meta, "protected Lexer newLexer(CharStream stream)\n", ""],
            $[If, #meta, "{\n\n", ""],
            $[If, #meta, $[:, "return new ", #id, "MetaLexer(stream);\n"], ""],
            $[If, #meta, "}\n\n", ""],
            $[If, #meta, "protected void initATN()\n{    _interp = new ParserATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache);\n}", ""],
            "protected String _prefix() { return \"", #id, "_\"; }\n",
            "protected void _enterZOM() { fireEnterZOM(_parseListeners, _ctx); }\n",
            "protected void _exitZOM()  { fireExitZOM(_parseListeners, _ctx); }\n",
            "protected void _enterOOM() { _enterZOM(); }\n",
            "protected void _exitOOM()  { _exitZOM(); }\n",
            "protected void _enterOPT() { fireEnterOPT(_parseListeners, _ctx); }\n",
            "protected void _exitOPT()  { fireExitOPT(_parseListeners, _ctx); }\n",
            "protected void _enterAlt(String name) { fireEnterAlt(_parseListeners, _ctx, name); }\n",
            "protected void _enterAlt() { fireEnterAlt(_parseListeners, _ctx); }\n",
            "protected void _exitAlt()  { fireExitAlt(_parseListeners, _ctx); }\n",
            "protected void _hide()     { fireHide(_parseListeners, _ctx); }\n",
            $[If, #meta, "protected void _embed()    { fireEmbed(_parseListeners, _ctx); }\n", ""],
            $[If, #meta, "protected void _tail()     { fireTail(_parseListeners, _ctx); }\n", ""],
            $[If, #meta, "protected void _term()     { fireTerm(_parseListeners, _ctx); }\n", ""],
            
        "}"]⟩
    ⟩;

MakeModeSpec[$List[ANTLR_modeSpec_sort], Mode] :: $List[ANTLR_modeSpec_sort];

MakeModeSpec[#modeSpec*, PARSER]        → #modeSpec*;
MakeModeSpec[#modeSpec*, METAPARSER]    → #modeSpec*;
MakeModeSpec[#modeSpec*, METALEXER]     → 
    Concat[
        %modeSpec*⟨
            mode Embed;
            
            EMBED_END           : END_EMBED_CHAR            -> popMode;
            EMBED_NESTED        : START_EMBED_CHAR          -> pushMode(NestedEmbed), more;
            EMBEDDED            : .                         -> more;
                    
            mode NestedEmbed;    
        
            NESTED_EMBED_END    : END_EMBED_CHAR            -> popMode, more;
            NESTED_EMBED_NESTED : START_EMBED_CHAR          -> pushMode(NestedEmbed), more;
            NESTED_EMBEDDED     : .                         -> more;
        ⟩,
        #modeSpec*
    ];
// TODO: ANTLR Meta parser to support ModeSpec tail


// 
MakeRules[ANTLR_rules_sort, Mode] :: $List[ANTLR_rules_sort];
MakeRules[{#L}%rules⟨ #ruleSpec* ⟩, #mode] → {#L}%rules⟨ ⟨ruleSpec*: MakeRuleSpecs[#ruleSpec*, #mode]⟩ ⟩;

// 
MakeRuleSpecs[$List[ANTLR_ruleSpec_sort], Mode] :: $List[ANTLR_ruleSpec_sort];

// TODO: special characters should be configurable.

MakeRuleSpecs[(), PARSER]       → ();
MakeRuleSpecs[(), METAPARSER]   → ();
MakeRuleSpecs[(), METALEXER]    → 
    %ruleSpec* ⟨
        fragment META_CHAR        : '#'; 
        fragment START_EMBED_CHAR : '⟨';  
        fragment END_EMBED_CHAR   : '⟩';  
    ⟩;

MakeRuleSpecs[(#ruleSpec; #ruleSpec*), #mode]  → Concat[MakeRuleSpec[#ruleSpec, #mode], MakeRuleSpecs[#ruleSpec*, #mode]];

//
MakeRuleSpec[ANTLR_ruleSpec_sort, Mode] :: $List[ANTLR_ruleSpec_sort];

// Parser rule
// RuleRef : RuleBlock ;
MakeRuleSpec[{#L}%ruleSpec⟨ #RULE_REF : #ruleBlock ; ⟩, #mode] →
    Concat[MakeRuleSpec2[IsParser[#mode], #RULE_REF, #ruleBlock, #mode], MakeMetaRules[#mode, #RULE_REF, ToMeta[#RULE_REF]]];

// Lexer rule
MakeRuleSpec[{#L}%ruleSpec⟨ #FRAGMENT? #TOKEN_REF : #lexerRuleBlock ; ⟩, #mode] →
    $[If, $[Equal, #mode, METAPARSER], (), ({#L}%ruleSpec⟨ #FRAGMENT? #TOKEN_REF : #lexerRuleBlock ; ⟩;)];


// Decide to annotate or filter rule based on mode
MakeRuleSpec2[$String, ANTLR_ruleBlock_sort, Mode] :: $List[ANTLR_ruleSpec_sort];

MakeRuleSpec2[$False, #RULE_REF, #ruleBlock, #mode]  → ();
MakeRuleSpec2[$True, #RULE_REF, #ruleBlock, #mode]   → (%ruleSpec⟨ #RULE_REF : ⟨ruleBlock: MakeRuleBlock[#ruleBlock, #RULE_REF, #mode]⟩ ; ⟩;);
//MakeRuleSpec2[$True, $True, #RULE_REF, #ruleBlock, #mode]       → (%ruleSpec⟨ #RULE_REF : #ruleBlock ; ⟩;);


//----- Parser Rule Block

//
MakeRuleBlock[ANTLR_ruleBlock_sort, $String, Mode] :: ANTLR_ruleBlock_sort;
MakeRuleBlock[{#L}%ruleBlock⟨ #ruleAltList ⟩, #RULE_REF, #mode] → {#L}%ruleBlock⟨ ⟨ruleAltList: MakeRuleAltList[#ruleAltList, #RULE_REF, #mode] ⟩ ⟩;

//
MakeRuleAltList[ANTLR_ruleAltList_sort, $String, Mode] :: ANTLR_ruleAltList_sort;
MakeRuleAltList[{#L}%ruleAltList⟨ #alternative #ruleAltList_S1* ⟩, #RULE_REF, #mode] →
    {#L}%ruleAltList⟨ ⟨alternative: MakeAlternative[#alternative, IsEmpty[#ruleAltList_S1*], 1, #RULE_REF, IsMeta[#mode]]⟩ ⟨ruleAltList_S1*: Concat[MakeRuleAltList_S1s[#ruleAltList_S1*, 2, #RULE_REF, IsMeta[#mode]], MakeMetaAltList[#RULE_REF, #mode]]⟩ ⟩; ;

//
MakeRuleAltList_S1s[$List[ANTLR_ruleAltList_S1_sort], $Numeric, $String, $Boolean /* Meta parser? */] :: $List[ANTLR_ruleAltList_S1_sort];

MakeRuleAltList_S1s[{#L}%ruleAltList_S1*⟨⟩, #Count, #RULE_REF, #meta] → {#L}%ruleAltList_S1*⟨⟩;
MakeRuleAltList_S1s[{#L}%ruleAltList_S1*⟨ | #alternative #ruleAltList_S1* ⟩, #Count, #RULE_REF, #meta] →
    {#L}%ruleAltList_S1*⟨ | ⟨alternative: MakeAlternative[#alternative, FALSE, #Count, #RULE_REF, #meta]⟩ ⟨ruleAltList_S1*: MakeRuleAltList_S1s[#ruleAltList_S1*, $[Plus, #Count, 1], #RULE_REF, #meta]⟩ ⟩
;

//
MakeAlternative[ANTLR_alternative_sort, $Boolean, $Numeric, $String, $Boolean /* Meta parser? */] :: ANTLR_alternative_sort;
MakeAlternative[{#L}%alternative⟨ #element* ⟩, #Unique, #Count, #RULE_REF, #meta] →
    {#L}%alternative⟨ ⟨element: MakeEnterAltAction[#Unique, #Count, IsInternalRule[#RULE_REF]]⟩ ⟨element*: MakeElements[#element*, #RULE_REF, #meta]⟩ ⟩
;

// 
MakeElements[$List[ANTLR_element_sort], $String, $Boolean /* Meta parser? */] :: $List[ANTLR_element_sort];
MakeElements[{#L}%element*⟨⟩, #RULE_REF, #meta]                     → {#L}%element*⟨ ⟨element:  MakeExitAltAction[IsInternalRule[#RULE_REF]]⟩ ⟩;
MakeElements[{#L}%element*⟨ #element #element* ⟩, #RULE_REF, #meta] → {#L}%element*⟨ ⟨element*: Concat[MakeElement[#element, #RULE_REF, #meta], MakeElements[#element*, #RULE_REF, #meta]] ⟩ ⟩;

//
MakeElement[ANTLR_element_sort, $String, $Boolean /* Meta parser? */] :: $List[ANTLR_element_sort];
MakeElement[{#L}%element⟨ #atom #ebnfSuffix ⟩, #RULE_REF, #meta]  → WrapElement[{#L}%element⟨ #atom #ebnfSuffix ⟩, #ebnfSuffix, #RULE_REF, #meta];
MakeElement[{#L}%element⟨ #atom ⟩, #RULE_REF, #meta]              → {#L}%element*⟨ #atom ⟩;
;

// Wrap element with action depending on its attached EBNF suffix
WrapElement[ANTLR_element_sort, ANTLR_ebnfSuffix_sort, $String, $Boolean /* Meta parser? */] :: $List[ANTLR_element_sort];

WrapElement[{#L}#element, %ebnfSuffix⟨ ? ⟩, #RULE_REF, #meta] → Concat[{#L}%element*⟨ {_enterOPT();} #element ⟩, Concat[MakeTail[#RULE_REF, #meta], {#L}%element*⟨ {_exitOPT();} ⟩]] ;
WrapElement[{#L}#element, %ebnfSuffix⟨ * ⟩, #RULE_REF, #meta] → Concat[{#L}%element*⟨ {_enterZOM();} #element ⟩, Concat[MakeTail[#RULE_REF, #meta], {#L}%element*⟨ {_exitZOM();} ⟩]] ;
WrapElement[{#L}#element, %ebnfSuffix⟨ + ⟩, #RULE_REF, #meta] → Concat[{#L}%element*⟨ {_enterOOM();} #element ⟩, Concat[MakeTail[#RULE_REF, #meta], {#L}%element*⟨ {_exitOOM();} ⟩]] ;

// Produce grammar to match/contract a sequence tail.
MakeTail[$String, $Boolean] :: $List[ANTLR_element_sort];

MakeTail[#RULE_REF, $False]    → %element*⟨ ⟩;
MakeTail[#RULE_REF, $True]     → %element*⟨ ({_tail();} ({_term();} ⟨TOKEN_REF: $[:, "MT_", #RULE_REF]⟩ | {_embed();} ⟨TOKEN_REF: $[:, "ET_", #RULE_REF]⟩ EMBED_END))? ⟩;

// ({tail();} ({term();} MT_ELEMENT_ZOM | {embed();} ET_ELEMENT_ZOM EMBED_END))?

// Some utilities

// Make the "enterAlt" action. If only 1 alternative, command takes no alternative number.
MakeEnterAltAction[#Unique, #Count, $True]                    → %element⟨ {} ⟩;
MakeEnterAltAction[TRUE /* Unique */, #Count, $False]         → %element⟨ {_enterAlt();} ⟩;
MakeEnterAltAction[FALSE /* Not Unique */, #Count, $False]    → %element⟨ ⟨ACTION: $[:, "{_enterAlt(\"", $[FormatNumber, #Count], "\");}"]⟩ ⟩;

// Make the "exitAlt" action
MakeExitAltAction[$False] → %element⟨ {_exitAlt();} ⟩;
MakeExitAltAction[$True]  → %element⟨ {} ⟩;
   
//----- Generate the _EOF rules.

MakeMetaRules[Mode, $String /* RULE_REF */, $String /* Resolved rule ref */] :: $List[ANTLR_ruleSpec_sort];

MakeMetaRules[PARSER, #RULE_REF, #resolved]        → ();

MakeMetaRules[METAPARSER, #RULE_REF, #resolved]    →
    (
        %ruleSpec⟨ ⟨RULE_REF: $[:, #RULE_REF, "_EOF"]⟩ : #RULE_REF EOF ; ⟩; 
    );

MakeMetaRules[METALEXER, #RULE_REF, #resolved]     →    
    ( 
        %ruleSpec⟨ ⟨TOKEN_REF: $[:, "MT_", #RULE_REF]⟩  : META_CHAR ⟨STRING_LITERAL: $[:, "'", #resolved, "'"]⟩[0-9]* ; ⟩;
        %ruleSpec⟨ ⟨TOKEN_REF: $[:, "ET_", #RULE_REF]⟩  : START_EMBED_CHAR ⟨STRING_LITERAL: $[:, "'", #resolved, ":'"]⟩  -> pushMode(Embed); ⟩;
    );

//----- Generate additional alternatives, for META and EMBED. Only for meta paresr

MakeMetaAltList[$String, Mode] :: $List[ANTLR_ruleAltList_S1_sort];

MakeMetaAltList[#RULE_REF, PARSER]      → ();
MakeMetaAltList[#RULE_REF, METALEXER]   → ();

MakeMetaAltList[#RULE_REF, METAPARSER]  
→
%ruleAltList_S1*⟨ | {_term();} ⟨TOKEN_REF: $[:, "MT_", #RULE_REF]⟩ | {_embed();} ⟨TOKEN_REF: $[:, "ET_", #RULE_REF]⟩ EMBED_END ⟩; 

// 
// LiftEbnfRules
//
// Elements with ebnf suffix are promoted to top-level rules, for instance:
// 
//      A     : B C*
//      →
//      A     : B C_ZOM
//      C_ZOM : C*
//
// In addition, tokens are replaced by a grammar rule producing the token, to allow META and EMBED on tokens.
// 
// It's done in two passes, the first one rewrite the first rule, and the second one generate the new rules.
//
// Only called when generating the meta-parser.
//  

{#E}LiftEbnfRules[{#L}%rules⟨ #ruleSpec* ⟩] → {#L}%rules⟨ ⟨ruleSpec*: {#E}LiftEbnfRuleSpecs[OK, #ruleSpec*, ok.$Nil]⟩ ⟩;

//
{#E}LiftEbnfRuleSpecs[OK, (), ok.#[ok]]                       → {#E}#[OK];
{#E}LiftEbnfRuleSpecs[OK, (#ruleSpec; #ruleSpec*), ok.#[ok]]  → {#E}LiftEbnfRuleSpec[#ruleSpec, ok.LiftEbnfRuleSpecs[ok, #ruleSpec*, ok.#[ok]]];

{#E}LiftEbnfRuleSpec[{#L}%ruleSpec⟨ #RULE_REF : #ruleAltList ; ⟩, ok.#[ok]] →
    (
        {#L}%ruleSpec⟨ #RULE_REF : ⟨ruleAltList: {#E}LiftEbnfRuleAltList[#ruleAltList]⟩ ; ⟩;   // First pass
        {#E}MakeEbnfRuleAltList[#ruleAltList, ok.#[ok]]                                      // Second pass
    );

{#E}LiftEbnfRuleSpec[{#L}%ruleSpec⟨ #lexerRule ⟩, ok.#[ok]] → ( {#L}%ruleSpec⟨ #lexerRule ⟩; {#E}#[OK]);

// --- First Pass: rewrite the original rule.

//
{#E}LiftEbnfRuleAltList[{#L}%ruleAltList⟨ #element* #ruleAltList_S1* ⟩] →
    {#L}%ruleAltList⟨ 
        ⟨element*:        {#E}LiftEbnfElements[#element*]⟩
        ⟨ruleAltList_S1*: {#E}LiftEbnfRuleAltList_S1s[#ruleAltList_S1*] ⟩
    ⟩;

//
{#E}LiftEbnfRuleAltList_S1s[{#L}%ruleAltList_S1*⟨⟩] → {#L}%ruleAltList_S1*⟨⟩;

{#E}LiftEbnfRuleAltList_S1s[{#L}%ruleAltList_S1*⟨ | #element* #ruleAltList_S1*⟩] →
    {#L}%ruleAltList_S1*⟨ 
        | ⟨element*: {#E}LiftEbnfElements[#element*]⟩ 
        ⟨ruleAltList_S1*: {#E}LiftEbnfRuleAltList_S1s[#ruleAltList_S1*] ⟩ 
    ⟩;

//
{#E}LiftEbnfElements[{#L}%element*⟨⟩]                                  → {#L}%element*⟨⟩;
{#E}LiftEbnfElements[{#L}%element*⟨ #RULE_REF #element* ⟩]             → {#L}%element*⟨ #RULE_REF ⟨element*: {#E}LiftEbnfElements[#element*]⟩ ⟩;

{#E}LiftEbnfElements[{#L}%element*⟨ #RULE_REF #ebnfSuffix #element* ⟩] 
→ 
{#L}%element*⟨ ⟨RULE_REF: EbnfEBNFRuleRef[#RULE_REF, #ebnfSuffix]⟩ ⟨element*: {#E}LiftEbnfElements[#element*]⟩ ⟩;

{#E}LiftEbnfElements[{#L}%element*⟨ #TOKEN_REF #element* ⟩] 
→ 
{#L}%element*⟨ ⟨RULE_REF: TokenToRuleName[#TOKEN_REF]⟩ ⟨element*: {#E}LiftEbnfElements[#element*]⟩ ⟩;

{#E}LiftEbnfElements[{#L}%element*⟨ #TOKEN_REF #ebnfSuffix #element* ⟩] 
→ 
{#L}%element*⟨ ⟨RULE_REF: TokenToRuleName[#TOKEN_REF]⟩ ⟨element*: {#E}LiftEbnfElements[#element*]⟩ ⟩;


// --- Second  Pass: Generate new rules

//
{#E}MakeEbnfRuleAltList[{#L}%ruleAltList⟨ #element* #ruleAltList_S1* ⟩, ok.#[ok]] 
→
{#E}MakeEbnfElements[#element*, ok.MakeEbnfRuleAltList_S1s[ok, #ruleAltList_S1*, ok.#[ok]]];

//
{#E}MakeEbnfRuleAltList_S1s[OK, {#L}%ruleAltList_S1*⟨⟩, ok.#[ok]] → {#E}#[OK];

{#E}MakeEbnfRuleAltList_S1s[OK, {#L}%ruleAltList_S1*⟨ | #element* #ruleAltList_S1* ⟩, ok.#[ok]] 
→
{#E}MakeEbnfElements[#element*, ok.MakeEbnfRuleAltList_S1s[ok, #ruleAltList_S1*, ok.#[ok]]];
    
//
{#E}MakeEbnfElements[{#L}%element*⟨⟩, ok.#[ok]]                                  → {#E}#[OK];
{#E}MakeEbnfElements[{#L}%element*⟨ #RULE_REF #element* ⟩, ok.#[ok]]             → {#E}MakeEbnfElements[#element*, ok.#[ok]];

{#E}MakeEbnfElements[{#L}%element*⟨ #RULE_REF #ebnfSuffix #element* ⟩, ok.#[ok]] 
→
{#E}MakeEbnfElements-Key[EbnfEBNFRuleRef[#RULE_REF, #ebnfSuffix], #RULE_REF, #ebnfSuffix, #element*, ok.#[ok]];

// TODO: should support ebnfSuffix
{#E}MakeEbnfElements[{#L}%element*⟨ #TOKEN_REF #element* ⟩, ok.#[ok]] 
→
{#E}MakeToken-Key[TokenToRuleName[#TOKEN_REF], #TOKEN_REF, #element*, ok.#[ok]];

{#E}MakeEbnfElements[{#L}%element*⟨ #TOKEN_REF #ebnfSuffix #element* ⟩, ok.#[ok]] 
→
{#E}MakeToken-Key[TokenToRuleName[#TOKEN_REF], #TOKEN_REF, #element*, ok.#[ok]];

//
-[Data[#key]]:
{#E}MakeEbnfElements-Key[#key, #RULE_REF, #ebnfSuffix, #element*, ok.#[ok]] 
→
$[{#E}IfDef, #key, 
    {#E}MakeEbnfElements[#element*, ok.#[ok]],
   (%ruleSpec⟨ ⟨RULE_REF: #key⟩ : #RULE_REF #ebnfSuffix ; ⟩ ; {#E; #key: DEFINED}MakeEbnfElements[#element*, ok.#[ok]])];

//
-[Data[#key]]:
{#E}MakeToken-Key[#key, #TOKEN_REF, #element*, ok.#[ok]] 
→
$[{#E}IfDef, #key, 
    {#E}MakeEbnfElements[#element*, ok.#[ok]],
   (%ruleSpec⟨ ⟨RULE_REF: #key⟩ : #TOKEN_REF ; ⟩ ; {#E; #key: DEFINED}MakeEbnfElements[#element*, ok.#[ok]])];

// -- Helpers

//
EbnfEBNFRuleRef[#ruleref, %ebnfSuffix⟨ * ⟩] → $[:, #ruleref, "_ZOM"];
EbnfEBNFRuleRef[#ruleref, %ebnfSuffix⟨ ? ⟩] → $[:, #ruleref, "_OPT"];
EbnfEBNFRuleRef[#ruleref, %ebnfSuffix⟨ + ⟩] → $[:, #ruleref, "_OOM"];  

// Convert token name to rule name.
TokenToRuleName[$String] :: $String;

TokenToRuleName[#token] → $[:, $[DownCase, #token], "_TOK"];

// Convert internal rule name to a string to be used for meta and category
ToMeta[$String] :: $String;

ToMeta[#RuleRef] →
    $[If, $[EndsWith, #RuleRef, "_OPT"], $[:, $[BeforeFirst, #RuleRef, "_OPT"], "?"],
    $[If, $[EndsWith, #RuleRef, "_ZOM"], $[:, $[BeforeFirst, #RuleRef, "_ZOM"], "*"],
    $[If, $[EndsWith, #RuleRef, "_OOM"], $[:, $[BeforeFirst, #RuleRef, "_OOM"], "+"],
    $[If, $[EndsWith, #RuleRef, "_TOK"], $[UpCase, $[BeforeFirst, #RuleRef, "_TOK"]],
    #RuleRef]]]];

// Whether mode is meta
IsMeta[Mode] :: $Boolean;

IsMeta[PARSER]      → $False;
IsMeta[METAPARSER]  → $True;
IsMeta[METALEXER]   → $True;

// Whether mode is parser
IsParser[Mode] :: $Boolean;

IsParser[PARSER]      → $True;
IsParser[METAPARSER]  → $True;
IsParser[METALEXER]   → $False;

// Whether mode is lexer 
IsLexer[Mode] :: $Boolean;

IsLexer[PARSER]      → $False;
IsLexer[METAPARSER]  → $False;
IsLexer[METALEXER]   → $True;


// Where the rule is internal.
IsInternalRule[$String] :: $Boolean;

IsInternalRule[#RuleRef] →
    $[If, $[EndsWith, #RuleRef, "_OPT"], $True,
    $[If, $[EndsWith, #RuleRef, "_ZOM"], $True,
    $[If, $[EndsWith, #RuleRef, "_OOM"], $True,
    $[If, $[EndsWith, #RuleRef, "_TOK"], $True,
    $False]]]];
)]