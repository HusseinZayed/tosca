// Copyright (c) 2015 IBM Corporation.
/*
 * Compilation state carried along passes
 */
State[(

$Lax;

$Use["std/core.crs"];
$Use["std/env.crs"];
$Use["std/list.crs"];

// --- A CRSX system composed of Modules

// Main module or sub-module
Mode ::= ( MAINMODULE; SUBMODULE; ); 

$StringEntry ::= (

    // Modules composing the system. List of keys in this environment.
    MODULES[$List[$String]];                                                  // keys: $modules, $notloaded, $normalized

    // A module composing the system
    MODULE[$String /* filename/module id */, Mode, Content];                  // key: $module$<filename>. 

);

// Compute the module key from the given filename
ModuleKey[$String] :: $String;
-[Data[#filename]]: ModuleKey[#filename]  → $[:, "$module$", #filename];

// Register module to compile. If module already registered, this does nothing. Add it to the $notloaded list
∀ a.{$String:$StringEntry}
AddModule[$String /* filename */, Boolean, ok¹::OK_SORT.$Sort[a]] :: a;
{#E}AddModule[#filename, #main, ok¹.#[ok¹]] → {#E}AddModuleKey[ModuleKey[#filename], #filename, #main, ok¹.#[ok¹]]; 

∀ a.{$String:$StringEntry}
AddModuleKey[$String, $String, Boolean, ok¹::OK_SORT.$Sort[a]] :: a;

-[Data[#key]]: 
{#E; "$modules":MODULES[#modules]; "$notloaded":MODULES[#notloaded]}
AddModuleKey[#key, #filename, #main, ok¹.#[ok¹]] 
→ 
$[{#E}IfDef, #key, 
    {#E}#[OK], 
    {#E}AddModuleKey2[#key, #filename, #main, Concat[#modules, (#key;)], Concat[#notloaded, (#key;)], ok¹.#[ok¹]]];

// Need this due to a bug in the crsx interpreter
∀ a.{$String:$StringEntry}
AddModuleKey2[$String, $String, Boolean, $List[$String], $List[$String], ok¹::OK_SORT.$Sort[a]] :: a;

-[Data[#modules, #notloaded]]: 
{#E}AddModuleKey2[#key, #filename, #main, #modules, #notloaded, ok¹.#[ok¹]] 
→
{#E; #key: MODULE[#filename, #main, NOTLOADED]; "$modules":MODULES[#modules]; "$notloaded":MODULES[#notloaded]}#[OK];

// --- A module

// Module content
{$String:ContentEntry}
Content ::= ( 

    // Module not loaded yet.
    NOTLOADED;      

    // Module has been fully loaded into ContentEntry 
    LOADED;       

    /*, STUB (might need a stub for fast compilation) */
);

ContentEntry ::= (

    // Entry in this environment
    KEYS[$List[$String]];                                           // keys: 
                                                                    // $rulekeys  : list of rule keys           ($rules$...)
                                                                    // $datakeys  : list of data sort keys      ($data$...)
                                                                    // $funckeys  : list of function sort keys  ($func$...)

    // Imported modules, as a list of filenames
    IMPORTS[$List[$String]];                                        // key: $imported

    // List of rules for a given constructor
    // Before normalization: might contains more than one rules
    // After normalization: only one rule
    RULES[$List[Crsx_ruleDeclaration_sort]];                        // key: $rules$<constructor>

    // Data sorts. Extensible. Also indexed by data forms constructor
    DATASORT[$List[QualifiedSort]];                                 // keys:$data$<sortname>, $form$<constructor>
    
    // Function sort. Unique.
    FUNCSORT[$String /* qualifier */, Crsx_sortDeclaration_sort];   // key: $func$<constructor>

    // form keys ($form$..), indexed by constructor. 
    // Many forms per constructor allowed but then required 
    // qualification 
    FORMKEYS[$List[$String]];                                       // keys: $form$<constructor>

    // General purpose string value
    STR[$String];
);

QualifiedSort ::= ( QSORT[$String /* Qualifier */, Crsx_sortDeclaration_sort]; );

// --- Sort utilities

UnDATASORT[ContentEntry] :: $List[QualifiedSort];
UnDATASORT[DATASORT[#]] → #;

UnFUNCSORT[ContentEntry] :: Crsx_sortDeclaration_sort;
UnFUNCSORT[FUNCSORT[#1, #]] → #;

UnRULES[ContentEntry] :: $List[Crsx_ruleDeclaration_sort];
UnRULES[RULES[#]] → #;

RulesKey[Crsx_constructor_sort] :: $String;
RulesKey[%constructor⟨ #CONSTRUCTOR ⟩] → $[:, "$rules$", #CONSTRUCTOR];
RulesKey[%constructor⟨ :            ⟩] → "$rules$:";

DataSortKey[Crsx_sortname_sort] :: $String;
DataSortKey[%sortname⟨ #CONSTRUCTOR #sortarguments? ⟩] → $[:, "$data$", #CONSTRUCTOR];
DataSortKey[%sortname⟨ :            #sortarguments? ⟩] → "$data$:";

DataFormKey[Crsx_constructor_sort] :: $String;
DataFormKey[%constructor⟨ #CONSTRUCTOR ⟩] → $[:, "$form$", #CONSTRUCTOR];
DataFormKey[%constructor⟨ :            ⟩] → "$form$:";

FuncSortKey[Crsx_constructor_sort] :: $String;
FuncSortKey[%constructor⟨ #CONSTRUCTOR ⟩] → $[:, "$func$", #CONSTRUCTOR];
FuncSortKey[%constructor⟨ :            ⟩] → "$func$:";

SortnameToString[Crsx_sortname_sort] :: $String;
SortnameToString[%sortname⟨ #CONSTRUCTOR #sortarguments? ⟩] → #CONSTRUCTOR;
SortnameToString[%sortname⟨ :            #sortarguments? ⟩] → ":";

ConstructorToString[Crsx_constructor_sort] :: $String;
ConstructorToString[%constructor⟨ #CONSTRUCTOR ⟩] → #CONSTRUCTOR;
ConstructorToString[%constructor⟨ :            ⟩] → ":";

// --- State lookup.

{$String:$StringEntry}LookupModule[$String] :: Option[Content];
{#E}LookupModule[#filename] → {#E}Get[ModuleKey[#filename]];

{$String:$ContentEntry}LookupSortByConstructor[Crsx_constructor_sort] :: Option[ContentEntry];
{#E}LookupSortByConstructor[#constructor] → LookupSortByConstructor1[{#E}Get[FuncSortKey[#constructor]], {#E}Get[DataFormKey[#constructor]]];

LookupSortByConstructor1[Option[ContentEntry]] :: Option[ContentEntry];
LookupSortByConstructor1[SOME[#1], #2] → SOME[#1];
LookupSortByConstructor1[NONE, #2]     → #2;

// --- State mutation.

∀ a.AddRule[$String, Crsx_ruleDeclaration_sort, ok¹::OK_SORT.$Sort[a]] :: $Sort[a];

-[Data[#key]]:
{#E}AddRule[#key, #ruleDeclaration, ok¹.#[ok¹]]
→
{#E}AddRule2[#key, #ruleDeclaration, ok¹.#[ok¹]];

∀ a.AddRule2[$String, Crsx_ruleDeclaration_sort, ok¹::OK_SORT.$Sort[a]] :: $Sort[a];

-[Data[#key]]:
{#E; #key: RULES[#rules]}
AddRule2[#key, #ruleDeclaration, ok¹.#[ok¹]]
→
{#E; #key: RULES[Concat[#rules, (#ruleDeclaration;)]]} // The lexical order must be preserved.
#[OK];

-[Data[#key]]:
{#E; ¬#key; "$rulekeys": KEYS[#keys]} 
AddRule2[#key, #ruleDeclaration, ok¹.#[ok¹]] 
→
{#E; #key: RULES[(#ruleDeclaration;)]; "$rulekeys": KEYS[(#key; #keys)]}
#[OK];

∀ a.{$String:$ContentEntry}
AddDataSort[Crsx_sortDeclaration_sort, ok¹::OK_SORT.$Sort[a]] :: $Sort[a];

{#E}AddDataSort[%sortDeclaration⟨ #sortparams? #sortset #sortname ::= ( #forms_S1* ) ⟩, ok¹.#[ok¹]]
→
{#E}AddDataSort1[DataSortKey[#sortname], %sortDeclaration⟨ #sortparams? #sortset #sortname ::= ( #forms_S1* ) ⟩, ok¹.
    SeqMap[form cont.AddDataForm[form, #sortname, %sortDeclaration⟨ #sortparams? #sortset #sortname ::= ( #forms_S1* ) ⟩, cont], #forms_S1*, ok¹.#[ok¹]]];

∀ a.AddDataSort1[$String, Crsx_sortDeclaration_sort, ok¹::OK_SORT.$Sort[a]] :: $Sort[a];

-[Data[#key]]:
{#E}AddDataSort1[#key, #sortDeclaration, ok¹.#[ok¹]]
→
{#E}AddDataSort2[#key, #sortDeclaration, ok¹.#[ok¹]];

∀ a.AddDataSort2[$String, Crsx_sortDeclaration_sort, ok¹::OK_SORT.$Sort[a]] :: $Sort[a];

-[Data[#key]]:
{#E; #key: DATASORT[#sorts]; "$qualifier": STR[#qualifier]}
AddDataSort2[#key, #sortDeclaration, ok¹.#[ok¹]]
→
{#E; #key: DATASORT[(QSORT[#qualifier, #sortDeclaration]; #sorts)]}  
#[OK];

-[Data[#key]]:
{#E; ¬#key; "$datakeys": KEYS[#keys]; "$qualifier": STR[#qualifier]}
AddDataSort2[#key, #sortDeclaration, ok¹.#[ok¹]]
→
{#E; #key: DATASORT[(QSORT[#qualifier, #sortDeclaration];)]; "$datakeys": KEYS[(#key; #keys)]}
#[OK];

∀ a.{$String:$ContentEntry}
AddDataForm[Crsx_forms_S1_sort, Crsx_sortname_sort, Crsx_sortDeclaration_sort, Continuation[a]] :: a;

{#E}AddDataForm[%forms_S1⟨ #constructor #arguments? ; ⟩, #sortname, #sortdecl, #CONTINUATION]
→
{#E}AddDataForm1[DataFormKey[#constructor], #constructor, #sortname, #sortdecl, #CONTINUATION];

∀ a.{$String:$ContentEntry}
AddDataForm1[$String, Crsx_constructor_sort, Crsx_sortname_sort, Crsx_sortDeclaration_sort, Continuation[a]] :: a;

-[Data[#key]]: 
{#E}AddDataForm1[#key, #constructor, #sortname, #sortdecl, #CONTINUATION]
→
{#E}AddDataForm2[#key, #constructor, #sortname, #sortdecl, #CONTINUATION];

∀ a.{$String:$ContentEntry}
AddDataForm2[$String, Crsx_constructor_sort, Crsx_sortname_sort, Crsx_sortDeclaration_sort, Continuation[a]] :: a;

-[Data[#key]]: 
{#E; #key: #exist}AddDataForm2[#key, %constructor⟨ #CONSTRUCTOR1 ⟩, %sortname⟨ #CONSTRUCTOR2 #sortarguments? ⟩, #sortdecl, #CONTINUATION]
→
$[Error, $[:, "Error: duplicate data form ", #CONSTRUCTOR1, " found in sort ", #CONSTRUCTOR2, "."]];
 
-[Data[#key]]: 
{#E; ¬#key; "$qualifier":STR[#qualifier]}
AddDataForm2[#key, #constructor, #sortname, #sortdecl, CONTINUATION[ok¹.#[ok¹]]]
→
{#E; #key: DATASORT[(QSORT[#qualifier, #sortdecl];)]}#[OK];

∀ a.AddFuncSort[$String, Crsx_sortDeclaration_sort, ok¹::OK_SORT.$Sort[a]] :: $Sort[a];

// Crsx Interpreter does not like fetching a env entry and data at the same time.
{#E}AddFuncSort[%sortDeclaration⟨ #sortparams? #sortset #constructor #arguments? :: #sortname ⟩, ok¹.#[ok¹]]
→
{#E}AddFuncSort1[FuncSortKey[#constructor], %sortDeclaration⟨ #sortparams? #sortset #constructor #arguments? :: #sortname ⟩, ok¹.#[ok¹]];

∀ a.AddFuncSort1[$String, Crsx_sortDeclaration_sort, ok¹::OK_SORT.$Sort[a]] :: $Sort[a];

-[Data[#key]]: 
{#E}AddFuncSort1[#key, #sortDeclaration, ok¹.#[ok¹]]
→
{#E}AddFuncSort2[#key, #sortDeclaration, ok¹.#[ok¹]];

∀ a.AddFuncSort2[$String, Crsx_sortDeclaration_sort, ok¹::OK_SORT.$Sort[a]] :: $Sort[a];

-[Data[#key]]:
{#E; #key: FUNCSORT[#qualifier, #sort]}
AddFuncSort2[#key, %sortDeclaration⟨ #sortparams? #sortset #constructor #arguments? :: #sortname  ⟩, ok¹.#[ok¹]]
→
$[Error, $[:, "Function sort already defined:", ConstructorToString[#constructor]]]; // TODO: locations, data 

-[Data[#key]]:
{#E; ¬#key; "$funckeys": KEYS[#keys]; "$qualifier" : STR[#qualifier]}
AddFuncSort2[#key, #sortDeclaration, ok¹.#[ok¹]] 
→
{#E; #key: FUNCSORT[#qualifier, #sortDeclaration]; "$funckeys": KEYS[(#key; #keys)]}
#[OK];

// --- Load CRSX into state.

// TODO: copy from normalizer.


// --- Convert state to CRSX (debugging only)

{$String:ContentEntry}
OutputCrsx[OK_SORT] :: Crsx_crsx_sort;

{#E; "$datakeys": KEYS[#keys]}OutputCrsx[OK] 
→
%crsx⟨ $Lax ⟨declarations_S1*: {#E}OutputDataDeclarations[#keys]⟩ ⟩;

{$String:ContentEntry}
OutputDeclarations[OK_SORT] :: Crsx_declarations_sort;

{#E; "$datakeys": KEYS[#keys]}OutputDeclarations[OK] 
→
%declarations⟨ $Lax ⟨declarations_S1*: {#E}OutputDataDeclarations[#keys]⟩ ⟩;

{$String:ContentEntry}
OutputDataDeclarations[$List[$String]] :: $List[Crsx_declarations_S1_sort];

{#E; "$funckeys": KEYS[#keys]}
OutputDataDeclarations[(           )] →  {#E}OutputFuncDeclarations[#keys];

{#E}OutputDataDeclarations[(#key; #keys)] 
→ 
{#E}OutputDataDeclarationsForKey[UnDATASORT[$[{#E}Get, #key]], #keys];

{$String:ContentEntry}
OutputDataDeclarationsForKey[$List[QualifiedSort], $List[$String]] :: $List[Crsx_declarations_S1_sort];

{#E}OutputDataDeclarationsForKey[(             ), #keys] 
→ 
{#E}OutputDataDeclarations[#keys];

{#E}OutputDataDeclarationsForKey[(QSORT[#qualifier, #sort]; #qsorts), #keys]
→ 
%declarations_S1*⟨ ; ⟨sortDeclaration: #sort⟩ ⟨declarations_S1*: {#E}OutputDataDeclarationsForKey[#qsorts, #keys]⟩ ⟩;

{$String:ContentEntry}
OutputFuncDeclarations[$List[$String]] :: $List[Crsx_declarations_S1_sort];

{#E; "$rulekeys": KEYS[#keys]}
OutputFuncDeclarations[()] →  {#E}OutputRuleDeclarations[#keys];

{#E}OutputFuncDeclarations[(#key; #keys)] 
→ 
{#E}OutputFuncDeclaration[UnFUNCSORT[$[{#E}Get, #key]], #keys];

{$String:ContentEntry}
OutputFuncDeclaration[Crsx_sortDeclaration_sort, $List[$String]] :: $List[Crsx_declarations_S1_sort];

{#E}OutputFuncDeclaration[#sort, #keys]
→ 
%declarations_S1*⟨ ; ⟨sortDeclaration: #sort⟩ ⟨declarations_S1*: {#E}OutputFuncDeclarations[#keys]⟩ ⟩;

{$String:ContentEntry}
OutputRuleDeclarations[$List[$String]] :: $List[Crsx_declarations_S1_sort];

{#E}OutputRuleDeclarations[(           )] → %declarations_S1*⟨ ⟩;

{#E}OutputRuleDeclarations[(#key; #keys)] 
→ 
{#E}OutputRuleDeclarationsForKey[UnRULES[$[{#E}Get, #key]], #keys];

{$String:ContentEntry}
OutputRuleDeclarationsForKey[$List[Crsx_ruleDeclaration_sort], $List[$String]] :: $List[Crsx_declarations_S1_sort];

{#E}OutputRuleDeclarationsForKey[(), #keys]
→ 
{#E}OutputRuleDeclarations[#keys];

{#E}OutputRuleDeclarationsForKey[(#rule; #rules), #keys]
→ 
%declarations_S1*⟨ ; ⟨ruleDeclaration: #rule⟩ ⟨declarations_S1*: {#E}OutputRuleDeclarationsForKey[#rules, #keys]⟩ ⟩;

)]