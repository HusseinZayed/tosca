/*
 * Copyright (c) 2015 IBM Corporation.
 *
 * @author : m schett
 * @date   : 08/18/2015
 */

TermOps[(

$Use["std/list.crs"];
$Use["std/string.crs"];

/* ***************************************************** */
/*  MISC                                                 */
/* ***************************************************** */

/* Lhs
   @param `rule` a rule declaration
   @return `lhs` the **term** `lhs` which is the left-hand side of the rule
*/
Lhs[Crsx_ruleDeclaration_sort] :: Crsx_term_sort;
Lhs[%ruleDeclaration⟦ ##option? ##constructor ##arguments? → ##contractum ⟧] 
→ 
%term⟦ ##constructor ##arguments? ⟧;


/* ***************************************************** */
/*  RENAMING                                             */
/* ***************************************************** */

/* Rename
   @param `suffix` a string, which serves as suffix for the meta variables
   @param `term`   a term in which the meta variables will be renamed
   @return `term'` in which all meta variables `#X` are renamed to
                   `#Xsuffix` 
   @throws error if it encounters a nested bound variable with the same name
           e.g., x.F[ x.G[x]]
   @note   prefixing with a $String did not work
 */
Rename[$String, Crsx_term_sort] :: Crsx_term_sort;
Rename[#suffix, #term] → RenameHelper[#suffix, (), #term];
  /* case: constructor */
  RenameHelper[$String, $List[Crsx_variable_sort], Crsx_term_sort] :: Crsx_term_sort;
  RenameHelper[#suffix, #BVs, 
               %term⟦ ##annotations? ##properties? ##constructor ##arguments? ⟧ ] 
  → 
  %term⟦ ##annotations? ##properties? ##constructor 
         ⟨arguments?: WrapArguments[Map[t.RenameHelper[#suffix, #BVs, t], UnwrapArguments[#arguments?]]] ⟩ ⟧ ;
  /* case: meta var */
  RenameHelper[#suffix, #BVs, 
               %term⟦ ##annotations? ##properties? ##METAVAR ##freeArguments? ⟧ ]
  → 
  %term⟦ ##annotations? ##properties? 
         ⟨METAVAR: ConcatString[#METAVAR,#suffix]⟩ 
         ⟨freeArguments?: WrapFreeArguments2[Map[t.RenameHelper[#suffix, #BVs, t], UnwrapFreeArguments[#freeArguments?]]] ⟩ ⟧ ;
  /* case: abstraction/binder */
  RenameHelper[#suffix, #BVs, %term⟦ ##variable ##nextBinder ⟧ ] 
  → 
  DetectNestedBinders[Elem[#variable, #BVs], #suffix, #BVs, #variable, UnwrapNextBinder[#nextBinder]];
    /* according to Nipkow93, Sec. 5, nested binders with the same name are a problem */
    DetectNestedBinders[Boolean, $String, $List[Crsx_variable_sort], Crsx_variable_sort, Crsx_term_sort] :: Crsx_term_sort;
    DetectNestedBinders[FALSE, #suffix, #BVs, #variable, #term] 
    → %term⟦ ##variable ⟨nextBinder: WrapNextBinder[RenameHelper[#suffix, Insert[#variable, #BVs], #term]] ⟩ ⟧ ;
    DetectNestedBinders[TRUE, #suffix, #BVs, #variable, #t] 
    → Error[ConcatString["Rename: The term contains nested abstractions, e.g., x.C[x.x]. The offending variable is: ", Show[#variable]] ]; 

  /* case: variable */
  RenameHelper[ #suffix, #BVs, %term⟦ ##annotations? ##variable ⟧ ] 
  → 
  %term⟦ ##annotations? ##variable ⟧ ;

/* RenameRule
   @param `suffix` a string, which serves as suffix for all meta variables
   @param `rule`   a rule in which the meta variables will be renamed
   @return `rule'` in which all meta variables `#X` are renamed to `#Xsuffix` 
   @note   see [Rename] 
 */
RenameRule[$String, Crsx_ruleDeclaration_sort] :: Crsx_ruleDeclaration_sort;
RenameRule[#suff, %ruleDeclaration⟦ ##option? ##pattern → ##contractum ⟧] 
→ %ruleDeclaration⟦ ##option? ⟨pattern: WrapPattern[Rename[#suff,UnwrapPattern[#pattern]]]⟩ 
                   → ⟨contractum: WrapContractum[Rename[#suff, UnwrapContractum[#contractum]]]⟩ ⟧;
 
/* RenameRules 
   @param  `rules`    a list of rules in which the meta variables will be renamed
   @return `rules'`  in which all meta variables `#X` are renamed to `#X_n`, whereby `n` in `1..Length[rules]`
   @note   see [RenameRule] 
 */
RenameRules[$List[Crsx_ruleDeclaration_sort]] :: $List[Crsx_ruleDeclaration_sort];
RenameRules[#rules] → RenameRulesHelper[1, #rules];
  RenameRulesHelper[$Numeric, $List[Crsx_ruleDeclaration_sort]] ::  $List[Crsx_ruleDeclaration_sort];
  RenameRulesHelper[#_, ()] → ();
  RenameRulesHelper[#n, (#r;#rules)] → Insert[ RenameRule[ConcatString["_", Show[#n]],#r], RenameRulesHelper[NumberPlus[#n,1], #rules]];



/* ***************************************************** */
/* Blue Print                                            */
/* ***************************************************** */

/* BluePrint
   @param `#sortDecl`  a sort declaration
   @return a term, which is a "blue print" for this sort, i.e., the `Fallback` for this term,
           i.e., the most general version of this term
           Example: F[ x :: Nat y :: Boolean . Nat, Nat ] :: Nat 
                     transforms to 
                     F[ x_0 x_1 . #0_[x_0, x_1], #1_]
   @note the definition of `form` is very permissive (`arguments?`)
          TODO: refine grammar
          for the moment, it is assumed, that `#freeTerm` indicates Data at this position,
          for a `#boundTerm`, the amount of consecutive binders indicates the amount of arguments
          Example Update: F[ x :: Nat y :: Boolean . Nat, Nat ] :: Nat actually looks like
                          F[ x y . Nat, Nat] :: Nat, whereby Nat is a Crsx_term
   @throw Error, if applied to Data sort
*/
BluePrint[ Crsx_sortDeclaration_sort] :: Crsx_term_sort;
BluePrint[ %sortDeclaration⟦ ##sortparams? ##sortset ##sortname ::= ( ##forms ) ⟧] 
  → Error[ ConcatString[ "BluePrintPattern is tried on data sort  \n", Show[#sortname]]];
BluePrint[ %sortDeclaration⟦ ##sortparams? ##sortset ##constructor ##arguments? :: ##sortname ⟧] 
  → %term⟦ ##constructor ⟨arguments?: WrapArguments[BluePrintArgs[UnwrapArguments[#arguments?], 0]]⟩ ⟧;

// Numeric, #n = Number of argument
BluePrintArgs[$List[Crsx_term_sort], $Numeric] :: $List[Crsx_term_sort];
BluePrintArgs[(), #n] → ();
BluePrintArgs[(%term⟦ ##freeTerm ⟧; #args), #n ] 
  /* meta variables of the shape `#n_` */
  → ( %term⟦ ⟨METAVAR: ConcatString[ConcatString["#", Show[#n]], "_"] ⟩ ⟧ 
      ; BluePrintArgs[#args, NumberPlus[#n,1]] );

BluePrintArgs[ (%term⟦ ##boundTerm ⟧; #args), #n ]
  /* case position has bound variables */ 
  → ( BluePrintArgsHelper[ ConcatString[ConcatString["#", Show[#n]], "_"], 
                           Reverse[BluePrintBoundVars[%term⟦ ##boundTerm ⟧, (), 0]]]
      ; BluePrintArgs[#args, NumberPlus[#n,1]]);

  BluePrintArgsHelper[$String, $List[Crsx_variable_sort]] :: Crsx_term_sort;
  BluePrintArgsHelper[#METAVAR, #args] → WrapBoundTerm[ #args, %term⟦ ##METAVAR ⟨freeArguments?: WrapMetaVariableArguments[#args] ⟩ ⟧];

  BluePrintBoundVars[ Crsx_term_sort, $List[Crsx_variable_sort], $Numeric] :: $List[Crsx_variable_sort];
  BluePrintBoundVars[ %term⟦ ##freeTerm ⟧, #args, #x ] 
  → #args;
  BluePrintBoundVars[ %term⟦ ##variable ##nextBinder ⟧, #args, #x ] 
  → BluePrintBoundVars[ UnwrapNextBinder[#nextBinder], (BluePrintBoundVarsHelper[ ConcatString["x_", Show[#x]]]; #args), NumberPlus[#x,1] ];
     BluePrintBoundVarsHelper[$String] :: Crsx_variable_sort;
     BluePrintBoundVarsHelper[ #VARIABLE ] → %variable⟦ ##VARIABLE ⟧;

/* ***************************************************** */
/*  VARIABLES                                            */
/* ***************************************************** */

/* FreeVariables
   @param  `t` a term 
   @return the list of free variables in `t`
   @note   contains duplicates, if variable occurs more than once
*/
FreeVariables[Crsx_term_sort] :: $List[Crsx_variable_sort];
FreeVariables[ #t ] → MatchFreeVariables[ Variables[#t] ];
  MatchFreeVariables[VARS] :: $List[Crsx_variable_sort];
  MatchFreeVariables[Vars[#M, #BV, #FV]] → #FV;


MetaVariables[Crsx_term_sort] :: $List[$String /* Crsx_METAVAR_sort */];
MetaVariables[ #t ] → MatchMetaVariables[ Variables[#t] ];
  MatchMetaVariables[VARS] :: $List[ $String /* Crsx_METAVAR_sort */ ];
  MatchMetaVariables[Vars[#M, #BV, #FV]] → #M;

/* VARS
  data sort to hold meta variables, bound variables, and free variables
 */
VARS ::= ( Vars[ $List[$String],              /* meta variables  */ 
                 $List[Crsx_variable_sort],   /* bound variables */ 
                 $List[Crsx_variable_sort] ]; /* free Variables  */ );
/* Variables
   @param  `t` a term
   @return `VARS` which hold in  
           1. component: meta variables of `t`
           2. component: bound variables of `t`  
           3. component: free variables of `t`
   @note that the components may contain duplicates, in particular if `t` is not linear
*/
Variables[Crsx_term_sort] :: VARS;
Variables[ #term ] →  VariablesHelperBoundVar[(), #term ];
  /* needed to carry the bound variables throughout the computation */
  VariablesHelperBoundVar[$List[Crsx_variable_sort], Crsx_term_sort] :: VARS;
  VariablesHelperBoundVar[#BV, #t] →
  VariablesHelper[Vars[(),(),()], #BV, #t];

  /* case: constructor */
  VariablesHelper[VARS, $List[Crsx_variable_sort], Crsx_term_sort] :: VARS;
  VariablesHelper[Vars[#M, #BV, #FV], #_,
                  %term⟦ ##annotations? ##properties? ##constructor ##arguments? ⟧ ]  
  →    
       ConcatVars[Vars[#M, #BV, #FV],           
                  Map[t .VariablesHelperBoundVar[#BV,t], UnwrapArguments[#arguments?]]];
  /* case: meta variable */
  VariablesHelper[Vars[#M, #BV, #FV], #_,
                 %term⟦ ##annotations? ##properties? ##METAVAR ##freeArguments? ⟧ ]
  →    
       ConcatVars[Vars[Insert[#METAVAR,#M], #BV, #FV],
                  Map[t . VariablesHelperBoundVar[#BV,t], UnwrapFreeArguments[#freeArguments?]]];
  /* case: abstraction/binder */
  VariablesHelper[Vars[#M, #BV, #FV], #currBV, 
                  %term⟦ ##annotations? ##variable ##nextBinder ⟧] 
  → 
  VariablesHelper[Vars[#M, Insert[#variable, #BV], #FV], Insert[#variable, #currBV], 
                  UnwrapNextBinder[#nextBinder]];
  /* case: variable */
  VariablesHelper[#VARS, #currBV, 
                  %term⟦ ##annotations? ##variable ⟧] 
  → 
    MatchVariablesHelper[Elem[#variable, #currBV], #variable, #VARS];
    /* match whether variable is bound in this branch or not */
      MatchVariablesHelper[Boolean, Crsx_variable_sort, VARS ] :: VARS; 
      MatchVariablesHelper[TRUE,  #variable, #VARS             ] → #VARS;
      MatchVariablesHelper[FALSE, #variable, Vars[#M, #BV, #FV]] → Vars[#M, #BV, Insert[#variable,#FV]]; 

/* ConcatVARS
   @param  `VARS`  an accumulator of VARS
   @param  `VARSs` an list of VARS
   @return the component-wise concatenation of each `VARS'` in `VARSs` to `VAR` 
*/
ConcatVars[VARS, $List[VARS] ] :: VARS;
ConcatVars[#VARS, #VARSs] → FoldlP[ vars varsAcc . ConcatVARSHelper[vars, varsAcc], #VARS, #VARSs];
  ConcatVARSHelper[VARS, VARS] :: VARS;
  ConcatVARSHelper[Vars[#M, #BV, #FV], Vars[#M2, #BV2, #FV2]] 
  → Vars[Concat[#M, #M2],Concat[#BV, #BV2],Concat[#FV, #FV2]];


/* ***************************************************** */
/*  Experimental Foldl                                   */
/* ***************************************************** */

// experimental/work in progress to fold over a term 

∀ a . TermFoldl[ v :: Crsx_variable_sort . $sort[a],
                 b :: Crsx_binder_sort t :: a. $sort[a], 
                 m :: $String  vs :: $List[a] . $sort[a],
                 c :: Crsx_constructor_sort ts :: $List[a] . $sort[a], Crsx_term_sort ] :: a;

 TermFoldl[v.#V[v], b t.#B[b, t], m xs.#M[m,xs], c ts.#F[c,ts], %term⟦ ##annotations? ##properties? ##constructor ##arguments? ⟧ ] 
 → 
 #F[#constructor, Map[ t. TermFoldl[ v.#V[v], b t . #B[b,t], m xs.#M[m,xs], c ts.#F[c,ts], t] , UnwrapArguments[#arguments?]]];
  
  /* case: meta var */
  TermFoldl[v.#V[v], b t . #B[b,t], m xs.#M[m,xs], c ts.#F[c,ts], %term⟦ ##annotations? ##properties? ##METAVAR ##freeArguments? ⟧ ]
 → #M[#METAVAR, Map[ t. TermFoldl[v.#V[v], b t . #B[b,t], m xs.#M[m,xs], c ts.#F[c,ts], t], UnwrapFreeArguments[#freeArguments?]]  ];

  /* case: abstraction/binder */
 TermFoldl[v.#V[v], b t . #B[b,t], m xs.#M[m,xs], c ts.#F[c,ts],  %term⟦ ##binder ##nextBinder ⟧]
  → #B[#binder, TermFoldl[v.#V[v], b t . #B[b,t], m xs.#M[m,xs], c ts.#F[c,ts], UnwrapNextBinder[#nextBinder]]];

  /* case: variable */
 TermFoldl[v.#V[v], b t . #B[b,t], m xs.#M[m,xs], c ts.#F[c,ts], %term⟦ ##annotations? ##variable ⟧ ] 
  → #V[#variable] ;

// to use for Termfoldl with i.e.,
// TermFoldl[ x . Var[x], b t. BVar[b,t], x ys . Meta[x,ys], c bs. Const[c,bs],  #term] == #term
Var[ Crsx_variable_sort ] :: Crsx_term_sort;
Var[ #variable ] → %term⟦ ##variable ⟧;

BVar[ Crsx_binder_sort, Crsx_term_sort] :: Crsx_term_sort;
BVar[ #binder, #term]  → %term⟦ ##binder ⟨nextBinder: WrapNextBinder[#term]⟩ ⟧;

Meta[ $String, $List[Crsx_term_sort] ] :: Crsx_term_sort;
-[Data[#METAVAR]] :
Meta[#METAVAR, #args] → %term⟦ ##METAVAR  ⟨freeArguments?: WrapFreeArguments2[#args] ⟩ ⟧;
 
Const[ Crsx_constructor_sort, $List[Crsx_term_sort]] :: Crsx_term_sort;
Const[ #constructor, #args ] → %term⟦ ##constructor ⟨arguments?: WrapArguments[#args] ⟩ ⟧;


/*
MetaR[ $String, $List[Crsx_term_sort] ] :: Crsx_term_sort;
-[ Free[x] ]:
MetaR[$[NotMatch,x,#METAVAR], #args] → Meta[ConcatString[#METAVAR, "_1"], #args];
*/


)]
