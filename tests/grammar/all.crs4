// Crsx can start with a module declaration. If not, put names in the global scope
module Test // No semicolon. Declarations are separated by lower case keywords (type, fn, etc...)
            // semicolon can be used in term expression, for instance for monads.
            // No curly braces to avoid indenting all declarations

// This is a type definition
// The name of a type can be anything expect the first character which must not be a lower case character, a digit and separators (,),(, space)
enum List<a>       // type parameters are specified between < >. Use space to separate them
    | Cons(a, List<a>)   // '|' is used to indicate the definition of a variant type
    | Nil

enum Statement
    | Let(Expr, [Expr] -> Expr)    // [] specifies scoped variables. -> says it's a function parameters.
    | Var(String)
    | var // allow variables

type Expr
    | Plus(Expr, Expr)
    | Number(Integer)

// Function type definition. Notice '->'
func TermList<a>(Expr) -> List<a> 
func HO<a>([Expr Expr] -> Expr) -> List<a>

// Function cannot return scoped functions. Must be wrapped
// Might relax for function
//func Invalid([Expr Expr] -> Expr) -> [Expr] -> List<a>

// Can also define associative array (map)
struct MyEnv
    & "key1" : Expr         // key1 has type Expr
    & String : String       // all other keys are of type String
// Potential confusion: String: String is not the same as String : String, since ':' is a valid symbol character

// This is a function. #expr is a called a meta-variable (just a variable in other programming languages)
// The parameter type is specified after ':'
// → marks the beginning of the function body
func Eval(#expr : Expr) -> Expr
→ dispatch (#expr)           // Dispatch variant value. Partial overlaps is allowed. Most specific case triggers first
    | Let(#expr)   → Eval(#body),    // ',' to separate between cases
    | Var(#string) → Eval(#string)

// Rule style.
rule TermList(#expr)
→ 3, 4, F       // This is a list (linked list).

rule EmptyList
→ ()         // Empty list

rule SingletonList
→ (Term,)  // List with 1 item. Notice the comma

rule GroupedTerm
→ (Term(G))   // (Term) is just a grouped term, for association.

rule ComplexTerm
→ ^($,!,:, Q :: A::A :: : ,::=,::>,*,&,>,<,?,|) // Very few restriction on what term name can be used

// <a is not a valid constructor, >a is. This is to adopt c++ type parameter style

// List patterns
rule CloseList( (#item1, #item2) ) // Match only a list of 2 items
→ #item1

rule OpenList( (#item1, #items ... ) ) // items matches a rest of the list
→ #items

// Prefix can be used to specify annotation on term expression
func prefix 1 @last<a>(#term : a) -> a
→ #term

// On type definition as well
func @copy<a> prefix 1 (a) -> a

// Prefixes are hard to read because the syntax is ambiguous
func Annotation1IsNotPrefix -> a
→ Annotation1 ( Arg )   // Arg is the argument of Annotation1. () is not a parentherized expression !

func prefix 1 Annotation2(#term : a) -> a
→ #term

fn Annotation2IsPrefix -> a
→ Annotation2 ( Term ) // Term is an annotated term in a group


// Rule arguments can be arbitrary patterns
rule ComplexHOPattern(Wrapper(#arg), [x] -> Callback(x), Input(⟦ let a := #1 return #2 ⟧))
→  Callback( (#1, #2, #arg, @last @copy #1 ) )

// Constructing maps
rule MyMap
→  { "key1" : "Value1",
     x : ArbitraryTerm( { "nestedmap" : b } ),
     other : :(#s1, #s2)
   }

// Map patterns
rule MyMapPattern( {#E}, {#E2, "key1" : #1, #2 : #3, ¬ #5})
→ #2

// Can define left-associative infix operators
func infixl 4 +(#expr : Expr, #expr : Expr) -> Expr
→ 45 + 32 + 1      // same as (45 + 32) + 1

// Or postfix operator
func postfix 2 !!(#expr : Expr) -> Expr
→ 45 + 32 + 1 !!     // same as ((45 + 32) + 1) !! because 2 < 4

// nested module declaration. :: is *NOT* an operator, just a name convention
//module Test::Sub

// All declarations below are in the Test::Nested module

// Concrete syntax, business as usual

func Test -> Expr
→ Test::Eval(⟦ let v := 4 return v ⟧)

// Different:
//→ Test :: Eval which is equivalent to ::(Test, Eval)

// Embedding Crsx in concrete syntax is customizable.
// However the recommended way is ⟨grammar_rule_name: ⟩ syntax (described in documentation).
func Test2 -> Expr
→ Eval(⟦ let v := 4 return ⟨expr: CreateExpr⟩ ⟧)

// Maybe monad

enum Maybe<a>
    | Just(a)
    | Nothing

func infixl 1 BindMaybe<a b>(#maybe : Maybe<a>, #make : (a) -> Maybe<b>) -> Maybe<b>
→ dispatch (#maybe)
    | Just(#) → #make(#),
    | Nothing → Nothing


func ReturnMaybe<a>(#v: a) -> Maybe<a>
→ Just(a)

func Ex
→ Just(1) BindMaybe (x) -> Just(x + 1)
